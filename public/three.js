(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload"))
        return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]'))
        n(i);
    new MutationObserver(i => {
        for (const r of i)
            if (r.type === "childList")
                for (const o of r.addedNodes)
                    o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }
    ).observe(document, {
        childList: !0,
        subtree: !0
    });
    function t(i) {
        const r = {};
        return i.integrity && (r.integrity = i.integrity),
        i.referrerPolicy && (r.referrerPolicy = i.referrerPolicy),
        i.crossOrigin === "use-credentials" ? r.credentials = "include" : i.crossOrigin === "anonymous" ? r.credentials = "omit" : r.credentials = "same-origin",
        r
    }
    function n(i) {
        if (i.ep)
            return;
        i.ep = !0;
        const r = t(i);
        fetch(i.href, r)
    }
}
)();
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const ia = "168"
  , Ai = {
    LEFT: 0,
    MIDDLE: 1,
    RIGHT: 2,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2
}
  , Ei = {
    ROTATE: 0,
    PAN: 1,
    DOLLY_PAN: 2,
    DOLLY_ROTATE: 3
}
  , yh = 0
  , Oa = 1
  , Sh = 2
  , fc = 1
  , pc = 2
  , yn = 3
  , Jt = 0
  , It = 1
  , Bt = 2
  , Vn = 0
  , Ri = 1
  , Ba = 2
  , za = 3
  , ka = 4
  , bh = 5
  , ei = 100
  , Eh = 101
  , Th = 102
  , wh = 103
  , Ah = 104
  , Rh = 200
  , Ch = 201
  , Ph = 202
  , Dh = 203
  , go = 204
  , Mo = 205
  , Lh = 206
  , Ih = 207
  , Uh = 208
  , Nh = 209
  , Fh = 210
  , Oh = 211
  , Bh = 212
  , zh = 213
  , kh = 214
  , Hh = 0
  , Gh = 1
  , Vh = 2
  , dr = 3
  , Wh = 4
  , Xh = 5
  , qh = 6
  , Yh = 7
  , mc = 0
  , jh = 1
  , Kh = 2
  , Rn = 0
  , gc = 1
  , Mc = 2
  , _c = 3
  , vc = 4
  , xc = 5
  , yc = 6
  , Sc = 7
  , Ha = "attached"
  , $h = "detached"
  , bc = 300
  , Ui = 301
  , Ni = 302
  , _o = 303
  , vo = 304
  , vr = 306
  , Fi = 1e3
  , sn = 1001
  , ur = 1002
  , Ct = 1003
  , Ec = 1004
  , is = 1005
  , _t = 1006
  , ir = 1007
  , rn = 1008
  , Cn = 1009
  , Tc = 1010
  , wc = 1011
  , hs = 1012
  , sa = 1013
  , ni = 1014
  , Pt = 1015
  , on = 1016
  , ra = 1017
  , oa = 1018
  , Oi = 1020
  , Ac = 35902
  , Rc = 1021
  , Cc = 1022
  , Gt = 1023
  , Pc = 1024
  , Dc = 1025
  , Ci = 1026
  , Bi = 1027
  , aa = 1028
  , la = 1029
  , Lc = 1030
  , ca = 1031
  , ha = 1033
  , sr = 33776
  , rr = 33777
  , or = 33778
  , ar = 33779
  , xo = 35840
  , yo = 35841
  , So = 35842
  , bo = 35843
  , Eo = 36196
  , To = 37492
  , wo = 37496
  , Ao = 37808
  , Ro = 37809
  , Co = 37810
  , Po = 37811
  , Do = 37812
  , Lo = 37813
  , Io = 37814
  , Uo = 37815
  , No = 37816
  , Fo = 37817
  , Oo = 37818
  , Bo = 37819
  , zo = 37820
  , ko = 37821
  , lr = 36492
  , Ho = 36494
  , Go = 36495
  , Ic = 36283
  , Vo = 36284
  , Wo = 36285
  , Xo = 36286
  , ds = 2300
  , us = 2301
  , Dr = 2302
  , Ga = 2400
  , Va = 2401
  , Wa = 2402
  , Zh = 2500
  , Jh = 0
  , Uc = 1
  , qo = 2
  , Qh = 3200
  , ed = 3201
  , Nc = 0
  , td = 1
  , Hn = ""
  , Tt = "srgb"
  , xt = "srgb-linear"
  , da = "display-p3"
  , xr = "display-p3-linear"
  , fr = "linear"
  , st = "srgb"
  , pr = "rec709"
  , mr = "p3"
  , kn = 7680
  , fs = 7681
  , Xa = 517
  , ii = 519
  , nd = 512
  , id = 513
  , sd = 514
  , Fc = 515
  , rd = 516
  , od = 517
  , ad = 518
  , ld = 519
  , Yo = 35044
  , qa = "300 es"
  , Tn = 2e3
  , gr = 2001;
class ri {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []),
        n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0)
            return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0)
            return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const r = i.indexOf(t);
            r !== -1 && i.splice(r, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0)
            return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let r = 0, o = i.length; r < o; r++)
                i[r].call(this, e);
            e.target = null
        }
    }
}
const bt = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let Ya = 1234567;
const rs = Math.PI / 180
  , zi = 180 / Math.PI;
function Vt() {
    const s = Math.random() * 4294967295 | 0
      , e = Math.random() * 4294967295 | 0
      , t = Math.random() * 4294967295 | 0
      , n = Math.random() * 4294967295 | 0;
    return (bt[s & 255] + bt[s >> 8 & 255] + bt[s >> 16 & 255] + bt[s >> 24 & 255] + "-" + bt[e & 255] + bt[e >> 8 & 255] + "-" + bt[e >> 16 & 15 | 64] + bt[e >> 24 & 255] + "-" + bt[t & 63 | 128] + bt[t >> 8 & 255] + "-" + bt[t >> 16 & 255] + bt[t >> 24 & 255] + bt[n & 255] + bt[n >> 8 & 255] + bt[n >> 16 & 255] + bt[n >> 24 & 255]).toLowerCase()
}
function ft(s, e, t) {
    return Math.max(e, Math.min(t, s))
}
function ua(s, e) {
    return (s % e + e) % e
}
function cd(s, e, t, n, i) {
    return n + (s - e) * (i - n) / (t - e)
}
function hd(s, e, t) {
    return s !== e ? (t - s) / (e - s) : 0
}
function os(s, e, t) {
    return (1 - t) * s + t * e
}
function dd(s, e, t, n) {
    return os(s, e, 1 - Math.exp(-t * n))
}
function ud(s, e=1) {
    return e - Math.abs(ua(s, e * 2) - e)
}
function fd(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e),
    s * s * (3 - 2 * s))
}
function pd(s, e, t) {
    return s <= e ? 0 : s >= t ? 1 : (s = (s - e) / (t - e),
    s * s * s * (s * (s * 6 - 15) + 10))
}
function md(s, e) {
    return s + Math.floor(Math.random() * (e - s + 1))
}
function gd(s, e) {
    return s + Math.random() * (e - s)
}
function Md(s) {
    return s * (.5 - Math.random())
}
function _d(s) {
    s !== void 0 && (Ya = s);
    let e = Ya += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1),
    e ^= e + Math.imul(e ^ e >>> 7, e | 61),
    ((e ^ e >>> 14) >>> 0) / 4294967296
}
function vd(s) {
    return s * rs
}
function xd(s) {
    return s * zi
}
function yd(s) {
    return (s & s - 1) === 0 && s !== 0
}
function Sd(s) {
    return Math.pow(2, Math.ceil(Math.log(s) / Math.LN2))
}
function bd(s) {
    return Math.pow(2, Math.floor(Math.log(s) / Math.LN2))
}
function Ed(s, e, t, n, i) {
    const r = Math.cos
      , o = Math.sin
      , a = r(t / 2)
      , l = o(t / 2)
      , c = r((e + n) / 2)
      , h = o((e + n) / 2)
      , d = r((e - n) / 2)
      , u = o((e - n) / 2)
      , f = r((n - e) / 2)
      , g = o((n - e) / 2);
    switch (i) {
    case "XYX":
        s.set(a * h, l * d, l * u, a * c);
        break;
    case "YZY":
        s.set(l * u, a * h, l * d, a * c);
        break;
    case "ZXZ":
        s.set(l * d, l * u, a * h, a * c);
        break;
    case "XZX":
        s.set(a * h, l * g, l * f, a * c);
        break;
    case "YXY":
        s.set(l * f, a * h, l * g, a * c);
        break;
    case "ZYZ":
        s.set(l * g, l * f, a * h, a * c);
        break;
    default:
        console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}
function Kt(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return s / 4294967295;
    case Uint16Array:
        return s / 65535;
    case Uint8Array:
        return s / 255;
    case Int32Array:
        return Math.max(s / 2147483647, -1);
    case Int16Array:
        return Math.max(s / 32767, -1);
    case Int8Array:
        return Math.max(s / 127, -1);
    default:
        throw new Error("Invalid component type.")
    }
}
function et(s, e) {
    switch (e.constructor) {
    case Float32Array:
        return s;
    case Uint32Array:
        return Math.round(s * 4294967295);
    case Uint16Array:
        return Math.round(s * 65535);
    case Uint8Array:
        return Math.round(s * 255);
    case Int32Array:
        return Math.round(s * 2147483647);
    case Int16Array:
        return Math.round(s * 32767);
    case Int8Array:
        return Math.round(s * 127);
    default:
        throw new Error("Invalid component type.")
    }
}
const Oc = {
    DEG2RAD: rs,
    RAD2DEG: zi,
    generateUUID: Vt,
    clamp: ft,
    euclideanModulo: ua,
    mapLinear: cd,
    inverseLerp: hd,
    lerp: os,
    damp: dd,
    pingpong: ud,
    smoothstep: fd,
    smootherstep: pd,
    randInt: md,
    randFloat: gd,
    randFloatSpread: Md,
    seededRandom: _d,
    degToRad: vd,
    radToDeg: xd,
    isPowerOfTwo: yd,
    ceilPowerOfTwo: Sd,
    floorPowerOfTwo: bd,
    setQuaternionFromProperEuler: Ed,
    normalize: et,
    denormalize: Kt
};
class ee {
    constructor(e=0, t=0) {
        ee.prototype.isVector2 = !0,
        this.x = e,
        this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e,
        this.y = t,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6],
        this.y = i[1] * t + i[4] * n + i[7],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(ft(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this
    }
    rotateAround(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = this.x - e.x
          , o = this.y - e.y;
        return this.x = r * n - o * i + e.x,
        this.y = r * i + o * n + e.y,
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y
    }
}
class He {
    constructor(e, t, n, i, r, o, a, l, c) {
        He.prototype.isMatrix3 = !0,
        this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, r, o, a, l, c)
    }
    set(e, t, n, i, r, o, a, l, c) {
        const h = this.elements;
        return h[0] = e,
        h[1] = i,
        h[2] = a,
        h[3] = t,
        h[4] = r,
        h[5] = l,
        h[6] = n,
        h[7] = o,
        h[8] = c,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1),
        this
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0),
        t.setFromMatrix3Column(this, 1),
        n.setFromMatrix3Column(this, 2),
        this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]),
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , o = n[0]
          , a = n[3]
          , l = n[6]
          , c = n[1]
          , h = n[4]
          , d = n[7]
          , u = n[2]
          , f = n[5]
          , g = n[8]
          , M = i[0]
          , m = i[3]
          , p = i[6]
          , E = i[1]
          , _ = i[4]
          , v = i[7]
          , L = i[2]
          , P = i[5]
          , A = i[8];
        return r[0] = o * M + a * E + l * L,
        r[3] = o * m + a * _ + l * P,
        r[6] = o * p + a * v + l * A,
        r[1] = c * M + h * E + d * L,
        r[4] = c * m + h * _ + d * P,
        r[7] = c * p + h * v + d * A,
        r[2] = u * M + f * E + g * L,
        r[5] = u * m + f * _ + g * P,
        r[8] = u * p + f * v + g * A,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[3] *= e,
        t[6] *= e,
        t[1] *= e,
        t[4] *= e,
        t[7] *= e,
        t[2] *= e,
        t[5] *= e,
        t[8] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8];
        return t * o * h - t * a * c - n * r * h + n * a * l + i * r * c - i * o * l
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , d = h * o - a * c
          , u = a * l - h * r
          , f = c * r - o * l
          , g = t * d + n * u + i * f;
        if (g === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const M = 1 / g;
        return e[0] = d * M,
        e[1] = (i * c - h * n) * M,
        e[2] = (a * n - i * o) * M,
        e[3] = u * M,
        e[4] = (h * t - i * l) * M,
        e[5] = (i * r - a * t) * M,
        e[6] = f * M,
        e[7] = (n * l - c * t) * M,
        e[8] = (o * t - n * r) * M,
        this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1],
        t[1] = t[3],
        t[3] = e,
        e = t[2],
        t[2] = t[6],
        t[6] = e,
        e = t[5],
        t[5] = t[7],
        t[7] = e,
        this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0],
        e[1] = t[3],
        e[2] = t[6],
        e[3] = t[1],
        e[4] = t[4],
        e[5] = t[7],
        e[6] = t[2],
        e[7] = t[5],
        e[8] = t[8],
        this
    }
    setUvTransform(e, t, n, i, r, o, a) {
        const l = Math.cos(r)
          , c = Math.sin(r);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1),
        this
    }
    scale(e, t) {
        return this.premultiply(Lr.makeScale(e, t)),
        this
    }
    rotate(e) {
        return this.premultiply(Lr.makeRotation(-e)),
        this
    }
    translate(e, t) {
        return this.premultiply(Lr.makeTranslation(e, t)),
        this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1),
        this
    }
    makeRotation(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1),
        this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1),
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 9; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const Lr = new He;
function Bc(s) {
    for (let e = s.length - 1; e >= 0; --e)
        if (s[e] >= 65535)
            return !0;
    return !1
}
function ps(s) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", s)
}
function Td() {
    const s = ps("canvas");
    return s.style.display = "block",
    s
}
const ja = {};
function Pi(s) {
    s in ja || (ja[s] = !0,
    console.warn(s))
}
function wd(s, e, t) {
    return new Promise(function(n, i) {
        function r() {
            switch (s.clientWaitSync(e, s.SYNC_FLUSH_COMMANDS_BIT, 0)) {
            case s.WAIT_FAILED:
                i();
                break;
            case s.TIMEOUT_EXPIRED:
                setTimeout(r, t);
                break;
            default:
                n()
            }
        }
        setTimeout(r, t)
    }
    )
}
const Ka = new He().set(.8224621, .177538, 0, .0331941, .9668058, 0, .0170827, .0723974, .9105199)
  , $a = new He().set(1.2249401, -.2249404, 0, -.0420569, 1.0420571, 0, -.0196376, -.0786361, 1.0982735)
  , Yi = {
    [xt]: {
        transfer: fr,
        primaries: pr,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: s => s,
        fromReference: s => s
    },
    [Tt]: {
        transfer: st,
        primaries: pr,
        luminanceCoefficients: [.2126, .7152, .0722],
        toReference: s => s.convertSRGBToLinear(),
        fromReference: s => s.convertLinearToSRGB()
    },
    [xr]: {
        transfer: fr,
        primaries: mr,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: s => s.applyMatrix3($a),
        fromReference: s => s.applyMatrix3(Ka)
    },
    [da]: {
        transfer: st,
        primaries: mr,
        luminanceCoefficients: [.2289, .6917, .0793],
        toReference: s => s.convertSRGBToLinear().applyMatrix3($a),
        fromReference: s => s.applyMatrix3(Ka).convertLinearToSRGB()
    }
}
  , Ad = new Set([xt, xr])
  , je = {
    enabled: !0,
    _workingColorSpace: xt,
    get workingColorSpace() {
        return this._workingColorSpace
    },
    set workingColorSpace(s) {
        if (!Ad.has(s))
            throw new Error(`Unsupported working color space, "${s}".`);
        this._workingColorSpace = s
    },
    convert: function(s, e, t) {
        if (this.enabled === !1 || e === t || !e || !t)
            return s;
        const n = Yi[e].toReference
          , i = Yi[t].fromReference;
        return i(n(s))
    },
    fromWorkingColorSpace: function(s, e) {
        return this.convert(s, this._workingColorSpace, e)
    },
    toWorkingColorSpace: function(s, e) {
        return this.convert(s, e, this._workingColorSpace)
    },
    getPrimaries: function(s) {
        return Yi[s].primaries
    },
    getTransfer: function(s) {
        return s === Hn ? fr : Yi[s].transfer
    },
    getLuminanceCoefficients: function(s, e=this._workingColorSpace) {
        return s.fromArray(Yi[e].luminanceCoefficients)
    }
};
function Di(s) {
    return s < .04045 ? s * .0773993808 : Math.pow(s * .9478672986 + .0521327014, 2.4)
}
function Ir(s) {
    return s < .0031308 ? s * 12.92 : 1.055 * Math.pow(s, .41666) - .055
}
let ai;
class Rd {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u")
            return e.src;
        let t;
        if (e instanceof HTMLCanvasElement)
            t = e;
        else {
            ai === void 0 && (ai = ps("canvas")),
            ai.width = e.width,
            ai.height = e.height;
            const n = ai.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height),
            t = ai
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e),
        t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = ps("canvas");
            t.width = e.width,
            t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height)
              , r = i.data;
            for (let o = 0; o < r.length; o++)
                r[o] = Di(r[o] / 255) * 255;
            return n.putImageData(i, 0, 0),
            t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++)
                t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(Di(t[n] / 255) * 255) : t[n] = Di(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else
            return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."),
            e
    }
}
let Cd = 0;
class zc {
    constructor(e=null) {
        this.isSource = !0,
        Object.defineProperty(this, "id", {
            value: Cd++
        }),
        this.uuid = Vt(),
        this.data = e,
        this.dataReady = !0,
        this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0)
            return e.images[this.uuid];
        const n = {
            uuid: this.uuid,
            url: ""
        }
          , i = this.data;
        if (i !== null) {
            let r;
            if (Array.isArray(i)) {
                r = [];
                for (let o = 0, a = i.length; o < a; o++)
                    i[o].isDataTexture ? r.push(Ur(i[o].image)) : r.push(Ur(i[o]))
            } else
                r = Ur(i);
            n.url = r
        }
        return t || (e.images[this.uuid] = n),
        n
    }
}
function Ur(s) {
    return typeof HTMLImageElement < "u" && s instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && s instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && s instanceof ImageBitmap ? Rd.getDataURL(s) : s.data ? {
        data: Array.from(s.data),
        width: s.width,
        height: s.height,
        type: s.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."),
    {})
}
let Pd = 0;
class vt extends ri {
    constructor(e=vt.DEFAULT_IMAGE, t=vt.DEFAULT_MAPPING, n=sn, i=sn, r=_t, o=rn, a=Gt, l=Cn, c=vt.DEFAULT_ANISOTROPY, h=Hn) {
        super(),
        this.isTexture = !0,
        Object.defineProperty(this, "id", {
            value: Pd++
        }),
        this.uuid = Vt(),
        this.name = "",
        this.source = new zc(e),
        this.mipmaps = [],
        this.mapping = t,
        this.channel = 0,
        this.wrapS = n,
        this.wrapT = i,
        this.magFilter = r,
        this.minFilter = o,
        this.anisotropy = c,
        this.format = a,
        this.internalFormat = null,
        this.type = l,
        this.offset = new ee(0,0),
        this.repeat = new ee(1,1),
        this.center = new ee(0,0),
        this.rotation = 0,
        this.matrixAutoUpdate = !0,
        this.matrix = new He,
        this.generateMipmaps = !0,
        this.premultiplyAlpha = !1,
        this.flipY = !0,
        this.unpackAlignment = 4,
        this.colorSpace = h,
        this.userData = {},
        this.version = 0,
        this.onUpdate = null,
        this.isRenderTargetTexture = !1,
        this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e=null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name,
        this.source = e.source,
        this.mipmaps = e.mipmaps.slice(0),
        this.mapping = e.mapping,
        this.channel = e.channel,
        this.wrapS = e.wrapS,
        this.wrapT = e.wrapT,
        this.magFilter = e.magFilter,
        this.minFilter = e.minFilter,
        this.anisotropy = e.anisotropy,
        this.format = e.format,
        this.internalFormat = e.internalFormat,
        this.type = e.type,
        this.offset.copy(e.offset),
        this.repeat.copy(e.repeat),
        this.center.copy(e.center),
        this.rotation = e.rotation,
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrix.copy(e.matrix),
        this.generateMipmaps = e.generateMipmaps,
        this.premultiplyAlpha = e.premultiplyAlpha,
        this.flipY = e.flipY,
        this.unpackAlignment = e.unpackAlignment,
        this.colorSpace = e.colorSpace,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this.needsUpdate = !0,
        this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0)
            return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData),
        t || (e.textures[this.uuid] = n),
        n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== bc)
            return e;
        if (e.applyMatrix3(this.matrix),
        e.x < 0 || e.x > 1)
            switch (this.wrapS) {
            case Fi:
                e.x = e.x - Math.floor(e.x);
                break;
            case sn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case ur:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
            }
        if (e.y < 0 || e.y > 1)
            switch (this.wrapT) {
            case Fi:
                e.y = e.y - Math.floor(e.y);
                break;
            case sn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case ur:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
            }
        return this.flipY && (e.y = 1 - e.y),
        e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++,
        this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
vt.DEFAULT_IMAGE = null;
vt.DEFAULT_MAPPING = bc;
vt.DEFAULT_ANISOTROPY = 1;
class Qe {
    constructor(e=0, t=0, n=0, i=1) {
        Qe.prototype.isVector4 = !0,
        this.x = e,
        this.y = t,
        this.z = n,
        this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e,
        this.y = t,
        this.z = n,
        this.w = i,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this.w = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setW(e) {
        return this.w = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        case 3:
            this.w = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        case 3:
            return this.w;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z,this.w)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this.w = e.w !== void 0 ? e.w : 1,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this.w += e.w,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this.w += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this.w = e.w + t.w,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this.w += e.w * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this.w -= e.w,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this.w -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this.w = e.w - t.w,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this.w *= e.w,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this.w *= e,
        this
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = this.w
          , o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * r,
        this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * r,
        this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * r,
        this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * r,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1,
        this.y = 0,
        this.z = 0) : (this.x = e.x / t,
        this.y = e.y / t,
        this.z = e.z / t),
        this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, r;
        const l = e.elements
          , c = l[0]
          , h = l[4]
          , d = l[8]
          , u = l[1]
          , f = l[5]
          , g = l[9]
          , M = l[2]
          , m = l[6]
          , p = l[10];
        if (Math.abs(h - u) < .01 && Math.abs(d - M) < .01 && Math.abs(g - m) < .01) {
            if (Math.abs(h + u) < .1 && Math.abs(d + M) < .1 && Math.abs(g + m) < .1 && Math.abs(c + f + p - 3) < .1)
                return this.set(1, 0, 0, 0),
                this;
            t = Math.PI;
            const _ = (c + 1) / 2
              , v = (f + 1) / 2
              , L = (p + 1) / 2
              , P = (h + u) / 4
              , A = (d + M) / 4
              , w = (g + m) / 4;
            return _ > v && _ > L ? _ < .01 ? (n = 0,
            i = .707106781,
            r = .707106781) : (n = Math.sqrt(_),
            i = P / n,
            r = A / n) : v > L ? v < .01 ? (n = .707106781,
            i = 0,
            r = .707106781) : (i = Math.sqrt(v),
            n = P / i,
            r = w / i) : L < .01 ? (n = .707106781,
            i = .707106781,
            r = 0) : (r = Math.sqrt(L),
            n = A / r,
            i = w / r),
            this.set(n, i, r, t),
            this
        }
        let E = Math.sqrt((m - g) * (m - g) + (d - M) * (d - M) + (u - h) * (u - h));
        return Math.abs(E) < .001 && (E = 1),
        this.x = (m - g) / E,
        this.y = (d - M) / E,
        this.z = (u - h) / E,
        this.w = Math.acos((c + f + p - 1) / 2),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this.w = t[15],
        this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this.w = Math.min(this.w, e.w),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this.w = Math.max(this.w, e.w),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this.w = Math.max(e.w, Math.min(t.w, this.w)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this.w = Math.max(e, Math.min(t, this.w)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this.w = Math.floor(this.w),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this.w = Math.ceil(this.w),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this.w = Math.round(this.w),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this.w = Math.trunc(this.w),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this.w = -this.w,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this.w += (e.w - this.w) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this.w = e.w + (t.w - e.w) * n,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this.w = e[t + 3],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e[t + 3] = this.w,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this.w = e.getW(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this.w = Math.random(),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z,
        yield this.w
    }
}
class Dd extends ri {
    constructor(e=1, t=1, n={}) {
        super(),
        this.isRenderTarget = !0,
        this.width = e,
        this.height = t,
        this.depth = 1,
        this.scissor = new Qe(0,0,e,t),
        this.scissorTest = !1,
        this.viewport = new Qe(0,0,e,t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: _t,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, n);
        const r = new vt(i,n.mapping,n.wrapS,n.wrapT,n.magFilter,n.minFilter,n.format,n.type,n.anisotropy,n.colorSpace);
        r.flipY = !1,
        r.generateMipmaps = n.generateMipmaps,
        r.internalFormat = n.internalFormat,
        this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++)
            this.textures[a] = r.clone(),
            this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = n.depthBuffer,
        this.stencilBuffer = n.stencilBuffer,
        this.resolveDepthBuffer = n.resolveDepthBuffer,
        this.resolveStencilBuffer = n.resolveStencilBuffer,
        this.depthTexture = n.depthTexture,
        this.samples = n.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, n=1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e,
            this.height = t,
            this.depth = n;
            for (let i = 0, r = this.textures.length; i < r; i++)
                this.textures[i].image.width = e,
                this.textures[i].image.height = t,
                this.textures[i].image.depth = n;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t),
        this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width,
        this.height = e.height,
        this.depth = e.depth,
        this.scissor.copy(e.scissor),
        this.scissorTest = e.scissorTest,
        this.viewport.copy(e.viewport),
        this.textures.length = 0;
        for (let n = 0, i = e.textures.length; n < i; n++)
            this.textures[n] = e.textures[n].clone(),
            this.textures[n].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new zc(t),
        this.depthBuffer = e.depthBuffer,
        this.stencilBuffer = e.stencilBuffer,
        this.resolveDepthBuffer = e.resolveDepthBuffer,
        this.resolveStencilBuffer = e.resolveStencilBuffer,
        e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()),
        this.samples = e.samples,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Wn extends Dd {
    constructor(e=1, t=1, n={}) {
        super(e, t, n),
        this.isWebGLRenderTarget = !0
    }
}
class kc extends vt {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isDataArrayTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Ct,
        this.minFilter = Ct,
        this.wrapR = sn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1,
        this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class Ld extends vt {
    constructor(e=null, t=1, n=1, i=1) {
        super(null),
        this.isData3DTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        },
        this.magFilter = Ct,
        this.minFilter = Ct,
        this.wrapR = sn,
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
class ln {
    constructor(e=0, t=0, n=0, i=1) {
        this.isQuaternion = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._w = i
    }
    static slerpFlat(e, t, n, i, r, o, a) {
        let l = n[i + 0]
          , c = n[i + 1]
          , h = n[i + 2]
          , d = n[i + 3];
        const u = r[o + 0]
          , f = r[o + 1]
          , g = r[o + 2]
          , M = r[o + 3];
        if (a === 0) {
            e[t + 0] = l,
            e[t + 1] = c,
            e[t + 2] = h,
            e[t + 3] = d;
            return
        }
        if (a === 1) {
            e[t + 0] = u,
            e[t + 1] = f,
            e[t + 2] = g,
            e[t + 3] = M;
            return
        }
        if (d !== M || l !== u || c !== f || h !== g) {
            let m = 1 - a;
            const p = l * u + c * f + h * g + d * M
              , E = p >= 0 ? 1 : -1
              , _ = 1 - p * p;
            if (_ > Number.EPSILON) {
                const L = Math.sqrt(_)
                  , P = Math.atan2(L, p * E);
                m = Math.sin(m * P) / L,
                a = Math.sin(a * P) / L
            }
            const v = a * E;
            if (l = l * m + u * v,
            c = c * m + f * v,
            h = h * m + g * v,
            d = d * m + M * v,
            m === 1 - a) {
                const L = 1 / Math.sqrt(l * l + c * c + h * h + d * d);
                l *= L,
                c *= L,
                h *= L,
                d *= L
            }
        }
        e[t] = l,
        e[t + 1] = c,
        e[t + 2] = h,
        e[t + 3] = d
    }
    static multiplyQuaternionsFlat(e, t, n, i, r, o) {
        const a = n[i]
          , l = n[i + 1]
          , c = n[i + 2]
          , h = n[i + 3]
          , d = r[o]
          , u = r[o + 1]
          , f = r[o + 2]
          , g = r[o + 3];
        return e[t] = a * g + h * d + l * f - c * u,
        e[t + 1] = l * g + h * u + c * d - a * f,
        e[t + 2] = c * g + h * f + a * u - l * d,
        e[t + 3] = h * g - a * d - l * u - c * f,
        e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e,
        this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._w = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._w)
    }
    copy(e) {
        return this._x = e.x,
        this._y = e.y,
        this._z = e.z,
        this._w = e.w,
        this._onChangeCallback(),
        this
    }
    setFromEuler(e, t=!0) {
        const n = e._x
          , i = e._y
          , r = e._z
          , o = e._order
          , a = Math.cos
          , l = Math.sin
          , c = a(n / 2)
          , h = a(i / 2)
          , d = a(r / 2)
          , u = l(n / 2)
          , f = l(i / 2)
          , g = l(r / 2);
        switch (o) {
        case "XYZ":
            this._x = u * h * d + c * f * g,
            this._y = c * f * d - u * h * g,
            this._z = c * h * g + u * f * d,
            this._w = c * h * d - u * f * g;
            break;
        case "YXZ":
            this._x = u * h * d + c * f * g,
            this._y = c * f * d - u * h * g,
            this._z = c * h * g - u * f * d,
            this._w = c * h * d + u * f * g;
            break;
        case "ZXY":
            this._x = u * h * d - c * f * g,
            this._y = c * f * d + u * h * g,
            this._z = c * h * g + u * f * d,
            this._w = c * h * d - u * f * g;
            break;
        case "ZYX":
            this._x = u * h * d - c * f * g,
            this._y = c * f * d + u * h * g,
            this._z = c * h * g - u * f * d,
            this._w = c * h * d + u * f * g;
            break;
        case "YZX":
            this._x = u * h * d + c * f * g,
            this._y = c * f * d + u * h * g,
            this._z = c * h * g - u * f * d,
            this._w = c * h * d - u * f * g;
            break;
        case "XZY":
            this._x = u * h * d - c * f * g,
            this._y = c * f * d - u * h * g,
            this._z = c * h * g + u * f * d,
            this._w = c * h * d + u * f * g;
            break;
        default:
            console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(),
        this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2
          , i = Math.sin(n);
        return this._x = e.x * i,
        this._y = e.y * i,
        this._z = e.z * i,
        this._w = Math.cos(n),
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e) {
        const t = e.elements
          , n = t[0]
          , i = t[4]
          , r = t[8]
          , o = t[1]
          , a = t[5]
          , l = t[9]
          , c = t[2]
          , h = t[6]
          , d = t[10]
          , u = n + a + d;
        if (u > 0) {
            const f = .5 / Math.sqrt(u + 1);
            this._w = .25 / f,
            this._x = (h - l) * f,
            this._y = (r - c) * f,
            this._z = (o - i) * f
        } else if (n > a && n > d) {
            const f = 2 * Math.sqrt(1 + n - a - d);
            this._w = (h - l) / f,
            this._x = .25 * f,
            this._y = (i + o) / f,
            this._z = (r + c) / f
        } else if (a > d) {
            const f = 2 * Math.sqrt(1 + a - n - d);
            this._w = (r - c) / f,
            this._x = (i + o) / f,
            this._y = .25 * f,
            this._z = (l + h) / f
        } else {
            const f = 2 * Math.sqrt(1 + d - n - a);
            this._w = (o - i) / f,
            this._x = (r + c) / f,
            this._y = (l + h) / f,
            this._z = .25 * f
        }
        return this._onChangeCallback(),
        this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0,
        Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y,
        this._y = e.x,
        this._z = 0,
        this._w = n) : (this._x = 0,
        this._y = -e.z,
        this._z = e.y,
        this._w = n)) : (this._x = e.y * t.z - e.z * t.y,
        this._y = e.z * t.x - e.x * t.z,
        this._z = e.x * t.y - e.y * t.x,
        this._w = n),
        this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(ft(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0)
            return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i),
        this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1,
        this._y *= -1,
        this._z *= -1,
        this._onChangeCallback(),
        this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0,
        this._y = 0,
        this._z = 0,
        this._w = 1) : (e = 1 / e,
        this._x = this._x * e,
        this._y = this._y * e,
        this._z = this._z * e,
        this._w = this._w * e),
        this._onChangeCallback(),
        this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x
          , i = e._y
          , r = e._z
          , o = e._w
          , a = t._x
          , l = t._y
          , c = t._z
          , h = t._w;
        return this._x = n * h + o * a + i * c - r * l,
        this._y = i * h + o * l + r * a - n * c,
        this._z = r * h + o * c + n * l - i * a,
        this._w = o * h - n * a - i * l - r * c,
        this._onChangeCallback(),
        this
    }
    slerp(e, t) {
        if (t === 0)
            return this;
        if (t === 1)
            return this.copy(e);
        const n = this._x
          , i = this._y
          , r = this._z
          , o = this._w;
        let a = o * e._w + n * e._x + i * e._y + r * e._z;
        if (a < 0 ? (this._w = -e._w,
        this._x = -e._x,
        this._y = -e._y,
        this._z = -e._z,
        a = -a) : this.copy(e),
        a >= 1)
            return this._w = o,
            this._x = n,
            this._y = i,
            this._z = r,
            this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const f = 1 - t;
            return this._w = f * o + t * this._w,
            this._x = f * n + t * this._x,
            this._y = f * i + t * this._y,
            this._z = f * r + t * this._z,
            this.normalize(),
            this
        }
        const c = Math.sqrt(l)
          , h = Math.atan2(c, a)
          , d = Math.sin((1 - t) * h) / c
          , u = Math.sin(t * h) / c;
        return this._w = o * d + this._w * u,
        this._x = n * d + this._x * u,
        this._y = i * d + this._y * u,
        this._z = r * d + this._z * u,
        this._onChangeCallback(),
        this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random()
          , t = 2 * Math.PI * Math.random()
          , n = Math.random()
          , i = Math.sqrt(1 - n)
          , r = Math.sqrt(n);
        return this.set(i * Math.sin(e), i * Math.cos(e), r * Math.sin(t), r * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t=0) {
        return this._x = e[t],
        this._y = e[t + 1],
        this._z = e[t + 2],
        this._w = e[t + 3],
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._w,
        e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t),
        this._y = e.getY(t),
        this._z = e.getZ(t),
        this._w = e.getW(t),
        this._onChangeCallback(),
        this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._w
    }
}
class C {
    constructor(e=0, t=0, n=0) {
        C.prototype.isVector3 = !0,
        this.x = e,
        this.y = t,
        this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z),
        this.x = e,
        this.y = t,
        this.z = n,
        this
    }
    setScalar(e) {
        return this.x = e,
        this.y = e,
        this.z = e,
        this
    }
    setX(e) {
        return this.x = e,
        this
    }
    setY(e) {
        return this.y = e,
        this
    }
    setZ(e) {
        return this.z = e,
        this
    }
    setComponent(e, t) {
        switch (e) {
        case 0:
            this.x = t;
            break;
        case 1:
            this.y = t;
            break;
        case 2:
            this.z = t;
            break;
        default:
            throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
        case 0:
            return this.x;
        case 1:
            return this.y;
        case 2:
            return this.z;
        default:
            throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x,this.y,this.z)
    }
    copy(e) {
        return this.x = e.x,
        this.y = e.y,
        this.z = e.z,
        this
    }
    add(e) {
        return this.x += e.x,
        this.y += e.y,
        this.z += e.z,
        this
    }
    addScalar(e) {
        return this.x += e,
        this.y += e,
        this.z += e,
        this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x,
        this.y = e.y + t.y,
        this.z = e.z + t.z,
        this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t,
        this.y += e.y * t,
        this.z += e.z * t,
        this
    }
    sub(e) {
        return this.x -= e.x,
        this.y -= e.y,
        this.z -= e.z,
        this
    }
    subScalar(e) {
        return this.x -= e,
        this.y -= e,
        this.z -= e,
        this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x,
        this.y = e.y - t.y,
        this.z = e.z - t.z,
        this
    }
    multiply(e) {
        return this.x *= e.x,
        this.y *= e.y,
        this.z *= e.z,
        this
    }
    multiplyScalar(e) {
        return this.x *= e,
        this.y *= e,
        this.z *= e,
        this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x,
        this.y = e.y * t.y,
        this.z = e.z * t.z,
        this
    }
    applyEuler(e) {
        return this.applyQuaternion(Za.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(Za.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[3] * n + r[6] * i,
        this.y = r[1] * t + r[4] * n + r[7] * i,
        this.z = r[2] * t + r[5] * n + r[8] * i,
        this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements
          , o = 1 / (r[3] * t + r[7] * n + r[11] * i + r[15]);
        return this.x = (r[0] * t + r[4] * n + r[8] * i + r[12]) * o,
        this.y = (r[1] * t + r[5] * n + r[9] * i + r[13]) * o,
        this.z = (r[2] * t + r[6] * n + r[10] * i + r[14]) * o,
        this
    }
    applyQuaternion(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.x
          , o = e.y
          , a = e.z
          , l = e.w
          , c = 2 * (o * i - a * n)
          , h = 2 * (a * t - r * i)
          , d = 2 * (r * n - o * t);
        return this.x = t + l * c + o * d - a * h,
        this.y = n + l * h + a * c - r * d,
        this.z = i + l * d + r * h - o * c,
        this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x
          , n = this.y
          , i = this.z
          , r = e.elements;
        return this.x = r[0] * t + r[4] * n + r[8] * i,
        this.y = r[1] * t + r[5] * n + r[9] * i,
        this.z = r[2] * t + r[6] * n + r[10] * i,
        this.normalize()
    }
    divide(e) {
        return this.x /= e.x,
        this.y /= e.y,
        this.z /= e.z,
        this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x),
        this.y = Math.min(this.y, e.y),
        this.z = Math.min(this.z, e.z),
        this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x),
        this.y = Math.max(this.y, e.y),
        this.z = Math.max(this.z, e.z),
        this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)),
        this.y = Math.max(e.y, Math.min(t.y, this.y)),
        this.z = Math.max(e.z, Math.min(t.z, this.z)),
        this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)),
        this.y = Math.max(e, Math.min(t, this.y)),
        this.z = Math.max(e, Math.min(t, this.z)),
        this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x),
        this.y = Math.floor(this.y),
        this.z = Math.floor(this.z),
        this
    }
    ceil() {
        return this.x = Math.ceil(this.x),
        this.y = Math.ceil(this.y),
        this.z = Math.ceil(this.z),
        this
    }
    round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this.z = Math.round(this.z),
        this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x),
        this.y = Math.trunc(this.y),
        this.z = Math.trunc(this.z),
        this
    }
    negate() {
        return this.x = -this.x,
        this.y = -this.y,
        this.z = -this.z,
        this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t,
        this.y += (e.y - this.y) * t,
        this.z += (e.z - this.z) * t,
        this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n,
        this.y = e.y + (t.y - e.y) * n,
        this.z = e.z + (t.z - e.z) * n,
        this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x
          , i = e.y
          , r = e.z
          , o = t.x
          , a = t.y
          , l = t.z;
        return this.x = i * l - r * a,
        this.y = r * o - n * l,
        this.z = n * a - i * o,
        this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0)
            return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return Nr.copy(this).projectOnVector(e),
        this.sub(Nr)
    }
    reflect(e) {
        return this.sub(Nr.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0)
            return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(ft(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x
          , n = this.y - e.y
          , i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n),
        this.y = Math.cos(t) * e,
        this.z = i * Math.cos(n),
        this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t),
        this.y = n,
        this.z = e * Math.cos(t),
        this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12],
        this.y = t[13],
        this.z = t[14],
        this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length()
          , n = this.setFromMatrixColumn(e, 1).length()
          , i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t,
        this.y = n,
        this.z = i,
        this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x,
        this.y = e._y,
        this.z = e._z,
        this
    }
    setFromColor(e) {
        return this.x = e.r,
        this.y = e.g,
        this.z = e.b,
        this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t=0) {
        return this.x = e[t],
        this.y = e[t + 1],
        this.z = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.x,
        e[t + 1] = this.y,
        e[t + 2] = this.z,
        e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t),
        this.y = e.getY(t),
        this.z = e.getZ(t),
        this
    }
    random() {
        return this.x = Math.random(),
        this.y = Math.random(),
        this.z = Math.random(),
        this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2
          , t = Math.random() * 2 - 1
          , n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e),
        this.y = t,
        this.z = n * Math.sin(e),
        this
    }
    *[Symbol.iterator]() {
        yield this.x,
        yield this.y,
        yield this.z
    }
}
const Nr = new C
  , Za = new ln;
class Pn {
    constructor(e=new C(1 / 0,1 / 0,1 / 0), t=new C(-1 / 0,-1 / 0,-1 / 0)) {
        this.isBox3 = !0,
        this.min = e,
        this.max = t
    }
    set(e, t) {
        return this.min.copy(e),
        this.max.copy(t),
        this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3)
            this.expandByPoint(qt.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++)
            this.expandByPoint(qt.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++)
            this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = qt.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n),
        this.max.copy(e).add(n),
        this
    }
    setFromObject(e, t=!1) {
        return this.makeEmpty(),
        this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min),
        this.max.copy(e.max),
        this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0,
        this.max.x = this.max.y = this.max.z = -1 / 0,
        this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e),
        this.max.max(e),
        this
    }
    expandByVector(e) {
        return this.min.sub(e),
        this.max.add(e),
        this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e),
        this.max.addScalar(e),
        this
    }
    expandByObject(e, t=!1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const r = n.getAttribute("position");
            if (t === !0 && r !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = r.count; o < a; o++)
                    e.isMesh === !0 ? e.getVertexPosition(o, qt) : qt.fromBufferAttribute(r, o),
                    qt.applyMatrix4(e.matrixWorld),
                    this.expandByPoint(qt);
            else
                e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(),
                Es.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(),
                Es.copy(n.boundingBox)),
                Es.applyMatrix4(e.matrixWorld),
                this.union(Es)
        }
        const i = e.children;
        for (let r = 0, o = i.length; r < o; r++)
            this.expandByObject(i[r], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, qt),
        qt.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x,
        n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x,
        n = e.normal.x * this.min.x),
        e.normal.y > 0 ? (t += e.normal.y * this.min.y,
        n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y,
        n += e.normal.y * this.min.y),
        e.normal.z > 0 ? (t += e.normal.z * this.min.z,
        n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z,
        n += e.normal.z * this.min.z),
        t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty())
            return !1;
        this.getCenter(ji),
        Ts.subVectors(this.max, ji),
        li.subVectors(e.a, ji),
        ci.subVectors(e.b, ji),
        hi.subVectors(e.c, ji),
        In.subVectors(ci, li),
        Un.subVectors(hi, ci),
        qn.subVectors(li, hi);
        let t = [0, -In.z, In.y, 0, -Un.z, Un.y, 0, -qn.z, qn.y, In.z, 0, -In.x, Un.z, 0, -Un.x, qn.z, 0, -qn.x, -In.y, In.x, 0, -Un.y, Un.x, 0, -qn.y, qn.x, 0];
        return !Fr(t, li, ci, hi, Ts) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1],
        !Fr(t, li, ci, hi, Ts)) ? !1 : (ws.crossVectors(In, Un),
        t = [ws.x, ws.y, ws.z],
        Fr(t, li, ci, hi, Ts))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, qt).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center),
        e.radius = this.getSize(qt).length() * .5),
        e
    }
    intersect(e) {
        return this.min.max(e.min),
        this.max.min(e.max),
        this.isEmpty() && this.makeEmpty(),
        this
    }
    union(e) {
        return this.min.min(e.min),
        this.max.max(e.max),
        this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (mn[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e),
        mn[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e),
        mn[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e),
        mn[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e),
        mn[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e),
        mn[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e),
        mn[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e),
        mn[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e),
        this.setFromPoints(mn),
        this)
    }
    translate(e) {
        return this.min.add(e),
        this.max.add(e),
        this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const mn = [new C, new C, new C, new C, new C, new C, new C, new C]
  , qt = new C
  , Es = new Pn
  , li = new C
  , ci = new C
  , hi = new C
  , In = new C
  , Un = new C
  , qn = new C
  , ji = new C
  , Ts = new C
  , ws = new C
  , Yn = new C;
function Fr(s, e, t, n, i) {
    for (let r = 0, o = s.length - 3; r <= o; r += 3) {
        Yn.fromArray(s, r);
        const a = i.x * Math.abs(Yn.x) + i.y * Math.abs(Yn.y) + i.z * Math.abs(Yn.z)
          , l = e.dot(Yn)
          , c = t.dot(Yn)
          , h = n.dot(Yn);
        if (Math.max(-Math.max(l, c, h), Math.min(l, c, h)) > a)
            return !1
    }
    return !0
}
const Id = new Pn
  , Ki = new C
  , Or = new C;
class dn {
    constructor(e=new C, t=-1) {
        this.isSphere = !0,
        this.center = e,
        this.radius = t
    }
    set(e, t) {
        return this.center.copy(e),
        this.radius = t,
        this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : Id.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let r = 0, o = e.length; r < o; r++)
            i = Math.max(i, n.distanceToSquared(e[r]));
        return this.radius = Math.sqrt(i),
        this
    }
    copy(e) {
        return this.center.copy(e.center),
        this.radius = e.radius,
        this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0),
        this.radius = -1,
        this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e),
        n > this.radius * this.radius && (t.sub(this.center).normalize(),
        t.multiplyScalar(this.radius).add(this.center)),
        t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(),
        e) : (e.set(this.center, this.center),
        e.expandByScalar(this.radius),
        e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e),
        this.radius = this.radius * e.getMaxScaleOnAxis(),
        this
    }
    translate(e) {
        return this.center.add(e),
        this
    }
    expandByPoint(e) {
        if (this.isEmpty())
            return this.center.copy(e),
            this.radius = 0,
            this;
        Ki.subVectors(e, this.center);
        const t = Ki.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t)
              , i = (n - this.radius) * .5;
            this.center.addScaledVector(Ki, i / n),
            this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e),
        this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (Or.subVectors(e.center, this.center).setLength(e.radius),
        this.expandByPoint(Ki.copy(e.center).add(Or)),
        this.expandByPoint(Ki.copy(e.center).sub(Or))),
        this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const gn = new C
  , Br = new C
  , As = new C
  , Nn = new C
  , zr = new C
  , Rs = new C
  , kr = new C;
class vs {
    constructor(e=new C, t=new C(0,0,-1)) {
        this.origin = e,
        this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e),
        this.direction.copy(t),
        this
    }
    copy(e) {
        return this.origin.copy(e.origin),
        this.direction.copy(e.direction),
        this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(),
        this
    }
    recast(e) {
        return this.origin.copy(this.at(e, gn)),
        this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = gn.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (gn.copy(this.origin).addScaledVector(this.direction, t),
        gn.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        Br.copy(e).add(t).multiplyScalar(.5),
        As.copy(t).sub(e).normalize(),
        Nn.copy(this.origin).sub(Br);
        const r = e.distanceTo(t) * .5
          , o = -this.direction.dot(As)
          , a = Nn.dot(this.direction)
          , l = -Nn.dot(As)
          , c = Nn.lengthSq()
          , h = Math.abs(1 - o * o);
        let d, u, f, g;
        if (h > 0)
            if (d = o * l - a,
            u = o * a - l,
            g = r * h,
            d >= 0)
                if (u >= -g)
                    if (u <= g) {
                        const M = 1 / h;
                        d *= M,
                        u *= M,
                        f = d * (d + o * u + 2 * a) + u * (o * d + u + 2 * l) + c
                    } else
                        u = r,
                        d = Math.max(0, -(o * u + a)),
                        f = -d * d + u * (u + 2 * l) + c;
                else
                    u = -r,
                    d = Math.max(0, -(o * u + a)),
                    f = -d * d + u * (u + 2 * l) + c;
            else
                u <= -g ? (d = Math.max(0, -(-o * r + a)),
                u = d > 0 ? -r : Math.min(Math.max(-r, -l), r),
                f = -d * d + u * (u + 2 * l) + c) : u <= g ? (d = 0,
                u = Math.min(Math.max(-r, -l), r),
                f = u * (u + 2 * l) + c) : (d = Math.max(0, -(o * r + a)),
                u = d > 0 ? r : Math.min(Math.max(-r, -l), r),
                f = -d * d + u * (u + 2 * l) + c);
        else
            u = o > 0 ? -r : r,
            d = Math.max(0, -(o * u + a)),
            f = -d * d + u * (u + 2 * l) + c;
        return n && n.copy(this.origin).addScaledVector(this.direction, d),
        i && i.copy(Br).addScaledVector(As, u),
        f
    }
    intersectSphere(e, t) {
        gn.subVectors(e.center, this.origin);
        const n = gn.dot(this.direction)
          , i = gn.dot(gn) - n * n
          , r = e.radius * e.radius;
        if (i > r)
            return null;
        const o = Math.sqrt(r - i)
          , a = n - o
          , l = n + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0)
            return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, r, o, a, l;
        const c = 1 / this.direction.x
          , h = 1 / this.direction.y
          , d = 1 / this.direction.z
          , u = this.origin;
        return c >= 0 ? (n = (e.min.x - u.x) * c,
        i = (e.max.x - u.x) * c) : (n = (e.max.x - u.x) * c,
        i = (e.min.x - u.x) * c),
        h >= 0 ? (r = (e.min.y - u.y) * h,
        o = (e.max.y - u.y) * h) : (r = (e.max.y - u.y) * h,
        o = (e.min.y - u.y) * h),
        n > o || r > i || ((r > n || isNaN(n)) && (n = r),
        (o < i || isNaN(i)) && (i = o),
        d >= 0 ? (a = (e.min.z - u.z) * d,
        l = (e.max.z - u.z) * d) : (a = (e.max.z - u.z) * d,
        l = (e.min.z - u.z) * d),
        n > l || a > i) || ((a > n || n !== n) && (n = a),
        (l < i || i !== i) && (i = l),
        i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, gn) !== null
    }
    intersectTriangle(e, t, n, i, r) {
        zr.subVectors(t, e),
        Rs.subVectors(n, e),
        kr.crossVectors(zr, Rs);
        let o = this.direction.dot(kr), a;
        if (o > 0) {
            if (i)
                return null;
            a = 1
        } else if (o < 0)
            a = -1,
            o = -o;
        else
            return null;
        Nn.subVectors(this.origin, e);
        const l = a * this.direction.dot(Rs.crossVectors(Nn, Rs));
        if (l < 0)
            return null;
        const c = a * this.direction.dot(zr.cross(Nn));
        if (c < 0 || l + c > o)
            return null;
        const h = -a * Nn.dot(kr);
        return h < 0 ? null : this.at(h / o, r)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e),
        this.direction.transformDirection(e),
        this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Oe {
    constructor(e, t, n, i, r, o, a, l, c, h, d, u, f, g, M, m) {
        Oe.prototype.isMatrix4 = !0,
        this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1],
        e !== void 0 && this.set(e, t, n, i, r, o, a, l, c, h, d, u, f, g, M, m)
    }
    set(e, t, n, i, r, o, a, l, c, h, d, u, f, g, M, m) {
        const p = this.elements;
        return p[0] = e,
        p[4] = t,
        p[8] = n,
        p[12] = i,
        p[1] = r,
        p[5] = o,
        p[9] = a,
        p[13] = l,
        p[2] = c,
        p[6] = h,
        p[10] = d,
        p[14] = u,
        p[3] = f,
        p[7] = g,
        p[11] = M,
        p[15] = m,
        this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    clone() {
        return new Oe().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements
          , n = e.elements;
        return t[0] = n[0],
        t[1] = n[1],
        t[2] = n[2],
        t[3] = n[3],
        t[4] = n[4],
        t[5] = n[5],
        t[6] = n[6],
        t[7] = n[7],
        t[8] = n[8],
        t[9] = n[9],
        t[10] = n[10],
        t[11] = n[11],
        t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        t[15] = n[15],
        this
    }
    copyPosition(e) {
        const t = this.elements
          , n = e.elements;
        return t[12] = n[12],
        t[13] = n[13],
        t[14] = n[14],
        this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1),
        this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0),
        t.setFromMatrixColumn(this, 1),
        n.setFromMatrixColumn(this, 2),
        this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1),
        this
    }
    extractRotation(e) {
        const t = this.elements
          , n = e.elements
          , i = 1 / di.setFromMatrixColumn(e, 0).length()
          , r = 1 / di.setFromMatrixColumn(e, 1).length()
          , o = 1 / di.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i,
        t[1] = n[1] * i,
        t[2] = n[2] * i,
        t[3] = 0,
        t[4] = n[4] * r,
        t[5] = n[5] * r,
        t[6] = n[6] * r,
        t[7] = 0,
        t[8] = n[8] * o,
        t[9] = n[9] * o,
        t[10] = n[10] * o,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromEuler(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z
          , o = Math.cos(n)
          , a = Math.sin(n)
          , l = Math.cos(i)
          , c = Math.sin(i)
          , h = Math.cos(r)
          , d = Math.sin(r);
        if (e.order === "XYZ") {
            const u = o * h
              , f = o * d
              , g = a * h
              , M = a * d;
            t[0] = l * h,
            t[4] = -l * d,
            t[8] = c,
            t[1] = f + g * c,
            t[5] = u - M * c,
            t[9] = -a * l,
            t[2] = M - u * c,
            t[6] = g + f * c,
            t[10] = o * l
        } else if (e.order === "YXZ") {
            const u = l * h
              , f = l * d
              , g = c * h
              , M = c * d;
            t[0] = u + M * a,
            t[4] = g * a - f,
            t[8] = o * c,
            t[1] = o * d,
            t[5] = o * h,
            t[9] = -a,
            t[2] = f * a - g,
            t[6] = M + u * a,
            t[10] = o * l
        } else if (e.order === "ZXY") {
            const u = l * h
              , f = l * d
              , g = c * h
              , M = c * d;
            t[0] = u - M * a,
            t[4] = -o * d,
            t[8] = g + f * a,
            t[1] = f + g * a,
            t[5] = o * h,
            t[9] = M - u * a,
            t[2] = -o * c,
            t[6] = a,
            t[10] = o * l
        } else if (e.order === "ZYX") {
            const u = o * h
              , f = o * d
              , g = a * h
              , M = a * d;
            t[0] = l * h,
            t[4] = g * c - f,
            t[8] = u * c + M,
            t[1] = l * d,
            t[5] = M * c + u,
            t[9] = f * c - g,
            t[2] = -c,
            t[6] = a * l,
            t[10] = o * l
        } else if (e.order === "YZX") {
            const u = o * l
              , f = o * c
              , g = a * l
              , M = a * c;
            t[0] = l * h,
            t[4] = M - u * d,
            t[8] = g * d + f,
            t[1] = d,
            t[5] = o * h,
            t[9] = -a * h,
            t[2] = -c * h,
            t[6] = f * d + g,
            t[10] = u - M * d
        } else if (e.order === "XZY") {
            const u = o * l
              , f = o * c
              , g = a * l
              , M = a * c;
            t[0] = l * h,
            t[4] = -d,
            t[8] = c * h,
            t[1] = u * d + M,
            t[5] = o * h,
            t[9] = f * d - g,
            t[2] = g * d - f,
            t[6] = a * h,
            t[10] = M * d + u
        }
        return t[3] = 0,
        t[7] = 0,
        t[11] = 0,
        t[12] = 0,
        t[13] = 0,
        t[14] = 0,
        t[15] = 1,
        this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(Ud, e, Nd)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return Ft.subVectors(e, t),
        Ft.lengthSq() === 0 && (Ft.z = 1),
        Ft.normalize(),
        Fn.crossVectors(n, Ft),
        Fn.lengthSq() === 0 && (Math.abs(n.z) === 1 ? Ft.x += 1e-4 : Ft.z += 1e-4,
        Ft.normalize(),
        Fn.crossVectors(n, Ft)),
        Fn.normalize(),
        Cs.crossVectors(Ft, Fn),
        i[0] = Fn.x,
        i[4] = Cs.x,
        i[8] = Ft.x,
        i[1] = Fn.y,
        i[5] = Cs.y,
        i[9] = Ft.y,
        i[2] = Fn.z,
        i[6] = Cs.z,
        i[10] = Ft.z,
        this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements
          , i = t.elements
          , r = this.elements
          , o = n[0]
          , a = n[4]
          , l = n[8]
          , c = n[12]
          , h = n[1]
          , d = n[5]
          , u = n[9]
          , f = n[13]
          , g = n[2]
          , M = n[6]
          , m = n[10]
          , p = n[14]
          , E = n[3]
          , _ = n[7]
          , v = n[11]
          , L = n[15]
          , P = i[0]
          , A = i[4]
          , w = i[8]
          , S = i[12]
          , y = i[1]
          , D = i[5]
          , G = i[9]
          , F = i[13]
          , O = i[2]
          , V = i[6]
          , B = i[10]
          , q = i[14]
          , W = i[3]
          , ae = i[7]
          , le = i[11]
          , me = i[15];
        return r[0] = o * P + a * y + l * O + c * W,
        r[4] = o * A + a * D + l * V + c * ae,
        r[8] = o * w + a * G + l * B + c * le,
        r[12] = o * S + a * F + l * q + c * me,
        r[1] = h * P + d * y + u * O + f * W,
        r[5] = h * A + d * D + u * V + f * ae,
        r[9] = h * w + d * G + u * B + f * le,
        r[13] = h * S + d * F + u * q + f * me,
        r[2] = g * P + M * y + m * O + p * W,
        r[6] = g * A + M * D + m * V + p * ae,
        r[10] = g * w + M * G + m * B + p * le,
        r[14] = g * S + M * F + m * q + p * me,
        r[3] = E * P + _ * y + v * O + L * W,
        r[7] = E * A + _ * D + v * V + L * ae,
        r[11] = E * w + _ * G + v * B + L * le,
        r[15] = E * S + _ * F + v * q + L * me,
        this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e,
        t[4] *= e,
        t[8] *= e,
        t[12] *= e,
        t[1] *= e,
        t[5] *= e,
        t[9] *= e,
        t[13] *= e,
        t[2] *= e,
        t[6] *= e,
        t[10] *= e,
        t[14] *= e,
        t[3] *= e,
        t[7] *= e,
        t[11] *= e,
        t[15] *= e,
        this
    }
    determinant() {
        const e = this.elements
          , t = e[0]
          , n = e[4]
          , i = e[8]
          , r = e[12]
          , o = e[1]
          , a = e[5]
          , l = e[9]
          , c = e[13]
          , h = e[2]
          , d = e[6]
          , u = e[10]
          , f = e[14]
          , g = e[3]
          , M = e[7]
          , m = e[11]
          , p = e[15];
        return g * (+r * l * d - i * c * d - r * a * u + n * c * u + i * a * f - n * l * f) + M * (+t * l * f - t * c * u + r * o * u - i * o * f + i * c * h - r * l * h) + m * (+t * c * d - t * a * f - r * o * d + n * o * f + r * a * h - n * c * h) + p * (-i * a * h - t * l * d + t * a * u + i * o * d - n * o * u + n * l * h)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1],
        e[1] = e[4],
        e[4] = t,
        t = e[2],
        e[2] = e[8],
        e[8] = t,
        t = e[6],
        e[6] = e[9],
        e[9] = t,
        t = e[3],
        e[3] = e[12],
        e[12] = t,
        t = e[7],
        e[7] = e[13],
        e[13] = t,
        t = e[11],
        e[11] = e[14],
        e[14] = t,
        this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z) : (i[12] = e,
        i[13] = t,
        i[14] = n),
        this
    }
    invert() {
        const e = this.elements
          , t = e[0]
          , n = e[1]
          , i = e[2]
          , r = e[3]
          , o = e[4]
          , a = e[5]
          , l = e[6]
          , c = e[7]
          , h = e[8]
          , d = e[9]
          , u = e[10]
          , f = e[11]
          , g = e[12]
          , M = e[13]
          , m = e[14]
          , p = e[15]
          , E = d * m * c - M * u * c + M * l * f - a * m * f - d * l * p + a * u * p
          , _ = g * u * c - h * m * c - g * l * f + o * m * f + h * l * p - o * u * p
          , v = h * M * c - g * d * c + g * a * f - o * M * f - h * a * p + o * d * p
          , L = g * d * l - h * M * l - g * a * u + o * M * u + h * a * m - o * d * m
          , P = t * E + n * _ + i * v + r * L;
        if (P === 0)
            return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const A = 1 / P;
        return e[0] = E * A,
        e[1] = (M * u * r - d * m * r - M * i * f + n * m * f + d * i * p - n * u * p) * A,
        e[2] = (a * m * r - M * l * r + M * i * c - n * m * c - a * i * p + n * l * p) * A,
        e[3] = (d * l * r - a * u * r - d * i * c + n * u * c + a * i * f - n * l * f) * A,
        e[4] = _ * A,
        e[5] = (h * m * r - g * u * r + g * i * f - t * m * f - h * i * p + t * u * p) * A,
        e[6] = (g * l * r - o * m * r - g * i * c + t * m * c + o * i * p - t * l * p) * A,
        e[7] = (o * u * r - h * l * r + h * i * c - t * u * c - o * i * f + t * l * f) * A,
        e[8] = v * A,
        e[9] = (g * d * r - h * M * r - g * n * f + t * M * f + h * n * p - t * d * p) * A,
        e[10] = (o * M * r - g * a * r + g * n * c - t * M * c - o * n * p + t * a * p) * A,
        e[11] = (h * a * r - o * d * r - h * n * c + t * d * c + o * n * f - t * a * f) * A,
        e[12] = L * A,
        e[13] = (h * M * i - g * d * i + g * n * u - t * M * u - h * n * m + t * d * m) * A,
        e[14] = (g * a * i - o * M * i - g * n * l + t * M * l + o * n * m - t * a * m) * A,
        e[15] = (o * d * i - h * a * i + h * n * l - t * d * l - o * n * u + t * a * u) * A,
        this
    }
    scale(e) {
        const t = this.elements
          , n = e.x
          , i = e.y
          , r = e.z;
        return t[0] *= n,
        t[4] *= i,
        t[8] *= r,
        t[1] *= n,
        t[5] *= i,
        t[9] *= r,
        t[2] *= n,
        t[6] *= i,
        t[10] *= r,
        t[3] *= n,
        t[7] *= i,
        t[11] *= r,
        this
    }
    getMaxScaleOnAxis() {
        const e = this.elements
          , t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2]
          , n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6]
          , i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1),
        this
    }
    makeRotationX(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationY(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1),
        this
    }
    makeRotationZ(e) {
        const t = Math.cos(e)
          , n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1),
        this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t)
          , i = Math.sin(t)
          , r = 1 - n
          , o = e.x
          , a = e.y
          , l = e.z
          , c = r * o
          , h = r * a;
        return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, h * a + n, h * l - i * o, 0, c * l - i * a, h * l + i * o, r * l * l + n, 0, 0, 0, 0, 1),
        this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1),
        this
    }
    makeShear(e, t, n, i, r, o) {
        return this.set(1, n, r, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1),
        this
    }
    compose(e, t, n) {
        const i = this.elements
          , r = t._x
          , o = t._y
          , a = t._z
          , l = t._w
          , c = r + r
          , h = o + o
          , d = a + a
          , u = r * c
          , f = r * h
          , g = r * d
          , M = o * h
          , m = o * d
          , p = a * d
          , E = l * c
          , _ = l * h
          , v = l * d
          , L = n.x
          , P = n.y
          , A = n.z;
        return i[0] = (1 - (M + p)) * L,
        i[1] = (f + v) * L,
        i[2] = (g - _) * L,
        i[3] = 0,
        i[4] = (f - v) * P,
        i[5] = (1 - (u + p)) * P,
        i[6] = (m + E) * P,
        i[7] = 0,
        i[8] = (g + _) * A,
        i[9] = (m - E) * A,
        i[10] = (1 - (u + M)) * A,
        i[11] = 0,
        i[12] = e.x,
        i[13] = e.y,
        i[14] = e.z,
        i[15] = 1,
        this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let r = di.set(i[0], i[1], i[2]).length();
        const o = di.set(i[4], i[5], i[6]).length()
          , a = di.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (r = -r),
        e.x = i[12],
        e.y = i[13],
        e.z = i[14],
        Yt.copy(this);
        const c = 1 / r
          , h = 1 / o
          , d = 1 / a;
        return Yt.elements[0] *= c,
        Yt.elements[1] *= c,
        Yt.elements[2] *= c,
        Yt.elements[4] *= h,
        Yt.elements[5] *= h,
        Yt.elements[6] *= h,
        Yt.elements[8] *= d,
        Yt.elements[9] *= d,
        Yt.elements[10] *= d,
        t.setFromRotationMatrix(Yt),
        n.x = r,
        n.y = o,
        n.z = a,
        this
    }
    makePerspective(e, t, n, i, r, o, a=Tn) {
        const l = this.elements
          , c = 2 * r / (t - e)
          , h = 2 * r / (n - i)
          , d = (t + e) / (t - e)
          , u = (n + i) / (n - i);
        let f, g;
        if (a === Tn)
            f = -(o + r) / (o - r),
            g = -2 * o * r / (o - r);
        else if (a === gr)
            f = -o / (o - r),
            g = -o * r / (o - r);
        else
            throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c,
        l[4] = 0,
        l[8] = d,
        l[12] = 0,
        l[1] = 0,
        l[5] = h,
        l[9] = u,
        l[13] = 0,
        l[2] = 0,
        l[6] = 0,
        l[10] = f,
        l[14] = g,
        l[3] = 0,
        l[7] = 0,
        l[11] = -1,
        l[15] = 0,
        this
    }
    makeOrthographic(e, t, n, i, r, o, a=Tn) {
        const l = this.elements
          , c = 1 / (t - e)
          , h = 1 / (n - i)
          , d = 1 / (o - r)
          , u = (t + e) * c
          , f = (n + i) * h;
        let g, M;
        if (a === Tn)
            g = (o + r) * d,
            M = -2 * d;
        else if (a === gr)
            g = r * d,
            M = -1 * d;
        else
            throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c,
        l[4] = 0,
        l[8] = 0,
        l[12] = -u,
        l[1] = 0,
        l[5] = 2 * h,
        l[9] = 0,
        l[13] = -f,
        l[2] = 0,
        l[6] = 0,
        l[10] = M,
        l[14] = -g,
        l[3] = 0,
        l[7] = 0,
        l[11] = 0,
        l[15] = 1,
        this
    }
    equals(e) {
        const t = this.elements
          , n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i])
                return !1;
        return !0
    }
    fromArray(e, t=0) {
        for (let n = 0; n < 16; n++)
            this.elements[n] = e[n + t];
        return this
    }
    toArray(e=[], t=0) {
        const n = this.elements;
        return e[t] = n[0],
        e[t + 1] = n[1],
        e[t + 2] = n[2],
        e[t + 3] = n[3],
        e[t + 4] = n[4],
        e[t + 5] = n[5],
        e[t + 6] = n[6],
        e[t + 7] = n[7],
        e[t + 8] = n[8],
        e[t + 9] = n[9],
        e[t + 10] = n[10],
        e[t + 11] = n[11],
        e[t + 12] = n[12],
        e[t + 13] = n[13],
        e[t + 14] = n[14],
        e[t + 15] = n[15],
        e
    }
}
const di = new C
  , Yt = new Oe
  , Ud = new C(0,0,0)
  , Nd = new C(1,1,1)
  , Fn = new C
  , Cs = new C
  , Ft = new C
  , Ja = new Oe
  , Qa = new ln;
class cn {
    constructor(e=0, t=0, n=0, i=cn.DEFAULT_ORDER) {
        this.isEuler = !0,
        this._x = e,
        this._y = t,
        this._z = n,
        this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e,
        this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e,
        this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e,
        this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e,
        this._onChangeCallback()
    }
    set(e, t, n, i=this._order) {
        return this._x = e,
        this._y = t,
        this._z = n,
        this._order = i,
        this._onChangeCallback(),
        this
    }
    clone() {
        return new this.constructor(this._x,this._y,this._z,this._order)
    }
    copy(e) {
        return this._x = e._x,
        this._y = e._y,
        this._z = e._z,
        this._order = e._order,
        this._onChangeCallback(),
        this
    }
    setFromRotationMatrix(e, t=this._order, n=!0) {
        const i = e.elements
          , r = i[0]
          , o = i[4]
          , a = i[8]
          , l = i[1]
          , c = i[5]
          , h = i[9]
          , d = i[2]
          , u = i[6]
          , f = i[10];
        switch (t) {
        case "XYZ":
            this._y = Math.asin(ft(a, -1, 1)),
            Math.abs(a) < .9999999 ? (this._x = Math.atan2(-h, f),
            this._z = Math.atan2(-o, r)) : (this._x = Math.atan2(u, c),
            this._z = 0);
            break;
        case "YXZ":
            this._x = Math.asin(-ft(h, -1, 1)),
            Math.abs(h) < .9999999 ? (this._y = Math.atan2(a, f),
            this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-d, r),
            this._z = 0);
            break;
        case "ZXY":
            this._x = Math.asin(ft(u, -1, 1)),
            Math.abs(u) < .9999999 ? (this._y = Math.atan2(-d, f),
            this._z = Math.atan2(-o, c)) : (this._y = 0,
            this._z = Math.atan2(l, r));
            break;
        case "ZYX":
            this._y = Math.asin(-ft(d, -1, 1)),
            Math.abs(d) < .9999999 ? (this._x = Math.atan2(u, f),
            this._z = Math.atan2(l, r)) : (this._x = 0,
            this._z = Math.atan2(-o, c));
            break;
        case "YZX":
            this._z = Math.asin(ft(l, -1, 1)),
            Math.abs(l) < .9999999 ? (this._x = Math.atan2(-h, c),
            this._y = Math.atan2(-d, r)) : (this._x = 0,
            this._y = Math.atan2(a, f));
            break;
        case "XZY":
            this._z = Math.asin(-ft(o, -1, 1)),
            Math.abs(o) < .9999999 ? (this._x = Math.atan2(u, c),
            this._y = Math.atan2(a, r)) : (this._x = Math.atan2(-h, f),
            this._y = 0);
            break;
        default:
            console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t,
        n === !0 && this._onChangeCallback(),
        this
    }
    setFromQuaternion(e, t, n) {
        return Ja.makeRotationFromQuaternion(e),
        this.setFromRotationMatrix(Ja, t, n)
    }
    setFromVector3(e, t=this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return Qa.setFromEuler(this),
        this.setFromQuaternion(Qa, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0],
        this._y = e[1],
        this._z = e[2],
        e[3] !== void 0 && (this._order = e[3]),
        this._onChangeCallback(),
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this._x,
        e[t + 1] = this._y,
        e[t + 2] = this._z,
        e[t + 3] = this._order,
        e
    }
    _onChange(e) {
        return this._onChangeCallback = e,
        this
    }
    _onChangeCallback() {}
    *[Symbol.iterator]() {
        yield this._x,
        yield this._y,
        yield this._z,
        yield this._order
    }
}
cn.DEFAULT_ORDER = "XYZ";
class Hc {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let Fd = 0;
const el = new C
  , ui = new ln
  , Mn = new Oe
  , Ps = new C
  , $i = new C
  , Od = new C
  , Bd = new ln
  , tl = new C(1,0,0)
  , nl = new C(0,1,0)
  , il = new C(0,0,1)
  , sl = {
    type: "added"
}
  , zd = {
    type: "removed"
}
  , fi = {
    type: "childadded",
    child: null
}
  , Hr = {
    type: "childremoved",
    child: null
};
class it extends ri {
    constructor() {
        super(),
        this.isObject3D = !0,
        Object.defineProperty(this, "id", {
            value: Fd++
        }),
        this.uuid = Vt(),
        this.name = "",
        this.type = "Object3D",
        this.parent = null,
        this.children = [],
        this.up = it.DEFAULT_UP.clone();
        const e = new C
          , t = new cn
          , n = new ln
          , i = new C(1,1,1);
        function r() {
            n.setFromEuler(t, !1)
        }
        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(r),
        n._onChange(o),
        Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Oe
            },
            normalMatrix: {
                value: new He
            }
        }),
        this.matrix = new Oe,
        this.matrixWorld = new Oe,
        this.matrixAutoUpdate = it.DEFAULT_MATRIX_AUTO_UPDATE,
        this.matrixWorldAutoUpdate = it.DEFAULT_MATRIX_WORLD_AUTO_UPDATE,
        this.matrixWorldNeedsUpdate = !1,
        this.layers = new Hc,
        this.visible = !0,
        this.castShadow = !1,
        this.receiveShadow = !1,
        this.frustumCulled = !0,
        this.renderOrder = 0,
        this.animations = [],
        this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrix.premultiply(e),
        this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e),
        this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return ui.setFromAxisAngle(e, t),
        this.quaternion.multiply(ui),
        this
    }
    rotateOnWorldAxis(e, t) {
        return ui.setFromAxisAngle(e, t),
        this.quaternion.premultiply(ui),
        this
    }
    rotateX(e) {
        return this.rotateOnAxis(tl, e)
    }
    rotateY(e) {
        return this.rotateOnAxis(nl, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(il, e)
    }
    translateOnAxis(e, t) {
        return el.copy(e).applyQuaternion(this.quaternion),
        this.position.add(el.multiplyScalar(t)),
        this
    }
    translateX(e) {
        return this.translateOnAxis(tl, e)
    }
    translateY(e) {
        return this.translateOnAxis(nl, e)
    }
    translateZ(e) {
        return this.translateOnAxis(il, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1),
        e.applyMatrix4(Mn.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? Ps.copy(e) : Ps.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1),
        $i.setFromMatrixPosition(this.matrixWorld),
        this.isCamera || this.isLight ? Mn.lookAt($i, Ps, this.up) : Mn.lookAt(Ps, $i, this.up),
        this.quaternion.setFromRotationMatrix(Mn),
        i && (Mn.extractRotation(i.matrixWorld),
        ui.setFromRotationMatrix(Mn),
        this.quaternion.premultiply(ui.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++)
                this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e),
        this) : (e && e.isObject3D ? (e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.dispatchEvent(sl),
        fi.child = e,
        this.dispatchEvent(fi),
        fi.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e),
        this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++)
                this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null,
        this.children.splice(t, 1),
        e.dispatchEvent(zd),
        Hr.child = e,
        this.dispatchEvent(Hr),
        Hr.child = null),
        this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this),
        this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1),
        Mn.copy(this.matrixWorld).invert(),
        e.parent !== null && (e.parent.updateWorldMatrix(!0, !1),
        Mn.multiply(e.parent.matrixWorld)),
        e.applyMatrix4(Mn),
        e.removeFromParent(),
        e.parent = this,
        this.children.push(e),
        e.updateWorldMatrix(!1, !0),
        e.dispatchEvent(sl),
        fi.child = e,
        this.dispatchEvent(fi),
        fi.child = null,
        this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t)
            return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0)
                return o
        }
    }
    getObjectsByProperty(e, t, n=[]) {
        this[e] === t && n.push(this);
        const i = this.children;
        for (let r = 0, o = i.length; r < o; r++)
            i[r].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1),
        e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose($i, e, Od),
        e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1),
        this.matrixWorld.decompose($i, Bd, e),
        e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1)
            return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t),
        t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale),
        this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(),
        (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        this.matrixWorldNeedsUpdate = !1,
        e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++)
            t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1),
        this.matrixAutoUpdate && this.updateMatrix(),
        this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)),
        t === !0) {
            const i = this.children;
            for (let r = 0, o = i.length; r < o; r++)
                i[r].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string"
          , n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        },
        n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid,
        i.type = this.type,
        this.name !== "" && (i.name = this.name),
        this.castShadow === !0 && (i.castShadow = !0),
        this.receiveShadow === !0 && (i.receiveShadow = !0),
        this.visible === !1 && (i.visible = !1),
        this.frustumCulled === !1 && (i.frustumCulled = !1),
        this.renderOrder !== 0 && (i.renderOrder = this.renderOrder),
        Object.keys(this.userData).length > 0 && (i.userData = this.userData),
        i.layers = this.layers.mask,
        i.matrix = this.matrix.toArray(),
        i.up = this.up.toArray(),
        this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1),
        this.isInstancedMesh && (i.type = "InstancedMesh",
        i.count = this.count,
        i.instanceMatrix = this.instanceMatrix.toJSON(),
        this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())),
        this.isBatchedMesh && (i.type = "BatchedMesh",
        i.perObjectFrustumCulled = this.perObjectFrustumCulled,
        i.sortObjects = this.sortObjects,
        i.drawRanges = this._drawRanges,
        i.reservedRanges = this._reservedRanges,
        i.visibility = this._visibility,
        i.active = this._active,
        i.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })),
        i.maxInstanceCount = this._maxInstanceCount,
        i.maxVertexCount = this._maxVertexCount,
        i.maxIndexCount = this._maxIndexCount,
        i.geometryInitialized = this._geometryInitialized,
        i.geometryCount = this._geometryCount,
        i.matricesTexture = this._matricesTexture.toJSON(e),
        this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)),
        this.boundingSphere !== null && (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius
        }),
        this.boundingBox !== null && (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray()
        }));
        function r(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)),
            l.uuid
        }
        if (this.isScene)
            this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)),
            this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = r(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, h = l.length; c < h; c++) {
                        const d = l[c];
                        r(e.shapes, d)
                    }
                else
                    r(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode,
        i.bindMatrix = this.bindMatrix.toArray(),
        this.skeleton !== void 0 && (r(e.skeletons, this.skeleton),
        i.skeleton = this.skeleton.uuid)),
        this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++)
                    a.push(r(e.materials, this.material[l]));
                i.material = a
            } else
                i.material = r(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++)
                i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(r(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries)
              , l = o(e.materials)
              , c = o(e.textures)
              , h = o(e.images)
              , d = o(e.shapes)
              , u = o(e.skeletons)
              , f = o(e.animations)
              , g = o(e.nodes);
            a.length > 0 && (n.geometries = a),
            l.length > 0 && (n.materials = l),
            c.length > 0 && (n.textures = c),
            h.length > 0 && (n.images = h),
            d.length > 0 && (n.shapes = d),
            u.length > 0 && (n.skeletons = u),
            f.length > 0 && (n.animations = f),
            g.length > 0 && (n.nodes = g)
        }
        return n.object = i,
        n;
        function o(a) {
            const l = [];
            for (const c in a) {
                const h = a[c];
                delete h.metadata,
                l.push(h)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t=!0) {
        if (this.name = e.name,
        this.up.copy(e.up),
        this.position.copy(e.position),
        this.rotation.order = e.rotation.order,
        this.quaternion.copy(e.quaternion),
        this.scale.copy(e.scale),
        this.matrix.copy(e.matrix),
        this.matrixWorld.copy(e.matrixWorld),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate,
        this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate,
        this.layers.mask = e.layers.mask,
        this.visible = e.visible,
        this.castShadow = e.castShadow,
        this.receiveShadow = e.receiveShadow,
        this.frustumCulled = e.frustumCulled,
        this.renderOrder = e.renderOrder,
        this.animations = e.animations.slice(),
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
it.DEFAULT_UP = new C(0,1,0);
it.DEFAULT_MATRIX_AUTO_UPDATE = !0;
it.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const jt = new C
  , _n = new C
  , Gr = new C
  , vn = new C
  , pi = new C
  , mi = new C
  , rl = new C
  , Vr = new C
  , Wr = new C
  , Xr = new C;
class nn {
    constructor(e=new C, t=new C, n=new C) {
        this.a = e,
        this.b = t,
        this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t),
        jt.subVectors(e, t),
        i.cross(jt);
        const r = i.lengthSq();
        return r > 0 ? i.multiplyScalar(1 / Math.sqrt(r)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, r) {
        jt.subVectors(i, t),
        _n.subVectors(n, t),
        Gr.subVectors(e, t);
        const o = jt.dot(jt)
          , a = jt.dot(_n)
          , l = jt.dot(Gr)
          , c = _n.dot(_n)
          , h = _n.dot(Gr)
          , d = o * c - a * a;
        if (d === 0)
            return r.set(0, 0, 0),
            null;
        const u = 1 / d
          , f = (c * l - a * h) * u
          , g = (o * h - a * l) * u;
        return r.set(1 - f - g, g, f)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, vn) === null ? !1 : vn.x >= 0 && vn.y >= 0 && vn.x + vn.y <= 1
    }
    static getInterpolation(e, t, n, i, r, o, a, l) {
        return this.getBarycoord(e, t, n, i, vn) === null ? (l.x = 0,
        l.y = 0,
        "z"in l && (l.z = 0),
        "w"in l && (l.w = 0),
        null) : (l.setScalar(0),
        l.addScaledVector(r, vn.x),
        l.addScaledVector(o, vn.y),
        l.addScaledVector(a, vn.z),
        l)
    }
    static isFrontFacing(e, t, n, i) {
        return jt.subVectors(n, t),
        _n.subVectors(e, t),
        jt.cross(_n).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e),
        this.b.copy(t),
        this.c.copy(n),
        this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]),
        this.b.copy(e[n]),
        this.c.copy(e[i]),
        this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t),
        this.b.fromBufferAttribute(e, n),
        this.c.fromBufferAttribute(e, i),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a),
        this.b.copy(e.b),
        this.c.copy(e.c),
        this
    }
    getArea() {
        return jt.subVectors(this.c, this.b),
        _n.subVectors(this.a, this.b),
        jt.cross(_n).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return nn.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return nn.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, i, r) {
        return nn.getInterpolation(e, this.a, this.b, this.c, t, n, i, r)
    }
    containsPoint(e) {
        return nn.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return nn.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a
          , i = this.b
          , r = this.c;
        let o, a;
        pi.subVectors(i, n),
        mi.subVectors(r, n),
        Vr.subVectors(e, n);
        const l = pi.dot(Vr)
          , c = mi.dot(Vr);
        if (l <= 0 && c <= 0)
            return t.copy(n);
        Wr.subVectors(e, i);
        const h = pi.dot(Wr)
          , d = mi.dot(Wr);
        if (h >= 0 && d <= h)
            return t.copy(i);
        const u = l * d - h * c;
        if (u <= 0 && l >= 0 && h <= 0)
            return o = l / (l - h),
            t.copy(n).addScaledVector(pi, o);
        Xr.subVectors(e, r);
        const f = pi.dot(Xr)
          , g = mi.dot(Xr);
        if (g >= 0 && f <= g)
            return t.copy(r);
        const M = f * c - l * g;
        if (M <= 0 && c >= 0 && g <= 0)
            return a = c / (c - g),
            t.copy(n).addScaledVector(mi, a);
        const m = h * g - f * d;
        if (m <= 0 && d - h >= 0 && f - g >= 0)
            return rl.subVectors(r, i),
            a = (d - h) / (d - h + (f - g)),
            t.copy(i).addScaledVector(rl, a);
        const p = 1 / (m + M + u);
        return o = M * p,
        a = u * p,
        t.copy(n).addScaledVector(pi, o).addScaledVector(mi, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const Gc = {
    aliceblue: 15792383,
    antiquewhite: 16444375,
    aqua: 65535,
    aquamarine: 8388564,
    azure: 15794175,
    beige: 16119260,
    bisque: 16770244,
    black: 0,
    blanchedalmond: 16772045,
    blue: 255,
    blueviolet: 9055202,
    brown: 10824234,
    burlywood: 14596231,
    cadetblue: 6266528,
    chartreuse: 8388352,
    chocolate: 13789470,
    coral: 16744272,
    cornflowerblue: 6591981,
    cornsilk: 16775388,
    crimson: 14423100,
    cyan: 65535,
    darkblue: 139,
    darkcyan: 35723,
    darkgoldenrod: 12092939,
    darkgray: 11119017,
    darkgreen: 25600,
    darkgrey: 11119017,
    darkkhaki: 12433259,
    darkmagenta: 9109643,
    darkolivegreen: 5597999,
    darkorange: 16747520,
    darkorchid: 10040012,
    darkred: 9109504,
    darksalmon: 15308410,
    darkseagreen: 9419919,
    darkslateblue: 4734347,
    darkslategray: 3100495,
    darkslategrey: 3100495,
    darkturquoise: 52945,
    darkviolet: 9699539,
    deeppink: 16716947,
    deepskyblue: 49151,
    dimgray: 6908265,
    dimgrey: 6908265,
    dodgerblue: 2003199,
    firebrick: 11674146,
    floralwhite: 16775920,
    forestgreen: 2263842,
    fuchsia: 16711935,
    gainsboro: 14474460,
    ghostwhite: 16316671,
    gold: 16766720,
    goldenrod: 14329120,
    gray: 8421504,
    green: 32768,
    greenyellow: 11403055,
    grey: 8421504,
    honeydew: 15794160,
    hotpink: 16738740,
    indianred: 13458524,
    indigo: 4915330,
    ivory: 16777200,
    khaki: 15787660,
    lavender: 15132410,
    lavenderblush: 16773365,
    lawngreen: 8190976,
    lemonchiffon: 16775885,
    lightblue: 11393254,
    lightcoral: 15761536,
    lightcyan: 14745599,
    lightgoldenrodyellow: 16448210,
    lightgray: 13882323,
    lightgreen: 9498256,
    lightgrey: 13882323,
    lightpink: 16758465,
    lightsalmon: 16752762,
    lightseagreen: 2142890,
    lightskyblue: 8900346,
    lightslategray: 7833753,
    lightslategrey: 7833753,
    lightsteelblue: 11584734,
    lightyellow: 16777184,
    lime: 65280,
    limegreen: 3329330,
    linen: 16445670,
    magenta: 16711935,
    maroon: 8388608,
    mediumaquamarine: 6737322,
    mediumblue: 205,
    mediumorchid: 12211667,
    mediumpurple: 9662683,
    mediumseagreen: 3978097,
    mediumslateblue: 8087790,
    mediumspringgreen: 64154,
    mediumturquoise: 4772300,
    mediumvioletred: 13047173,
    midnightblue: 1644912,
    mintcream: 16121850,
    mistyrose: 16770273,
    moccasin: 16770229,
    navajowhite: 16768685,
    navy: 128,
    oldlace: 16643558,
    olive: 8421376,
    olivedrab: 7048739,
    orange: 16753920,
    orangered: 16729344,
    orchid: 14315734,
    palegoldenrod: 15657130,
    palegreen: 10025880,
    paleturquoise: 11529966,
    palevioletred: 14381203,
    papayawhip: 16773077,
    peachpuff: 16767673,
    peru: 13468991,
    pink: 16761035,
    plum: 14524637,
    powderblue: 11591910,
    purple: 8388736,
    rebeccapurple: 6697881,
    red: 16711680,
    rosybrown: 12357519,
    royalblue: 4286945,
    saddlebrown: 9127187,
    salmon: 16416882,
    sandybrown: 16032864,
    seagreen: 3050327,
    seashell: 16774638,
    sienna: 10506797,
    silver: 12632256,
    skyblue: 8900331,
    slateblue: 6970061,
    slategray: 7372944,
    slategrey: 7372944,
    snow: 16775930,
    springgreen: 65407,
    steelblue: 4620980,
    tan: 13808780,
    teal: 32896,
    thistle: 14204888,
    tomato: 16737095,
    turquoise: 4251856,
    violet: 15631086,
    wheat: 16113331,
    white: 16777215,
    whitesmoke: 16119285,
    yellow: 16776960,
    yellowgreen: 10145074
}
  , On = {
    h: 0,
    s: 0,
    l: 0
}
  , Ds = {
    h: 0,
    s: 0,
    l: 0
};
function qr(s, e, t) {
    return t < 0 && (t += 1),
    t > 1 && (t -= 1),
    t < 1 / 6 ? s + (e - s) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? s + (e - s) * 6 * (2 / 3 - t) : s
}
class be {
    constructor(e, t, n) {
        return this.isColor = !0,
        this.r = 1,
        this.g = 1,
        this.b = 1,
        this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else
            this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e,
        this.g = e,
        this.b = e,
        this
    }
    setHex(e, t=Tt) {
        return e = Math.floor(e),
        this.r = (e >> 16 & 255) / 255,
        this.g = (e >> 8 & 255) / 255,
        this.b = (e & 255) / 255,
        je.toWorkingColorSpace(this, t),
        this
    }
    setRGB(e, t, n, i=je.workingColorSpace) {
        return this.r = e,
        this.g = t,
        this.b = n,
        je.toWorkingColorSpace(this, i),
        this
    }
    setHSL(e, t, n, i=je.workingColorSpace) {
        if (e = ua(e, 1),
        t = ft(t, 0, 1),
        n = ft(n, 0, 1),
        t === 0)
            this.r = this.g = this.b = n;
        else {
            const r = n <= .5 ? n * (1 + t) : n + t - n * t
              , o = 2 * n - r;
            this.r = qr(o, r, e + 1 / 3),
            this.g = qr(o, r, e),
            this.b = qr(o, r, e - 1 / 3)
        }
        return je.toWorkingColorSpace(this, i),
        this
    }
    setStyle(e, t=Tt) {
        function n(r) {
            r !== void 0 && parseFloat(r) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let r;
            const o = i[1]
              , a = i[2];
            switch (o) {
            case "rgb":
            case "rgba":
                if (r = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setRGB(Math.min(255, parseInt(r[1], 10)) / 255, Math.min(255, parseInt(r[2], 10)) / 255, Math.min(255, parseInt(r[3], 10)) / 255, t);
                if (r = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setRGB(Math.min(100, parseInt(r[1], 10)) / 100, Math.min(100, parseInt(r[2], 10)) / 100, Math.min(100, parseInt(r[3], 10)) / 100, t);
                break;
            case "hsl":
            case "hsla":
                if (r = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a))
                    return n(r[4]),
                    this.setHSL(parseFloat(r[1]) / 360, parseFloat(r[2]) / 100, parseFloat(r[3]) / 100, t);
                break;
            default:
                console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const r = i[1]
              , o = r.length;
            if (o === 3)
                return this.setRGB(parseInt(r.charAt(0), 16) / 15, parseInt(r.charAt(1), 16) / 15, parseInt(r.charAt(2), 16) / 15, t);
            if (o === 6)
                return this.setHex(parseInt(r, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0)
            return this.setColorName(e, t);
        return this
    }
    setColorName(e, t=Tt) {
        const n = Gc[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e),
        this
    }
    clone() {
        return new this.constructor(this.r,this.g,this.b)
    }
    copy(e) {
        return this.r = e.r,
        this.g = e.g,
        this.b = e.b,
        this
    }
    copySRGBToLinear(e) {
        return this.r = Di(e.r),
        this.g = Di(e.g),
        this.b = Di(e.b),
        this
    }
    copyLinearToSRGB(e) {
        return this.r = Ir(e.r),
        this.g = Ir(e.g),
        this.b = Ir(e.b),
        this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this),
        this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this),
        this
    }
    getHex(e=Tt) {
        return je.fromWorkingColorSpace(Et.copy(this), e),
        Math.round(ft(Et.r * 255, 0, 255)) * 65536 + Math.round(ft(Et.g * 255, 0, 255)) * 256 + Math.round(ft(Et.b * 255, 0, 255))
    }
    getHexString(e=Tt) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t=je.workingColorSpace) {
        je.fromWorkingColorSpace(Et.copy(this), t);
        const n = Et.r
          , i = Et.g
          , r = Et.b
          , o = Math.max(n, i, r)
          , a = Math.min(n, i, r);
        let l, c;
        const h = (a + o) / 2;
        if (a === o)
            l = 0,
            c = 0;
        else {
            const d = o - a;
            switch (c = h <= .5 ? d / (o + a) : d / (2 - o - a),
            o) {
            case n:
                l = (i - r) / d + (i < r ? 6 : 0);
                break;
            case i:
                l = (r - n) / d + 2;
                break;
            case r:
                l = (n - i) / d + 4;
                break
            }
            l /= 6
        }
        return e.h = l,
        e.s = c,
        e.l = h,
        e
    }
    getRGB(e, t=je.workingColorSpace) {
        return je.fromWorkingColorSpace(Et.copy(this), t),
        e.r = Et.r,
        e.g = Et.g,
        e.b = Et.b,
        e
    }
    getStyle(e=Tt) {
        je.fromWorkingColorSpace(Et.copy(this), e);
        const t = Et.r
          , n = Et.g
          , i = Et.b;
        return e !== Tt ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t * 255)},${Math.round(n * 255)},${Math.round(i * 255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(On),
        this.setHSL(On.h + e, On.s + t, On.l + n)
    }
    add(e) {
        return this.r += e.r,
        this.g += e.g,
        this.b += e.b,
        this
    }
    addColors(e, t) {
        return this.r = e.r + t.r,
        this.g = e.g + t.g,
        this.b = e.b + t.b,
        this
    }
    addScalar(e) {
        return this.r += e,
        this.g += e,
        this.b += e,
        this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r),
        this.g = Math.max(0, this.g - e.g),
        this.b = Math.max(0, this.b - e.b),
        this
    }
    multiply(e) {
        return this.r *= e.r,
        this.g *= e.g,
        this.b *= e.b,
        this
    }
    multiplyScalar(e) {
        return this.r *= e,
        this.g *= e,
        this.b *= e,
        this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t,
        this.g += (e.g - this.g) * t,
        this.b += (e.b - this.b) * t,
        this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n,
        this.g = e.g + (t.g - e.g) * n,
        this.b = e.b + (t.b - e.b) * n,
        this
    }
    lerpHSL(e, t) {
        this.getHSL(On),
        e.getHSL(Ds);
        const n = os(On.h, Ds.h, t)
          , i = os(On.s, Ds.s, t)
          , r = os(On.l, Ds.l, t);
        return this.setHSL(n, i, r),
        this
    }
    setFromVector3(e) {
        return this.r = e.x,
        this.g = e.y,
        this.b = e.z,
        this
    }
    applyMatrix3(e) {
        const t = this.r
          , n = this.g
          , i = this.b
          , r = e.elements;
        return this.r = r[0] * t + r[3] * n + r[6] * i,
        this.g = r[1] * t + r[4] * n + r[7] * i,
        this.b = r[2] * t + r[5] * n + r[8] * i,
        this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t=0) {
        return this.r = e[t],
        this.g = e[t + 1],
        this.b = e[t + 2],
        this
    }
    toArray(e=[], t=0) {
        return e[t] = this.r,
        e[t + 1] = this.g,
        e[t + 2] = this.b,
        e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t),
        this.g = e.getY(t),
        this.b = e.getZ(t),
        this
    }
    toJSON() {
        return this.getHex()
    }
    *[Symbol.iterator]() {
        yield this.r,
        yield this.g,
        yield this.b
    }
}
const Et = new be;
be.NAMES = Gc;
let kd = 0;
class $t extends ri {
    constructor() {
        super(),
        this.isMaterial = !0,
        Object.defineProperty(this, "id", {
            value: kd++
        }),
        this.uuid = Vt(),
        this.name = "",
        this.type = "Material",
        this.blending = Ri,
        this.side = Jt,
        this.vertexColors = !1,
        this.opacity = 1,
        this.transparent = !1,
        this.alphaHash = !1,
        this.blendSrc = go,
        this.blendDst = Mo,
        this.blendEquation = ei,
        this.blendSrcAlpha = null,
        this.blendDstAlpha = null,
        this.blendEquationAlpha = null,
        this.blendColor = new be(0,0,0),
        this.blendAlpha = 0,
        this.depthFunc = dr,
        this.depthTest = !0,
        this.depthWrite = !0,
        this.stencilWriteMask = 255,
        this.stencilFunc = ii,
        this.stencilRef = 0,
        this.stencilFuncMask = 255,
        this.stencilFail = kn,
        this.stencilZFail = kn,
        this.stencilZPass = kn,
        this.stencilWrite = !1,
        this.clippingPlanes = null,
        this.clipIntersection = !1,
        this.clipShadows = !1,
        this.shadowSide = null,
        this.colorWrite = !0,
        this.precision = null,
        this.polygonOffset = !1,
        this.polygonOffsetFactor = 0,
        this.polygonOffsetUnits = 0,
        this.dithering = !1,
        this.alphaToCoverage = !1,
        this.premultipliedAlpha = !1,
        this.forceSinglePass = !1,
        this.visible = !0,
        this.toneMapped = !0,
        this.userData = {},
        this.version = 0,
        this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++,
        this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid,
        n.type = this.type,
        this.name !== "" && (n.name = this.name),
        this.color && this.color.isColor && (n.color = this.color.getHex()),
        this.roughness !== void 0 && (n.roughness = this.roughness),
        this.metalness !== void 0 && (n.metalness = this.metalness),
        this.sheen !== void 0 && (n.sheen = this.sheen),
        this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()),
        this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness),
        this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()),
        this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity),
        this.specular && this.specular.isColor && (n.specular = this.specular.getHex()),
        this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity),
        this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()),
        this.shininess !== void 0 && (n.shininess = this.shininess),
        this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat),
        this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness),
        this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid),
        this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid),
        this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid,
        n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()),
        this.dispersion !== void 0 && (n.dispersion = this.dispersion),
        this.iridescence !== void 0 && (n.iridescence = this.iridescence),
        this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR),
        this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange),
        this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid),
        this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid),
        this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy),
        this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation),
        this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid),
        this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid),
        this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid),
        this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid),
        this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid,
        n.lightMapIntensity = this.lightMapIntensity),
        this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid,
        n.aoMapIntensity = this.aoMapIntensity),
        this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid,
        n.bumpScale = this.bumpScale),
        this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid,
        n.normalMapType = this.normalMapType,
        n.normalScale = this.normalScale.toArray()),
        this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid,
        n.displacementScale = this.displacementScale,
        n.displacementBias = this.displacementBias),
        this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid),
        this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid),
        this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid),
        this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid),
        this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid),
        this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid),
        this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid,
        this.combine !== void 0 && (n.combine = this.combine)),
        this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()),
        this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity),
        this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity),
        this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio),
        this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid),
        this.transmission !== void 0 && (n.transmission = this.transmission),
        this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid),
        this.thickness !== void 0 && (n.thickness = this.thickness),
        this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid),
        this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance),
        this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()),
        this.size !== void 0 && (n.size = this.size),
        this.shadowSide !== null && (n.shadowSide = this.shadowSide),
        this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation),
        this.blending !== Ri && (n.blending = this.blending),
        this.side !== Jt && (n.side = this.side),
        this.vertexColors === !0 && (n.vertexColors = !0),
        this.opacity < 1 && (n.opacity = this.opacity),
        this.transparent === !0 && (n.transparent = !0),
        this.blendSrc !== go && (n.blendSrc = this.blendSrc),
        this.blendDst !== Mo && (n.blendDst = this.blendDst),
        this.blendEquation !== ei && (n.blendEquation = this.blendEquation),
        this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha),
        this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha),
        this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha),
        this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()),
        this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha),
        this.depthFunc !== dr && (n.depthFunc = this.depthFunc),
        this.depthTest === !1 && (n.depthTest = this.depthTest),
        this.depthWrite === !1 && (n.depthWrite = this.depthWrite),
        this.colorWrite === !1 && (n.colorWrite = this.colorWrite),
        this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask),
        this.stencilFunc !== ii && (n.stencilFunc = this.stencilFunc),
        this.stencilRef !== 0 && (n.stencilRef = this.stencilRef),
        this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask),
        this.stencilFail !== kn && (n.stencilFail = this.stencilFail),
        this.stencilZFail !== kn && (n.stencilZFail = this.stencilZFail),
        this.stencilZPass !== kn && (n.stencilZPass = this.stencilZPass),
        this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite),
        this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation),
        this.polygonOffset === !0 && (n.polygonOffset = !0),
        this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor),
        this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits),
        this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth),
        this.dashSize !== void 0 && (n.dashSize = this.dashSize),
        this.gapSize !== void 0 && (n.gapSize = this.gapSize),
        this.scale !== void 0 && (n.scale = this.scale),
        this.dithering === !0 && (n.dithering = !0),
        this.alphaTest > 0 && (n.alphaTest = this.alphaTest),
        this.alphaHash === !0 && (n.alphaHash = !0),
        this.alphaToCoverage === !0 && (n.alphaToCoverage = !0),
        this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0),
        this.forceSinglePass === !0 && (n.forceSinglePass = !0),
        this.wireframe === !0 && (n.wireframe = !0),
        this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth),
        this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap),
        this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin),
        this.flatShading === !0 && (n.flatShading = !0),
        this.visible === !1 && (n.visible = !1),
        this.toneMapped === !1 && (n.toneMapped = !1),
        this.fog === !1 && (n.fog = !1),
        Object.keys(this.userData).length > 0 && (n.userData = this.userData);
        function i(r) {
            const o = [];
            for (const a in r) {
                const l = r[a];
                delete l.metadata,
                o.push(l)
            }
            return o
        }
        if (t) {
            const r = i(e.textures)
              , o = i(e.images);
            r.length > 0 && (n.textures = r),
            o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name,
        this.blending = e.blending,
        this.side = e.side,
        this.vertexColors = e.vertexColors,
        this.opacity = e.opacity,
        this.transparent = e.transparent,
        this.blendSrc = e.blendSrc,
        this.blendDst = e.blendDst,
        this.blendEquation = e.blendEquation,
        this.blendSrcAlpha = e.blendSrcAlpha,
        this.blendDstAlpha = e.blendDstAlpha,
        this.blendEquationAlpha = e.blendEquationAlpha,
        this.blendColor.copy(e.blendColor),
        this.blendAlpha = e.blendAlpha,
        this.depthFunc = e.depthFunc,
        this.depthTest = e.depthTest,
        this.depthWrite = e.depthWrite,
        this.stencilWriteMask = e.stencilWriteMask,
        this.stencilFunc = e.stencilFunc,
        this.stencilRef = e.stencilRef,
        this.stencilFuncMask = e.stencilFuncMask,
        this.stencilFail = e.stencilFail,
        this.stencilZFail = e.stencilZFail,
        this.stencilZPass = e.stencilZPass,
        this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let r = 0; r !== i; ++r)
                n[r] = t[r].clone()
        }
        return this.clippingPlanes = n,
        this.clipIntersection = e.clipIntersection,
        this.clipShadows = e.clipShadows,
        this.shadowSide = e.shadowSide,
        this.colorWrite = e.colorWrite,
        this.precision = e.precision,
        this.polygonOffset = e.polygonOffset,
        this.polygonOffsetFactor = e.polygonOffsetFactor,
        this.polygonOffsetUnits = e.polygonOffsetUnits,
        this.dithering = e.dithering,
        this.alphaTest = e.alphaTest,
        this.alphaHash = e.alphaHash,
        this.alphaToCoverage = e.alphaToCoverage,
        this.premultipliedAlpha = e.premultipliedAlpha,
        this.forceSinglePass = e.forceSinglePass,
        this.visible = e.visible,
        this.toneMapped = e.toneMapped,
        this.userData = JSON.parse(JSON.stringify(e.userData)),
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
class wn extends $t {
    constructor(e) {
        super(),
        this.isMeshBasicMaterial = !0,
        this.type = "MeshBasicMaterial",
        this.color = new be(16777215),
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.specularMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new cn,
        this.combine = mc,
        this.reflectivity = 1,
        this.refractionRatio = .98,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.specularMap = e.specularMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.combine = e.combine,
        this.reflectivity = e.reflectivity,
        this.refractionRatio = e.refractionRatio,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.fog = e.fog,
        this
    }
}
const bn = Hd();
function Hd() {
    const s = new ArrayBuffer(4)
      , e = new Float32Array(s)
      , t = new Uint32Array(s)
      , n = new Uint32Array(512)
      , i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (n[l] = 0,
        n[l | 256] = 32768,
        i[l] = 24,
        i[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14,
        n[l | 256] = 1024 >> -c - 14 | 32768,
        i[l] = -c - 1,
        i[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10,
        n[l | 256] = c + 15 << 10 | 32768,
        i[l] = 13,
        i[l | 256] = 13) : c < 128 ? (n[l] = 31744,
        n[l | 256] = 64512,
        i[l] = 24,
        i[l | 256] = 24) : (n[l] = 31744,
        n[l | 256] = 64512,
        i[l] = 13,
        i[l | 256] = 13)
    }
    const r = new Uint32Array(2048)
      , o = new Uint32Array(64)
      , a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13
          , h = 0;
        for (; !(c & 8388608); )
            c <<= 1,
            h -= 8388608;
        c &= -8388609,
        h += 947912704,
        r[l] = c | h
    }
    for (let l = 1024; l < 2048; ++l)
        r[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l)
        o[l] = l << 23;
    o[31] = 1199570944,
    o[32] = 2147483648;
    for (let l = 33; l < 63; ++l)
        o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l)
        l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: n,
        shiftTable: i,
        mantissaTable: r,
        exponentTable: o,
        offsetTable: a
    }
}
function Gd(s) {
    Math.abs(s) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."),
    s = ft(s, -65504, 65504),
    bn.floatView[0] = s;
    const e = bn.uint32View[0]
      , t = e >> 23 & 511;
    return bn.baseTable[t] + ((e & 8388607) >> bn.shiftTable[t])
}
function Vd(s) {
    const e = s >> 10;
    return bn.uint32View[0] = bn.mantissaTable[bn.offsetTable[e] + (s & 1023)] + bn.exponentTable[e],
    bn.floatView[0]
}
const Ls = {
    toHalfFloat: Gd,
    fromHalfFloat: Vd
}
  , ut = new C
  , Is = new ee;
class Dt {
    constructor(e, t, n=!1) {
        if (Array.isArray(e))
            throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0,
        this.name = "",
        this.array = e,
        this.itemSize = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.normalized = n,
        this.usage = Yo,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.gpuType = Pt,
        this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return Pi("THREE.BufferAttribute: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name,
        this.array = new e.array.constructor(e.array),
        this.itemSize = e.itemSize,
        this.count = e.count,
        this.normalized = e.normalized,
        this.usage = e.usage,
        this.gpuType = e.gpuType,
        this
    }
    copyAt(e, t, n) {
        e *= this.itemSize,
        n *= t.itemSize;
        for (let i = 0, r = this.itemSize; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e),
        this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++)
                Is.fromBufferAttribute(this, t),
                Is.applyMatrix3(e),
                this.setXY(t, Is.x, Is.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++)
                ut.fromBufferAttribute(this, t),
                ut.applyMatrix3(e),
                this.setXYZ(t, ut.x, ut.y, ut.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ut.fromBufferAttribute(this, t),
            ut.applyMatrix4(e),
            this.setXYZ(t, ut.x, ut.y, ut.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ut.fromBufferAttribute(this, t),
            ut.applyNormalMatrix(e),
            this.setXYZ(t, ut.x, ut.y, ut.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            ut.fromBufferAttribute(this, t),
            ut.transformDirection(e),
            this.setXYZ(t, ut.x, ut.y, ut.z);
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = Kt(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = et(n, this.array)),
        this.array[e * this.itemSize + t] = n,
        this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    setX(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.array[e * this.itemSize] = t,
        this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    setY(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.array[e * this.itemSize + 1] = t,
        this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    setZ(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.array[e * this.itemSize + 2] = t,
        this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    setW(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.array[e * this.itemSize + 3] = t,
        this
    }
    setXY(e, t, n) {
        return e *= this.itemSize,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array),
        i = et(i, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e *= this.itemSize,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array),
        i = et(i, this.array),
        r = et(r, this.array)),
        this.array[e + 0] = t,
        this.array[e + 1] = n,
        this.array[e + 2] = i,
        this.array[e + 3] = r,
        this
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    clone() {
        return new this.constructor(this.array,this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name),
        this.usage !== Yo && (e.usage = this.usage),
        e
    }
}
class Vc extends Dt {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class Wc extends Dt {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class Zt extends Dt {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let Wd = 0;
const kt = new Oe
  , Yr = new it
  , gi = new C
  , Ot = new Pn
  , Zi = new Pn
  , Mt = new C;
class Qt extends ri {
    constructor() {
        super(),
        this.isBufferGeometry = !0,
        Object.defineProperty(this, "id", {
            value: Wd++
        }),
        this.uuid = Vt(),
        this.name = "",
        this.type = "BufferGeometry",
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.morphTargetsRelative = !1,
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null,
        this.drawRange = {
            start: 0,
            count: 1 / 0
        },
        this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new (Bc(e) ? Wc : Vc)(e,1) : this.index = e,
        this
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t,
        this
    }
    deleteAttribute(e) {
        return delete this.attributes[e],
        this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n=0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e,
        this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e),
        t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const r = new He().getNormalMatrix(e);
            n.applyNormalMatrix(r),
            n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e),
        i.needsUpdate = !0),
        this.boundingBox !== null && this.computeBoundingBox(),
        this.boundingSphere !== null && this.computeBoundingSphere(),
        this
    }
    applyQuaternion(e) {
        return kt.makeRotationFromQuaternion(e),
        this.applyMatrix4(kt),
        this
    }
    rotateX(e) {
        return kt.makeRotationX(e),
        this.applyMatrix4(kt),
        this
    }
    rotateY(e) {
        return kt.makeRotationY(e),
        this.applyMatrix4(kt),
        this
    }
    rotateZ(e) {
        return kt.makeRotationZ(e),
        this.applyMatrix4(kt),
        this
    }
    translate(e, t, n) {
        return kt.makeTranslation(e, t, n),
        this.applyMatrix4(kt),
        this
    }
    scale(e, t, n) {
        return kt.makeScale(e, t, n),
        this.applyMatrix4(kt),
        this
    }
    lookAt(e) {
        return Yr.lookAt(e),
        Yr.updateMatrix(),
        this.applyMatrix4(Yr.matrix),
        this
    }
    center() {
        return this.computeBoundingBox(),
        this.boundingBox.getCenter(gi).negate(),
        this.translate(gi.x, gi.y, gi.z),
        this
    }
    setFromPoints(e) {
        const t = [];
        for (let n = 0, i = e.length; n < i; n++) {
            const r = e[n];
            t.push(r.x, r.y, r.z || 0)
        }
        return this.setAttribute("position", new Zt(t,3)),
        this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Pn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this),
            this.boundingBox.set(new C(-1 / 0,-1 / 0,-1 / 0), new C(1 / 0,1 / 0,1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e),
            t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const r = t[n];
                    Ot.setFromBufferAttribute(r),
                    this.morphTargetsRelative ? (Mt.addVectors(this.boundingBox.min, Ot.min),
                    this.boundingBox.expandByPoint(Mt),
                    Mt.addVectors(this.boundingBox.max, Ot.max),
                    this.boundingBox.expandByPoint(Mt)) : (this.boundingBox.expandByPoint(Ot.min),
                    this.boundingBox.expandByPoint(Ot.max))
                }
        } else
            this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new dn);
        const e = this.attributes.position
          , t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this),
            this.boundingSphere.set(new C, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (Ot.setFromBufferAttribute(e),
            t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r];
                    Zi.setFromBufferAttribute(a),
                    this.morphTargetsRelative ? (Mt.addVectors(Ot.min, Zi.min),
                    Ot.expandByPoint(Mt),
                    Mt.addVectors(Ot.max, Zi.max),
                    Ot.expandByPoint(Mt)) : (Ot.expandByPoint(Zi.min),
                    Ot.expandByPoint(Zi.max))
                }
            Ot.getCenter(n);
            let i = 0;
            for (let r = 0, o = e.count; r < o; r++)
                Mt.fromBufferAttribute(e, r),
                i = Math.max(i, n.distanceToSquared(Mt));
            if (t)
                for (let r = 0, o = t.length; r < o; r++) {
                    const a = t[r]
                      , l = this.morphTargetsRelative;
                    for (let c = 0, h = a.count; c < h; c++)
                        Mt.fromBufferAttribute(a, c),
                        l && (gi.fromBufferAttribute(e, c),
                        Mt.add(gi)),
                        i = Math.max(i, n.distanceToSquared(Mt))
                }
            this.boundingSphere.radius = Math.sqrt(i),
            isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index
          , t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position
          , i = t.normal
          , r = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new Dt(new Float32Array(4 * n.count),4));
        const o = this.getAttribute("tangent")
          , a = []
          , l = [];
        for (let w = 0; w < n.count; w++)
            a[w] = new C,
            l[w] = new C;
        const c = new C
          , h = new C
          , d = new C
          , u = new ee
          , f = new ee
          , g = new ee
          , M = new C
          , m = new C;
        function p(w, S, y) {
            c.fromBufferAttribute(n, w),
            h.fromBufferAttribute(n, S),
            d.fromBufferAttribute(n, y),
            u.fromBufferAttribute(r, w),
            f.fromBufferAttribute(r, S),
            g.fromBufferAttribute(r, y),
            h.sub(c),
            d.sub(c),
            f.sub(u),
            g.sub(u);
            const D = 1 / (f.x * g.y - g.x * f.y);
            isFinite(D) && (M.copy(h).multiplyScalar(g.y).addScaledVector(d, -f.y).multiplyScalar(D),
            m.copy(d).multiplyScalar(f.x).addScaledVector(h, -g.x).multiplyScalar(D),
            a[w].add(M),
            a[S].add(M),
            a[y].add(M),
            l[w].add(m),
            l[S].add(m),
            l[y].add(m))
        }
        let E = this.groups;
        E.length === 0 && (E = [{
            start: 0,
            count: e.count
        }]);
        for (let w = 0, S = E.length; w < S; ++w) {
            const y = E[w]
              , D = y.start
              , G = y.count;
            for (let F = D, O = D + G; F < O; F += 3)
                p(e.getX(F + 0), e.getX(F + 1), e.getX(F + 2))
        }
        const _ = new C
          , v = new C
          , L = new C
          , P = new C;
        function A(w) {
            L.fromBufferAttribute(i, w),
            P.copy(L);
            const S = a[w];
            _.copy(S),
            _.sub(L.multiplyScalar(L.dot(S))).normalize(),
            v.crossVectors(P, S);
            const D = v.dot(l[w]) < 0 ? -1 : 1;
            o.setXYZW(w, _.x, _.y, _.z, D)
        }
        for (let w = 0, S = E.length; w < S; ++w) {
            const y = E[w]
              , D = y.start
              , G = y.count;
            for (let F = D, O = D + G; F < O; F += 3)
                A(e.getX(F + 0)),
                A(e.getX(F + 1)),
                A(e.getX(F + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index
          , t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0)
                n = new Dt(new Float32Array(t.count * 3),3),
                this.setAttribute("normal", n);
            else
                for (let u = 0, f = n.count; u < f; u++)
                    n.setXYZ(u, 0, 0, 0);
            const i = new C
              , r = new C
              , o = new C
              , a = new C
              , l = new C
              , c = new C
              , h = new C
              , d = new C;
            if (e)
                for (let u = 0, f = e.count; u < f; u += 3) {
                    const g = e.getX(u + 0)
                      , M = e.getX(u + 1)
                      , m = e.getX(u + 2);
                    i.fromBufferAttribute(t, g),
                    r.fromBufferAttribute(t, M),
                    o.fromBufferAttribute(t, m),
                    h.subVectors(o, r),
                    d.subVectors(i, r),
                    h.cross(d),
                    a.fromBufferAttribute(n, g),
                    l.fromBufferAttribute(n, M),
                    c.fromBufferAttribute(n, m),
                    a.add(h),
                    l.add(h),
                    c.add(h),
                    n.setXYZ(g, a.x, a.y, a.z),
                    n.setXYZ(M, l.x, l.y, l.z),
                    n.setXYZ(m, c.x, c.y, c.z)
                }
            else
                for (let u = 0, f = t.count; u < f; u += 3)
                    i.fromBufferAttribute(t, u + 0),
                    r.fromBufferAttribute(t, u + 1),
                    o.fromBufferAttribute(t, u + 2),
                    h.subVectors(o, r),
                    d.subVectors(i, r),
                    h.cross(d),
                    n.setXYZ(u + 0, h.x, h.y, h.z),
                    n.setXYZ(u + 1, h.x, h.y, h.z),
                    n.setXYZ(u + 2, h.x, h.y, h.z);
            this.normalizeNormals(),
            n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++)
            Mt.fromBufferAttribute(e, t),
            Mt.normalize(),
            e.setXYZ(t, Mt.x, Mt.y, Mt.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array
              , h = a.itemSize
              , d = a.normalized
              , u = new c.constructor(l.length * h);
            let f = 0
              , g = 0;
            for (let M = 0, m = l.length; M < m; M++) {
                a.isInterleavedBufferAttribute ? f = l[M] * a.data.stride + a.offset : f = l[M] * h;
                for (let p = 0; p < h; p++)
                    u[g++] = c[f++]
            }
            return new Dt(u,h,d)
        }
        if (this.index === null)
            return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."),
            this;
        const t = new Qt
          , n = this.index.array
          , i = this.attributes;
        for (const a in i) {
            const l = i[a]
              , c = e(l, n);
            t.setAttribute(a, c)
        }
        const r = this.morphAttributes;
        for (const a in r) {
            const l = []
              , c = r[a];
            for (let h = 0, d = c.length; h < d; h++) {
                const u = c[h]
                  , f = e(u, n);
                l.push(f)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid,
        e.type = this.type,
        this.name !== "" && (e.name = this.name),
        Object.keys(this.userData).length > 0 && (e.userData = this.userData),
        this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l)
                l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const i = {};
        let r = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l]
              , h = [];
            for (let d = 0, u = c.length; d < u; d++) {
                const f = c[d];
                h.push(f.toJSON(e.data))
            }
            h.length > 0 && (i[l] = h,
            r = !0)
        }
        r && (e.data.morphAttributes = i,
        e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }),
        e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null,
        this.attributes = {},
        this.morphAttributes = {},
        this.groups = [],
        this.boundingBox = null,
        this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const c in i) {
            const h = i[c];
            this.setAttribute(c, h.clone(t))
        }
        const r = e.morphAttributes;
        for (const c in r) {
            const h = []
              , d = r[c];
            for (let u = 0, f = d.length; u < f; u++)
                h.push(d[u].clone(t));
            this.morphAttributes[c] = h
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, h = o.length; c < h; c++) {
            const d = o[c];
            this.addGroup(d.start, d.count, d.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()),
        this.drawRange.start = e.drawRange.start,
        this.drawRange.count = e.drawRange.count,
        this.userData = e.userData,
        this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const ol = new Oe
  , jn = new vs
  , Us = new dn
  , al = new C
  , Mi = new C
  , _i = new C
  , vi = new C
  , jr = new C
  , Ns = new C
  , Fs = new ee
  , Os = new ee
  , Bs = new ee
  , ll = new C
  , cl = new C
  , hl = new C
  , zs = new C
  , ks = new C;
class ct extends it {
    constructor(e=new Qt, t=new wn) {
        super(),
        this.isMesh = !0,
        this.type = "Mesh",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()),
        e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = i.length; r < o; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry
          , i = n.attributes.position
          , r = n.morphAttributes.position
          , o = n.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (r && a) {
            Ns.set(0, 0, 0);
            for (let l = 0, c = r.length; l < c; l++) {
                const h = a[l]
                  , d = r[l];
                h !== 0 && (jr.fromBufferAttribute(d, e),
                o ? Ns.addScaledVector(jr, h) : Ns.addScaledVector(jr.sub(t), h))
            }
            t.add(Ns)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.material
          , r = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(),
        Us.copy(n.boundingSphere),
        Us.applyMatrix4(r),
        jn.copy(e.ray).recast(e.near),
        !(Us.containsPoint(jn.origin) === !1 && (jn.intersectSphere(Us, al) === null || jn.origin.distanceToSquared(al) > (e.far - e.near) ** 2)) && (ol.copy(r).invert(),
        jn.copy(e.ray).applyMatrix4(ol),
        !(n.boundingBox !== null && jn.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, jn)))
    }
    _computeIntersections(e, t, n) {
        let i;
        const r = this.geometry
          , o = this.material
          , a = r.index
          , l = r.attributes.position
          , c = r.attributes.uv
          , h = r.attributes.uv1
          , d = r.attributes.normal
          , u = r.groups
          , f = r.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let g = 0, M = u.length; g < M; g++) {
                    const m = u[g]
                      , p = o[m.materialIndex]
                      , E = Math.max(m.start, f.start)
                      , _ = Math.min(a.count, Math.min(m.start + m.count, f.start + f.count));
                    for (let v = E, L = _; v < L; v += 3) {
                        const P = a.getX(v)
                          , A = a.getX(v + 1)
                          , w = a.getX(v + 2);
                        i = Hs(this, p, e, n, c, h, d, P, A, w),
                        i && (i.faceIndex = Math.floor(v / 3),
                        i.face.materialIndex = m.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const g = Math.max(0, f.start)
                  , M = Math.min(a.count, f.start + f.count);
                for (let m = g, p = M; m < p; m += 3) {
                    const E = a.getX(m)
                      , _ = a.getX(m + 1)
                      , v = a.getX(m + 2);
                    i = Hs(this, o, e, n, c, h, d, E, _, v),
                    i && (i.faceIndex = Math.floor(m / 3),
                    t.push(i))
                }
            }
        else if (l !== void 0)
            if (Array.isArray(o))
                for (let g = 0, M = u.length; g < M; g++) {
                    const m = u[g]
                      , p = o[m.materialIndex]
                      , E = Math.max(m.start, f.start)
                      , _ = Math.min(l.count, Math.min(m.start + m.count, f.start + f.count));
                    for (let v = E, L = _; v < L; v += 3) {
                        const P = v
                          , A = v + 1
                          , w = v + 2;
                        i = Hs(this, p, e, n, c, h, d, P, A, w),
                        i && (i.faceIndex = Math.floor(v / 3),
                        i.face.materialIndex = m.materialIndex,
                        t.push(i))
                    }
                }
            else {
                const g = Math.max(0, f.start)
                  , M = Math.min(l.count, f.start + f.count);
                for (let m = g, p = M; m < p; m += 3) {
                    const E = m
                      , _ = m + 1
                      , v = m + 2;
                    i = Hs(this, o, e, n, c, h, d, E, _, v),
                    i && (i.faceIndex = Math.floor(m / 3),
                    t.push(i))
                }
            }
    }
}
function Xd(s, e, t, n, i, r, o, a) {
    let l;
    if (e.side === It ? l = n.intersectTriangle(o, r, i, !0, a) : l = n.intersectTriangle(i, r, o, e.side === Jt, a),
    l === null)
        return null;
    ks.copy(a),
    ks.applyMatrix4(s.matrixWorld);
    const c = t.ray.origin.distanceTo(ks);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: ks.clone(),
        object: s
    }
}
function Hs(s, e, t, n, i, r, o, a, l, c) {
    s.getVertexPosition(a, Mi),
    s.getVertexPosition(l, _i),
    s.getVertexPosition(c, vi);
    const h = Xd(s, e, t, n, Mi, _i, vi, zs);
    if (h) {
        i && (Fs.fromBufferAttribute(i, a),
        Os.fromBufferAttribute(i, l),
        Bs.fromBufferAttribute(i, c),
        h.uv = nn.getInterpolation(zs, Mi, _i, vi, Fs, Os, Bs, new ee)),
        r && (Fs.fromBufferAttribute(r, a),
        Os.fromBufferAttribute(r, l),
        Bs.fromBufferAttribute(r, c),
        h.uv1 = nn.getInterpolation(zs, Mi, _i, vi, Fs, Os, Bs, new ee)),
        o && (ll.fromBufferAttribute(o, a),
        cl.fromBufferAttribute(o, l),
        hl.fromBufferAttribute(o, c),
        h.normal = nn.getInterpolation(zs, Mi, _i, vi, ll, cl, hl, new C),
        h.normal.dot(n.direction) > 0 && h.normal.multiplyScalar(-1));
        const d = {
            a,
            b: l,
            c,
            normal: new C,
            materialIndex: 0
        };
        nn.getNormal(Mi, _i, vi, d.normal),
        h.face = d
    }
    return h
}
class xs extends Qt {
    constructor(e=1, t=1, n=1, i=1, r=1, o=1) {
        super(),
        this.type = "BoxGeometry",
        this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: r,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i),
        r = Math.floor(r),
        o = Math.floor(o);
        const l = []
          , c = []
          , h = []
          , d = [];
        let u = 0
          , f = 0;
        g("z", "y", "x", -1, -1, n, t, e, o, r, 0),
        g("z", "y", "x", 1, -1, n, t, -e, o, r, 1),
        g("x", "z", "y", 1, 1, e, n, t, i, o, 2),
        g("x", "z", "y", 1, -1, e, n, -t, i, o, 3),
        g("x", "y", "z", 1, -1, e, t, n, i, r, 4),
        g("x", "y", "z", -1, -1, e, t, -n, i, r, 5),
        this.setIndex(l),
        this.setAttribute("position", new Zt(c,3)),
        this.setAttribute("normal", new Zt(h,3)),
        this.setAttribute("uv", new Zt(d,2));
        function g(M, m, p, E, _, v, L, P, A, w, S) {
            const y = v / A
              , D = L / w
              , G = v / 2
              , F = L / 2
              , O = P / 2
              , V = A + 1
              , B = w + 1;
            let q = 0
              , W = 0;
            const ae = new C;
            for (let le = 0; le < B; le++) {
                const me = le * D - F;
                for (let Ce = 0; Ce < V; Ce++) {
                    const ze = Ce * y - G;
                    ae[M] = ze * E,
                    ae[m] = me * _,
                    ae[p] = O,
                    c.push(ae.x, ae.y, ae.z),
                    ae[M] = 0,
                    ae[m] = 0,
                    ae[p] = P > 0 ? 1 : -1,
                    h.push(ae.x, ae.y, ae.z),
                    d.push(Ce / A),
                    d.push(1 - le / w),
                    q += 1
                }
            }
            for (let le = 0; le < w; le++)
                for (let me = 0; me < A; me++) {
                    const Ce = u + me + V * le
                      , ze = u + me + V * (le + 1)
                      , X = u + (me + 1) + V * (le + 1)
                      , te = u + (me + 1) + V * le;
                    l.push(Ce, ze, te),
                    l.push(ze, X, te),
                    W += 6
                }
            a.addGroup(f, W, S),
            f += W,
            u += q
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new xs(e.width,e.height,e.depth,e.widthSegments,e.heightSegments,e.depthSegments)
    }
}
function ki(s) {
    const e = {};
    for (const t in s) {
        e[t] = {};
        for (const n in s[t]) {
            const i = s[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."),
            e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}
function Rt(s) {
    const e = {};
    for (let t = 0; t < s.length; t++) {
        const n = ki(s[t]);
        for (const i in n)
            e[i] = n[i]
    }
    return e
}
function qd(s) {
    const e = [];
    for (let t = 0; t < s.length; t++)
        e.push(s[t].clone());
    return e
}
function Xc(s) {
    const e = s.getRenderTarget();
    return e === null ? s.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : je.workingColorSpace
}
const qc = {
    clone: ki,
    merge: Rt
};
var Yd = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`
  , jd = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class hn extends $t {
    constructor(e) {
        super(),
        this.isShaderMaterial = !0,
        this.type = "ShaderMaterial",
        this.defines = {},
        this.uniforms = {},
        this.uniformsGroups = [],
        this.vertexShader = Yd,
        this.fragmentShader = jd,
        this.linewidth = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.fog = !1,
        this.lights = !1,
        this.clipping = !1,
        this.forceSinglePass = !0,
        this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        },
        this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        },
        this.index0AttributeName = void 0,
        this.uniformsNeedUpdate = !1,
        this.glslVersion = null,
        e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.fragmentShader = e.fragmentShader,
        this.vertexShader = e.vertexShader,
        this.uniforms = ki(e.uniforms),
        this.uniformsGroups = qd(e.uniformsGroups),
        this.defines = Object.assign({}, e.defines),
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.fog = e.fog,
        this.lights = e.lights,
        this.clipping = e.clipping,
        this.extensions = Object.assign({}, e.extensions),
        this.glslVersion = e.glslVersion,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion,
        t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines),
        t.vertexShader = this.vertexShader,
        t.fragmentShader = this.fragmentShader,
        t.lights = this.lights,
        t.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions)
            this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n),
        t
    }
}
let Yc = class extends it {
    constructor() {
        super(),
        this.isCamera = !0,
        this.type = "Camera",
        this.matrixWorldInverse = new Oe,
        this.projectionMatrix = new Oe,
        this.projectionMatrixInverse = new Oe,
        this.coordinateSystem = Tn
    }
    copy(e, t) {
        return super.copy(e, t),
        this.matrixWorldInverse.copy(e.matrixWorldInverse),
        this.projectionMatrix.copy(e.projectionMatrix),
        this.projectionMatrixInverse.copy(e.projectionMatrixInverse),
        this.coordinateSystem = e.coordinateSystem,
        this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t),
        this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
;
const Bn = new C
  , dl = new ee
  , ul = new ee;
class wt extends Yc {
    constructor(e=50, t=1, n=.1, i=2e3) {
        super(),
        this.isPerspectiveCamera = !0,
        this.type = "PerspectiveCamera",
        this.fov = e,
        this.zoom = 1,
        this.near = n,
        this.far = i,
        this.focus = 10,
        this.aspect = t,
        this.view = null,
        this.filmGauge = 35,
        this.filmOffset = 0,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.fov = e.fov,
        this.zoom = e.zoom,
        this.near = e.near,
        this.far = e.far,
        this.focus = e.focus,
        this.aspect = e.aspect,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this.filmGauge = e.filmGauge,
        this.filmOffset = e.filmOffset,
        this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = zi * 2 * Math.atan(t),
        this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(rs * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return zi * 2 * Math.atan(Math.tan(rs * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        Bn.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse),
        t.set(Bn.x, Bn.y).multiplyScalar(-e / Bn.z),
        Bn.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse),
        n.set(Bn.x, Bn.y).multiplyScalar(-e / Bn.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, dl, ul),
        t.subVectors(ul, dl)
    }
    setViewOffset(e, t, n, i, r, o) {
        this.aspect = e / t,
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(rs * .5 * this.fov) / this.zoom
          , n = 2 * t
          , i = this.aspect * n
          , r = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth
              , c = o.fullHeight;
            r += o.offsetX * i / l,
            t -= o.offsetY * n / c,
            i *= o.width / l,
            n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (r += e * a / this.getFilmWidth()),
        this.projectionMatrix.makePerspective(r, r + i, t, t - n, e, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov,
        t.object.zoom = this.zoom,
        t.object.near = this.near,
        t.object.far = this.far,
        t.object.focus = this.focus,
        t.object.aspect = this.aspect,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t.object.filmGauge = this.filmGauge,
        t.object.filmOffset = this.filmOffset,
        t
    }
}
const xi = -90
  , yi = 1;
class Kd extends it {
    constructor(e, t, n) {
        super(),
        this.type = "CubeCamera",
        this.renderTarget = n,
        this.coordinateSystem = null,
        this.activeMipmapLevel = 0;
        const i = new wt(xi,yi,e,t);
        i.layers = this.layers,
        this.add(i);
        const r = new wt(xi,yi,e,t);
        r.layers = this.layers,
        this.add(r);
        const o = new wt(xi,yi,e,t);
        o.layers = this.layers,
        this.add(o);
        const a = new wt(xi,yi,e,t);
        a.layers = this.layers,
        this.add(a);
        const l = new wt(xi,yi,e,t);
        l.layers = this.layers,
        this.add(l);
        const c = new wt(xi,yi,e,t);
        c.layers = this.layers,
        this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem
          , t = this.children.concat()
          , [n,i,r,o,a,l] = t;
        for (const c of t)
            this.remove(c);
        if (e === Tn)
            n.up.set(0, 1, 0),
            n.lookAt(1, 0, 0),
            i.up.set(0, 1, 0),
            i.lookAt(-1, 0, 0),
            r.up.set(0, 0, -1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, 1),
            o.lookAt(0, -1, 0),
            a.up.set(0, 1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, 1, 0),
            l.lookAt(0, 0, -1);
        else if (e === gr)
            n.up.set(0, -1, 0),
            n.lookAt(-1, 0, 0),
            i.up.set(0, -1, 0),
            i.lookAt(1, 0, 0),
            r.up.set(0, 0, 1),
            r.lookAt(0, 1, 0),
            o.up.set(0, 0, -1),
            o.lookAt(0, -1, 0),
            a.up.set(0, -1, 0),
            a.lookAt(0, 0, 1),
            l.up.set(0, -1, 0),
            l.lookAt(0, 0, -1);
        else
            throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t)
            this.add(c),
            c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {renderTarget: n, activeMipmapLevel: i} = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem,
        this.updateCoordinateSystem());
        const [r,o,a,l,c,h] = this.children
          , d = e.getRenderTarget()
          , u = e.getActiveCubeFace()
          , f = e.getActiveMipmapLevel()
          , g = e.xr.enabled;
        e.xr.enabled = !1;
        const M = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1,
        e.setRenderTarget(n, 0, i),
        e.render(t, r),
        e.setRenderTarget(n, 1, i),
        e.render(t, o),
        e.setRenderTarget(n, 2, i),
        e.render(t, a),
        e.setRenderTarget(n, 3, i),
        e.render(t, l),
        e.setRenderTarget(n, 4, i),
        e.render(t, c),
        n.texture.generateMipmaps = M,
        e.setRenderTarget(n, 5, i),
        e.render(t, h),
        e.setRenderTarget(d, u, f),
        e.xr.enabled = g,
        n.texture.needsPMREMUpdate = !0
    }
}
class fa extends vt {
    constructor(e, t, n, i, r, o, a, l, c, h) {
        e = e !== void 0 ? e : [],
        t = t !== void 0 ? t : Ui,
        super(e, t, n, i, r, o, a, l, c, h),
        this.isCubeTexture = !0,
        this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class $d extends Wn {
    constructor(e=1, t={}) {
        super(e, e, t),
        this.isWebGLCubeRenderTarget = !0;
        const n = {
            width: e,
            height: e,
            depth: 1
        }
          , i = [n, n, n, n, n, n];
        this.texture = new fa(i,t.mapping,t.wrapS,t.wrapT,t.magFilter,t.minFilter,t.format,t.type,t.anisotropy,t.colorSpace),
        this.texture.isRenderTargetTexture = !0,
        this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1,
        this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : _t
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type,
        this.texture.colorSpace = t.colorSpace,
        this.texture.generateMipmaps = t.generateMipmaps,
        this.texture.minFilter = t.minFilter,
        this.texture.magFilter = t.magFilter;
        const n = {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
            fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
        }
          , i = new xs(5,5,5)
          , r = new hn({
            name: "CubemapFromEquirect",
            uniforms: ki(n.uniforms),
            vertexShader: n.vertexShader,
            fragmentShader: n.fragmentShader,
            side: It,
            blending: Vn
        });
        r.uniforms.tEquirect.value = t;
        const o = new ct(i,r)
          , a = t.minFilter;
        return t.minFilter === rn && (t.minFilter = _t),
        new Kd(1,10,this).update(e, o),
        t.minFilter = a,
        o.geometry.dispose(),
        o.material.dispose(),
        this
    }
    clear(e, t, n, i) {
        const r = e.getRenderTarget();
        for (let o = 0; o < 6; o++)
            e.setRenderTarget(this, o),
            e.clear(t, n, i);
        e.setRenderTarget(r)
    }
}
const Kr = new C
  , Zd = new C
  , Jd = new He;
class We {
    constructor(e=new C(1,0,0), t=0) {
        this.isPlane = !0,
        this.normal = e,
        this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e),
        this.constant = t,
        this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n),
        this.constant = i,
        this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e),
        this.constant = -t.dot(this.normal),
        this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = Kr.subVectors(n, t).cross(Zd.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e),
        this
    }
    copy(e) {
        return this.normal.copy(e.normal),
        this.constant = e.constant,
        this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e),
        this.constant *= e,
        this
    }
    negate() {
        return this.constant *= -1,
        this.normal.negate(),
        this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(Kr)
          , i = this.normal.dot(n);
        if (i === 0)
            return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const r = -(e.start.dot(this.normal) + this.constant) / i;
        return r < 0 || r > 1 ? null : t.copy(e.start).addScaledVector(n, r)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start)
          , n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || Jd.getNormalMatrix(e)
          , i = this.coplanarPoint(Kr).applyMatrix4(e)
          , r = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(r),
        this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal),
        this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Kn = new dn
  , Gs = new C;
class pa {
    constructor(e=new We, t=new We, n=new We, i=new We, r=new We, o=new We) {
        this.planes = [e, t, n, i, r, o]
    }
    set(e, t, n, i, r, o) {
        const a = this.planes;
        return a[0].copy(e),
        a[1].copy(t),
        a[2].copy(n),
        a[3].copy(i),
        a[4].copy(r),
        a[5].copy(o),
        this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t=Tn) {
        const n = this.planes
          , i = e.elements
          , r = i[0]
          , o = i[1]
          , a = i[2]
          , l = i[3]
          , c = i[4]
          , h = i[5]
          , d = i[6]
          , u = i[7]
          , f = i[8]
          , g = i[9]
          , M = i[10]
          , m = i[11]
          , p = i[12]
          , E = i[13]
          , _ = i[14]
          , v = i[15];
        if (n[0].setComponents(l - r, u - c, m - f, v - p).normalize(),
        n[1].setComponents(l + r, u + c, m + f, v + p).normalize(),
        n[2].setComponents(l + o, u + h, m + g, v + E).normalize(),
        n[3].setComponents(l - o, u - h, m - g, v - E).normalize(),
        n[4].setComponents(l - a, u - d, m - M, v - _).normalize(),
        t === Tn)
            n[5].setComponents(l + a, u + d, m + M, v + _).normalize();
        else if (t === gr)
            n[5].setComponents(a, d, M, _).normalize();
        else
            throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0)
            e.boundingSphere === null && e.computeBoundingSphere(),
            Kn.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(),
            Kn.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(Kn)
    }
    intersectsSprite(e) {
        return Kn.center.set(0, 0, 0),
        Kn.radius = .7071067811865476,
        Kn.applyMatrix4(e.matrixWorld),
        this.intersectsSphere(Kn)
    }
    intersectsSphere(e) {
        const t = this.planes
          , n = e.center
          , i = -e.radius;
        for (let r = 0; r < 6; r++)
            if (t[r].distanceToPoint(n) < i)
                return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (Gs.x = i.normal.x > 0 ? e.max.x : e.min.x,
            Gs.y = i.normal.y > 0 ? e.max.y : e.min.y,
            Gs.z = i.normal.z > 0 ? e.max.z : e.min.z,
            i.distanceToPoint(Gs) < 0)
                return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0)
                return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
function jc() {
    let s = null
      , e = !1
      , t = null
      , n = null;
    function i(r, o) {
        t(r, o),
        n = s.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = s.requestAnimationFrame(i),
            e = !0)
        },
        stop: function() {
            s.cancelAnimationFrame(n),
            e = !1
        },
        setAnimationLoop: function(r) {
            t = r
        },
        setContext: function(r) {
            s = r
        }
    }
}
function Qd(s) {
    const e = new WeakMap;
    function t(a, l) {
        const c = a.array
          , h = a.usage
          , d = c.byteLength
          , u = s.createBuffer();
        s.bindBuffer(l, u),
        s.bufferData(l, c, h),
        a.onUploadCallback();
        let f;
        if (c instanceof Float32Array)
            f = s.FLOAT;
        else if (c instanceof Uint16Array)
            a.isFloat16BufferAttribute ? f = s.HALF_FLOAT : f = s.UNSIGNED_SHORT;
        else if (c instanceof Int16Array)
            f = s.SHORT;
        else if (c instanceof Uint32Array)
            f = s.UNSIGNED_INT;
        else if (c instanceof Int32Array)
            f = s.INT;
        else if (c instanceof Int8Array)
            f = s.BYTE;
        else if (c instanceof Uint8Array)
            f = s.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray)
            f = s.UNSIGNED_BYTE;
        else
            throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: u,
            type: f,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: d
        }
    }
    function n(a, l, c) {
        const h = l.array
          , d = l._updateRange
          , u = l.updateRanges;
        if (s.bindBuffer(c, a),
        d.count === -1 && u.length === 0 && s.bufferSubData(c, 0, h),
        u.length !== 0) {
            for (let f = 0, g = u.length; f < g; f++) {
                const M = u[f];
                s.bufferSubData(c, M.start * h.BYTES_PER_ELEMENT, h, M.start, M.count)
            }
            l.clearUpdateRanges()
        }
        d.count !== -1 && (s.bufferSubData(c, d.offset * h.BYTES_PER_ELEMENT, h, d.offset, d.count),
        d.count = -1),
        l.onUploadCallback()
    }
    function i(a) {
        return a.isInterleavedBufferAttribute && (a = a.data),
        e.get(a)
    }
    function r(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (s.deleteBuffer(l.buffer),
        e.delete(a))
    }
    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data),
        a.isGLBufferAttribute) {
            const h = e.get(a);
            (!h || h.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0)
            e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength)
                throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(c.buffer, a, l),
            c.version = a.version
        }
    }
    return {
        get: i,
        remove: r,
        update: o
    }
}
class an extends Qt {
    constructor(e=1, t=1, n=1, i=1) {
        super(),
        this.type = "PlaneGeometry",
        this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const r = e / 2
          , o = t / 2
          , a = Math.floor(n)
          , l = Math.floor(i)
          , c = a + 1
          , h = l + 1
          , d = e / a
          , u = t / l
          , f = []
          , g = []
          , M = []
          , m = [];
        for (let p = 0; p < h; p++) {
            const E = p * u - o;
            for (let _ = 0; _ < c; _++) {
                const v = _ * d - r;
                g.push(v, -E, 0),
                M.push(0, 0, 1),
                m.push(_ / a),
                m.push(1 - p / l)
            }
        }
        for (let p = 0; p < l; p++)
            for (let E = 0; E < a; E++) {
                const _ = E + c * p
                  , v = E + c * (p + 1)
                  , L = E + 1 + c * (p + 1)
                  , P = E + 1 + c * p;
                f.push(_, v, P),
                f.push(v, L, P)
            }
        this.setIndex(f),
        this.setAttribute("position", new Zt(g,3)),
        this.setAttribute("normal", new Zt(M,3)),
        this.setAttribute("uv", new Zt(m,2))
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    static fromJSON(e) {
        return new an(e.width,e.height,e.widthSegments,e.heightSegments)
    }
}
var eu = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`
  , tu = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`
  , nu = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`
  , iu = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , su = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`
  , ru = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`
  , ou = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`
  , au = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`
  , lu = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`
  , cu = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`
  , hu = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`
  , du = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`
  , uu = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`
  , fu = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`
  , pu = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`
  , mu = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`
  , gu = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`
  , Mu = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`
  , _u = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`
  , vu = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`
  , xu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`
  , yu = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`
  , Su = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`
  , bu = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`
  , Eu = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`
  , Tu = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`
  , wu = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`
  , Au = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`
  , Ru = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`
  , Cu = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`
  , Pu = "gl_FragColor = linearToOutputTexel( gl_FragColor );"
  , Du = `
const mat3 LINEAR_SRGB_TO_LINEAR_DISPLAY_P3 = mat3(
	vec3( 0.8224621, 0.177538, 0.0 ),
	vec3( 0.0331941, 0.9668058, 0.0 ),
	vec3( 0.0170827, 0.0723974, 0.9105199 )
);
const mat3 LINEAR_DISPLAY_P3_TO_LINEAR_SRGB = mat3(
	vec3( 1.2249401, - 0.2249404, 0.0 ),
	vec3( - 0.0420569, 1.0420571, 0.0 ),
	vec3( - 0.0196376, - 0.0786361, 1.0982735 )
);
vec4 LinearSRGBToLinearDisplayP3( in vec4 value ) {
	return vec4( value.rgb * LINEAR_SRGB_TO_LINEAR_DISPLAY_P3, value.a );
}
vec4 LinearDisplayP3ToLinearSRGB( in vec4 value ) {
	return vec4( value.rgb * LINEAR_DISPLAY_P3_TO_LINEAR_SRGB, value.a );
}
vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`
  , Lu = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`
  , Iu = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`
  , Uu = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`
  , Nu = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`
  , Fu = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`
  , Ou = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`
  , Bu = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`
  , zu = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`
  , ku = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`
  , Hu = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`
  , Gu = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`
  , Vu = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`
  , Wu = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`
  , Xu = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`
  , qu = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`
  , Yu = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`
  , ju = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`
  , Ku = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`
  , $u = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`
  , Zu = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`
  , Ju = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`
  , Qu = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`
  , ef = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`
  , tf = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`
  , nf = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`
  , sf = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , rf = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`
  , of = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`
  , af = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = vec4( mix( pow( sampledDiffuseColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), sampledDiffuseColor.rgb * 0.0773993808, vec3( lessThanEqual( sampledDiffuseColor.rgb, vec3( 0.04045 ) ) ) ), sampledDiffuseColor.w );
	
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`
  , lf = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`
  , cf = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`
  , hf = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`
  , df = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`
  , uf = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`
  , ff = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`
  , pf = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`
  , mf = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , gf = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`
  , Mf = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`
  , _f = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`
  , vf = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`
  , xf = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , yf = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`
  , Sf = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`
  , bf = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`
  , Ef = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`
  , Tf = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`
  , wf = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`
  , Af = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`
  , Rf = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`
  , Cf = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`
  , Pf = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`
  , Df = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`
  , Lf = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`
  , If = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`
  , Uf = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`
  , Nf = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`
  , Ff = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`
  , Of = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`
  , Bf = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`
  , zf = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`
  , kf = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`
  , Hf = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`
  , Gf = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`
  , Vf = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`
  , Wf = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`
  , Xf = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`
  , qf = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`
  , Yf = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`
  , jf = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`
  , Kf = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`
  , $f = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Zf = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`
  , Jf = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`
  , Qf = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const ep = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`
  , tp = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , np = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , ip = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , sp = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`
  , rp = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , op = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`
  , ap = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`
  , lp = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`
  , cp = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`
  , hp = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`
  , dp = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`
  , up = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , fp = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , pp = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`
  , mp = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , gp = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Mp = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , _p = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`
  , vp = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , xp = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`
  , yp = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`
  , Sp = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , bp = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Ep = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`
  , Tp = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , wp = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Ap = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`
  , Rp = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`
  , Cp = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`
  , Pp = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`
  , Dp = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , Lp = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
	vec2 scale;
	scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
	scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`
  , Ip = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`
  , ke = {
    alphahash_fragment: eu,
    alphahash_pars_fragment: tu,
    alphamap_fragment: nu,
    alphamap_pars_fragment: iu,
    alphatest_fragment: su,
    alphatest_pars_fragment: ru,
    aomap_fragment: ou,
    aomap_pars_fragment: au,
    batching_pars_vertex: lu,
    batching_vertex: cu,
    begin_vertex: hu,
    beginnormal_vertex: du,
    bsdfs: uu,
    iridescence_fragment: fu,
    bumpmap_pars_fragment: pu,
    clipping_planes_fragment: mu,
    clipping_planes_pars_fragment: gu,
    clipping_planes_pars_vertex: Mu,
    clipping_planes_vertex: _u,
    color_fragment: vu,
    color_pars_fragment: xu,
    color_pars_vertex: yu,
    color_vertex: Su,
    common: bu,
    cube_uv_reflection_fragment: Eu,
    defaultnormal_vertex: Tu,
    displacementmap_pars_vertex: wu,
    displacementmap_vertex: Au,
    emissivemap_fragment: Ru,
    emissivemap_pars_fragment: Cu,
    colorspace_fragment: Pu,
    colorspace_pars_fragment: Du,
    envmap_fragment: Lu,
    envmap_common_pars_fragment: Iu,
    envmap_pars_fragment: Uu,
    envmap_pars_vertex: Nu,
    envmap_physical_pars_fragment: qu,
    envmap_vertex: Fu,
    fog_vertex: Ou,
    fog_pars_vertex: Bu,
    fog_fragment: zu,
    fog_pars_fragment: ku,
    gradientmap_pars_fragment: Hu,
    lightmap_pars_fragment: Gu,
    lights_lambert_fragment: Vu,
    lights_lambert_pars_fragment: Wu,
    lights_pars_begin: Xu,
    lights_toon_fragment: Yu,
    lights_toon_pars_fragment: ju,
    lights_phong_fragment: Ku,
    lights_phong_pars_fragment: $u,
    lights_physical_fragment: Zu,
    lights_physical_pars_fragment: Ju,
    lights_fragment_begin: Qu,
    lights_fragment_maps: ef,
    lights_fragment_end: tf,
    logdepthbuf_fragment: nf,
    logdepthbuf_pars_fragment: sf,
    logdepthbuf_pars_vertex: rf,
    logdepthbuf_vertex: of,
    map_fragment: af,
    map_pars_fragment: lf,
    map_particle_fragment: cf,
    map_particle_pars_fragment: hf,
    metalnessmap_fragment: df,
    metalnessmap_pars_fragment: uf,
    morphinstance_vertex: ff,
    morphcolor_vertex: pf,
    morphnormal_vertex: mf,
    morphtarget_pars_vertex: gf,
    morphtarget_vertex: Mf,
    normal_fragment_begin: _f,
    normal_fragment_maps: vf,
    normal_pars_fragment: xf,
    normal_pars_vertex: yf,
    normal_vertex: Sf,
    normalmap_pars_fragment: bf,
    clearcoat_normal_fragment_begin: Ef,
    clearcoat_normal_fragment_maps: Tf,
    clearcoat_pars_fragment: wf,
    iridescence_pars_fragment: Af,
    opaque_fragment: Rf,
    packing: Cf,
    premultiplied_alpha_fragment: Pf,
    project_vertex: Df,
    dithering_fragment: Lf,
    dithering_pars_fragment: If,
    roughnessmap_fragment: Uf,
    roughnessmap_pars_fragment: Nf,
    shadowmap_pars_fragment: Ff,
    shadowmap_pars_vertex: Of,
    shadowmap_vertex: Bf,
    shadowmask_pars_fragment: zf,
    skinbase_vertex: kf,
    skinning_pars_vertex: Hf,
    skinning_vertex: Gf,
    skinnormal_vertex: Vf,
    specularmap_fragment: Wf,
    specularmap_pars_fragment: Xf,
    tonemapping_fragment: qf,
    tonemapping_pars_fragment: Yf,
    transmission_fragment: jf,
    transmission_pars_fragment: Kf,
    uv_pars_fragment: $f,
    uv_pars_vertex: Zf,
    uv_vertex: Jf,
    worldpos_vertex: Qf,
    background_vert: ep,
    background_frag: tp,
    backgroundCube_vert: np,
    backgroundCube_frag: ip,
    cube_vert: sp,
    cube_frag: rp,
    depth_vert: op,
    depth_frag: ap,
    distanceRGBA_vert: lp,
    distanceRGBA_frag: cp,
    equirect_vert: hp,
    equirect_frag: dp,
    linedashed_vert: up,
    linedashed_frag: fp,
    meshbasic_vert: pp,
    meshbasic_frag: mp,
    meshlambert_vert: gp,
    meshlambert_frag: Mp,
    meshmatcap_vert: _p,
    meshmatcap_frag: vp,
    meshnormal_vert: xp,
    meshnormal_frag: yp,
    meshphong_vert: Sp,
    meshphong_frag: bp,
    meshphysical_vert: Ep,
    meshphysical_frag: Tp,
    meshtoon_vert: wp,
    meshtoon_frag: Ap,
    points_vert: Rp,
    points_frag: Cp,
    shadow_vert: Pp,
    shadow_frag: Dp,
    sprite_vert: Lp,
    sprite_frag: Ip
}
  , he = {
    common: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new He
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new He
        },
        alphaTest: {
            value: 0
        }
    },
    specularmap: {
        specularMap: {
            value: null
        },
        specularMapTransform: {
            value: new He
        }
    },
    envmap: {
        envMap: {
            value: null
        },
        envMapRotation: {
            value: new He
        },
        flipEnvMap: {
            value: -1
        },
        reflectivity: {
            value: 1
        },
        ior: {
            value: 1.5
        },
        refractionRatio: {
            value: .98
        }
    },
    aomap: {
        aoMap: {
            value: null
        },
        aoMapIntensity: {
            value: 1
        },
        aoMapTransform: {
            value: new He
        }
    },
    lightmap: {
        lightMap: {
            value: null
        },
        lightMapIntensity: {
            value: 1
        },
        lightMapTransform: {
            value: new He
        }
    },
    bumpmap: {
        bumpMap: {
            value: null
        },
        bumpMapTransform: {
            value: new He
        },
        bumpScale: {
            value: 1
        }
    },
    normalmap: {
        normalMap: {
            value: null
        },
        normalMapTransform: {
            value: new He
        },
        normalScale: {
            value: new ee(1,1)
        }
    },
    displacementmap: {
        displacementMap: {
            value: null
        },
        displacementMapTransform: {
            value: new He
        },
        displacementScale: {
            value: 1
        },
        displacementBias: {
            value: 0
        }
    },
    emissivemap: {
        emissiveMap: {
            value: null
        },
        emissiveMapTransform: {
            value: new He
        }
    },
    metalnessmap: {
        metalnessMap: {
            value: null
        },
        metalnessMapTransform: {
            value: new He
        }
    },
    roughnessmap: {
        roughnessMap: {
            value: null
        },
        roughnessMapTransform: {
            value: new He
        }
    },
    gradientmap: {
        gradientMap: {
            value: null
        }
    },
    fog: {
        fogDensity: {
            value: 25e-5
        },
        fogNear: {
            value: 1
        },
        fogFar: {
            value: 2e3
        },
        fogColor: {
            value: new be(16777215)
        }
    },
    lights: {
        ambientLightColor: {
            value: []
        },
        lightProbe: {
            value: []
        },
        directionalLights: {
            value: [],
            properties: {
                direction: {},
                color: {}
            }
        },
        directionalLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        directionalShadowMap: {
            value: []
        },
        directionalShadowMatrix: {
            value: []
        },
        spotLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                direction: {},
                distance: {},
                coneCos: {},
                penumbraCos: {},
                decay: {}
            }
        },
        spotLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {}
            }
        },
        spotLightMap: {
            value: []
        },
        spotShadowMap: {
            value: []
        },
        spotLightMatrix: {
            value: []
        },
        pointLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                decay: {},
                distance: {}
            }
        },
        pointLightShadows: {
            value: [],
            properties: {
                shadowIntensity: 1,
                shadowBias: {},
                shadowNormalBias: {},
                shadowRadius: {},
                shadowMapSize: {},
                shadowCameraNear: {},
                shadowCameraFar: {}
            }
        },
        pointShadowMap: {
            value: []
        },
        pointShadowMatrix: {
            value: []
        },
        hemisphereLights: {
            value: [],
            properties: {
                direction: {},
                skyColor: {},
                groundColor: {}
            }
        },
        rectAreaLights: {
            value: [],
            properties: {
                color: {},
                position: {},
                width: {},
                height: {}
            }
        },
        ltc_1: {
            value: null
        },
        ltc_2: {
            value: null
        }
    },
    points: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        size: {
            value: 1
        },
        scale: {
            value: 1
        },
        map: {
            value: null
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new He
        },
        alphaTest: {
            value: 0
        },
        uvTransform: {
            value: new He
        }
    },
    sprite: {
        diffuse: {
            value: new be(16777215)
        },
        opacity: {
            value: 1
        },
        center: {
            value: new ee(.5,.5)
        },
        rotation: {
            value: 0
        },
        map: {
            value: null
        },
        mapTransform: {
            value: new He
        },
        alphaMap: {
            value: null
        },
        alphaMapTransform: {
            value: new He
        },
        alphaTest: {
            value: 0
        }
    }
}
  , tn = {
    basic: {
        uniforms: Rt([he.common, he.specularmap, he.envmap, he.aomap, he.lightmap, he.fog]),
        vertexShader: ke.meshbasic_vert,
        fragmentShader: ke.meshbasic_frag
    },
    lambert: {
        uniforms: Rt([he.common, he.specularmap, he.envmap, he.aomap, he.lightmap, he.emissivemap, he.bumpmap, he.normalmap, he.displacementmap, he.fog, he.lights, {
            emissive: {
                value: new be(0)
            }
        }]),
        vertexShader: ke.meshlambert_vert,
        fragmentShader: ke.meshlambert_frag
    },
    phong: {
        uniforms: Rt([he.common, he.specularmap, he.envmap, he.aomap, he.lightmap, he.emissivemap, he.bumpmap, he.normalmap, he.displacementmap, he.fog, he.lights, {
            emissive: {
                value: new be(0)
            },
            specular: {
                value: new be(1118481)
            },
            shininess: {
                value: 30
            }
        }]),
        vertexShader: ke.meshphong_vert,
        fragmentShader: ke.meshphong_frag
    },
    standard: {
        uniforms: Rt([he.common, he.envmap, he.aomap, he.lightmap, he.emissivemap, he.bumpmap, he.normalmap, he.displacementmap, he.roughnessmap, he.metalnessmap, he.fog, he.lights, {
            emissive: {
                value: new be(0)
            },
            roughness: {
                value: 1
            },
            metalness: {
                value: 0
            },
            envMapIntensity: {
                value: 1
            }
        }]),
        vertexShader: ke.meshphysical_vert,
        fragmentShader: ke.meshphysical_frag
    },
    toon: {
        uniforms: Rt([he.common, he.aomap, he.lightmap, he.emissivemap, he.bumpmap, he.normalmap, he.displacementmap, he.gradientmap, he.fog, he.lights, {
            emissive: {
                value: new be(0)
            }
        }]),
        vertexShader: ke.meshtoon_vert,
        fragmentShader: ke.meshtoon_frag
    },
    matcap: {
        uniforms: Rt([he.common, he.bumpmap, he.normalmap, he.displacementmap, he.fog, {
            matcap: {
                value: null
            }
        }]),
        vertexShader: ke.meshmatcap_vert,
        fragmentShader: ke.meshmatcap_frag
    },
    points: {
        uniforms: Rt([he.points, he.fog]),
        vertexShader: ke.points_vert,
        fragmentShader: ke.points_frag
    },
    dashed: {
        uniforms: Rt([he.common, he.fog, {
            scale: {
                value: 1
            },
            dashSize: {
                value: 1
            },
            totalSize: {
                value: 2
            }
        }]),
        vertexShader: ke.linedashed_vert,
        fragmentShader: ke.linedashed_frag
    },
    depth: {
        uniforms: Rt([he.common, he.displacementmap]),
        vertexShader: ke.depth_vert,
        fragmentShader: ke.depth_frag
    },
    normal: {
        uniforms: Rt([he.common, he.bumpmap, he.normalmap, he.displacementmap, {
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ke.meshnormal_vert,
        fragmentShader: ke.meshnormal_frag
    },
    sprite: {
        uniforms: Rt([he.sprite, he.fog]),
        vertexShader: ke.sprite_vert,
        fragmentShader: ke.sprite_frag
    },
    background: {
        uniforms: {
            uvTransform: {
                value: new He
            },
            t2D: {
                value: null
            },
            backgroundIntensity: {
                value: 1
            }
        },
        vertexShader: ke.background_vert,
        fragmentShader: ke.background_frag
    },
    backgroundCube: {
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            },
            backgroundBlurriness: {
                value: 0
            },
            backgroundIntensity: {
                value: 1
            },
            backgroundRotation: {
                value: new He
            }
        },
        vertexShader: ke.backgroundCube_vert,
        fragmentShader: ke.backgroundCube_frag
    },
    cube: {
        uniforms: {
            tCube: {
                value: null
            },
            tFlip: {
                value: -1
            },
            opacity: {
                value: 1
            }
        },
        vertexShader: ke.cube_vert,
        fragmentShader: ke.cube_frag
    },
    equirect: {
        uniforms: {
            tEquirect: {
                value: null
            }
        },
        vertexShader: ke.equirect_vert,
        fragmentShader: ke.equirect_frag
    },
    distanceRGBA: {
        uniforms: Rt([he.common, he.displacementmap, {
            referencePosition: {
                value: new C
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }]),
        vertexShader: ke.distanceRGBA_vert,
        fragmentShader: ke.distanceRGBA_frag
    },
    shadow: {
        uniforms: Rt([he.lights, he.fog, {
            color: {
                value: new be(0)
            },
            opacity: {
                value: 1
            }
        }]),
        vertexShader: ke.shadow_vert,
        fragmentShader: ke.shadow_frag
    }
};
tn.physical = {
    uniforms: Rt([tn.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new He
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new He
        },
        clearcoatNormalScale: {
            value: new ee(1,1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new He
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new He
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new He
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new be(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new He
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new He
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new He
        },
        transmissionSamplerSize: {
            value: new ee
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new He
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new be(0)
        },
        specularColor: {
            value: new be(1,1,1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new He
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new He
        },
        anisotropyVector: {
            value: new ee
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new He
        }
    }]),
    vertexShader: ke.meshphysical_vert,
    fragmentShader: ke.meshphysical_frag
};
const Vs = {
    r: 0,
    b: 0,
    g: 0
}
  , $n = new cn
  , Up = new Oe;
function Np(s, e, t, n, i, r, o) {
    const a = new be(0);
    let l = r === !0 ? 0 : 1, c, h, d = null, u = 0, f = null;
    function g(E) {
        let _ = E.isScene === !0 ? E.background : null;
        return _ && _.isTexture && (_ = (E.backgroundBlurriness > 0 ? t : e).get(_)),
        _
    }
    function M(E) {
        let _ = !1;
        const v = g(E);
        v === null ? p(a, l) : v && v.isColor && (p(v, 1),
        _ = !0);
        const L = s.xr.getEnvironmentBlendMode();
        L === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : L === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o),
        (s.autoClear || _) && (n.buffers.depth.setTest(!0),
        n.buffers.depth.setMask(!0),
        n.buffers.color.setMask(!0),
        s.clear(s.autoClearColor, s.autoClearDepth, s.autoClearStencil))
    }
    function m(E, _) {
        const v = g(_);
        v && (v.isCubeTexture || v.mapping === vr) ? (h === void 0 && (h = new ct(new xs(1,1,1),new hn({
            name: "BackgroundCubeMaterial",
            uniforms: ki(tn.backgroundCube.uniforms),
            vertexShader: tn.backgroundCube.vertexShader,
            fragmentShader: tn.backgroundCube.fragmentShader,
            side: It,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        h.geometry.deleteAttribute("normal"),
        h.geometry.deleteAttribute("uv"),
        h.onBeforeRender = function(L, P, A) {
            this.matrixWorld.copyPosition(A.matrixWorld)
        }
        ,
        Object.defineProperty(h.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }),
        i.update(h)),
        $n.copy(_.backgroundRotation),
        $n.x *= -1,
        $n.y *= -1,
        $n.z *= -1,
        v.isCubeTexture && v.isRenderTargetTexture === !1 && ($n.y *= -1,
        $n.z *= -1),
        h.material.uniforms.envMap.value = v,
        h.material.uniforms.flipEnvMap.value = v.isCubeTexture && v.isRenderTargetTexture === !1 ? -1 : 1,
        h.material.uniforms.backgroundBlurriness.value = _.backgroundBlurriness,
        h.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        h.material.uniforms.backgroundRotation.value.setFromMatrix4(Up.makeRotationFromEuler($n)),
        h.material.toneMapped = je.getTransfer(v.colorSpace) !== st,
        (d !== v || u !== v.version || f !== s.toneMapping) && (h.material.needsUpdate = !0,
        d = v,
        u = v.version,
        f = s.toneMapping),
        h.layers.enableAll(),
        E.unshift(h, h.geometry, h.material, 0, 0, null)) : v && v.isTexture && (c === void 0 && (c = new ct(new an(2,2),new hn({
            name: "BackgroundMaterial",
            uniforms: ki(tn.background.uniforms),
            vertexShader: tn.background.vertexShader,
            fragmentShader: tn.background.fragmentShader,
            side: Jt,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })),
        c.geometry.deleteAttribute("normal"),
        Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }),
        i.update(c)),
        c.material.uniforms.t2D.value = v,
        c.material.uniforms.backgroundIntensity.value = _.backgroundIntensity,
        c.material.toneMapped = je.getTransfer(v.colorSpace) !== st,
        v.matrixAutoUpdate === !0 && v.updateMatrix(),
        c.material.uniforms.uvTransform.value.copy(v.matrix),
        (d !== v || u !== v.version || f !== s.toneMapping) && (c.material.needsUpdate = !0,
        d = v,
        u = v.version,
        f = s.toneMapping),
        c.layers.enableAll(),
        E.unshift(c, c.geometry, c.material, 0, 0, null))
    }
    function p(E, _) {
        E.getRGB(Vs, Xc(s)),
        n.buffers.color.setClear(Vs.r, Vs.g, Vs.b, _, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(E, _=1) {
            a.set(E),
            l = _,
            p(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(E) {
            l = E,
            p(a, l)
        },
        render: M,
        addToRenderList: m
    }
}
function Fp(s, e) {
    const t = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , n = {}
      , i = u(null);
    let r = i
      , o = !1;
    function a(y, D, G, F, O) {
        let V = !1;
        const B = d(F, G, D);
        r !== B && (r = B,
        c(r.object)),
        V = f(y, F, G, O),
        V && g(y, F, G, O),
        O !== null && e.update(O, s.ELEMENT_ARRAY_BUFFER),
        (V || o) && (o = !1,
        v(y, D, G, F),
        O !== null && s.bindBuffer(s.ELEMENT_ARRAY_BUFFER, e.get(O).buffer))
    }
    function l() {
        return s.createVertexArray()
    }
    function c(y) {
        return s.bindVertexArray(y)
    }
    function h(y) {
        return s.deleteVertexArray(y)
    }
    function d(y, D, G) {
        const F = G.wireframe === !0;
        let O = n[y.id];
        O === void 0 && (O = {},
        n[y.id] = O);
        let V = O[D.id];
        V === void 0 && (V = {},
        O[D.id] = V);
        let B = V[F];
        return B === void 0 && (B = u(l()),
        V[F] = B),
        B
    }
    function u(y) {
        const D = []
          , G = []
          , F = [];
        for (let O = 0; O < t; O++)
            D[O] = 0,
            G[O] = 0,
            F[O] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: D,
            enabledAttributes: G,
            attributeDivisors: F,
            object: y,
            attributes: {},
            index: null
        }
    }
    function f(y, D, G, F) {
        const O = r.attributes
          , V = D.attributes;
        let B = 0;
        const q = G.getAttributes();
        for (const W in q)
            if (q[W].location >= 0) {
                const le = O[W];
                let me = V[W];
                if (me === void 0 && (W === "instanceMatrix" && y.instanceMatrix && (me = y.instanceMatrix),
                W === "instanceColor" && y.instanceColor && (me = y.instanceColor)),
                le === void 0 || le.attribute !== me || me && le.data !== me.data)
                    return !0;
                B++
            }
        return r.attributesNum !== B || r.index !== F
    }
    function g(y, D, G, F) {
        const O = {}
          , V = D.attributes;
        let B = 0;
        const q = G.getAttributes();
        for (const W in q)
            if (q[W].location >= 0) {
                let le = V[W];
                le === void 0 && (W === "instanceMatrix" && y.instanceMatrix && (le = y.instanceMatrix),
                W === "instanceColor" && y.instanceColor && (le = y.instanceColor));
                const me = {};
                me.attribute = le,
                le && le.data && (me.data = le.data),
                O[W] = me,
                B++
            }
        r.attributes = O,
        r.attributesNum = B,
        r.index = F
    }
    function M() {
        const y = r.newAttributes;
        for (let D = 0, G = y.length; D < G; D++)
            y[D] = 0
    }
    function m(y) {
        p(y, 0)
    }
    function p(y, D) {
        const G = r.newAttributes
          , F = r.enabledAttributes
          , O = r.attributeDivisors;
        G[y] = 1,
        F[y] === 0 && (s.enableVertexAttribArray(y),
        F[y] = 1),
        O[y] !== D && (s.vertexAttribDivisor(y, D),
        O[y] = D)
    }
    function E() {
        const y = r.newAttributes
          , D = r.enabledAttributes;
        for (let G = 0, F = D.length; G < F; G++)
            D[G] !== y[G] && (s.disableVertexAttribArray(G),
            D[G] = 0)
    }
    function _(y, D, G, F, O, V, B) {
        B === !0 ? s.vertexAttribIPointer(y, D, G, O, V) : s.vertexAttribPointer(y, D, G, F, O, V)
    }
    function v(y, D, G, F) {
        M();
        const O = F.attributes
          , V = G.getAttributes()
          , B = D.defaultAttributeValues;
        for (const q in V) {
            const W = V[q];
            if (W.location >= 0) {
                let ae = O[q];
                if (ae === void 0 && (q === "instanceMatrix" && y.instanceMatrix && (ae = y.instanceMatrix),
                q === "instanceColor" && y.instanceColor && (ae = y.instanceColor)),
                ae !== void 0) {
                    const le = ae.normalized
                      , me = ae.itemSize
                      , Ce = e.get(ae);
                    if (Ce === void 0)
                        continue;
                    const ze = Ce.buffer
                      , X = Ce.type
                      , te = Ce.bytesPerElement
                      , ve = X === s.INT || X === s.UNSIGNED_INT || ae.gpuType === sa;
                    if (ae.isInterleavedBufferAttribute) {
                        const de = ae.data
                          , Ae = de.stride
                          , Ne = ae.offset;
                        if (de.isInstancedInterleavedBuffer) {
                            for (let Le = 0; Le < W.locationSize; Le++)
                                p(W.location + Le, de.meshPerAttribute);
                            y.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = de.meshPerAttribute * de.count)
                        } else
                            for (let Le = 0; Le < W.locationSize; Le++)
                                m(W.location + Le);
                        s.bindBuffer(s.ARRAY_BUFFER, ze);
                        for (let Le = 0; Le < W.locationSize; Le++)
                            _(W.location + Le, me / W.locationSize, X, le, Ae * te, (Ne + me / W.locationSize * Le) * te, ve)
                    } else {
                        if (ae.isInstancedBufferAttribute) {
                            for (let de = 0; de < W.locationSize; de++)
                                p(W.location + de, ae.meshPerAttribute);
                            y.isInstancedMesh !== !0 && F._maxInstanceCount === void 0 && (F._maxInstanceCount = ae.meshPerAttribute * ae.count)
                        } else
                            for (let de = 0; de < W.locationSize; de++)
                                m(W.location + de);
                        s.bindBuffer(s.ARRAY_BUFFER, ze);
                        for (let de = 0; de < W.locationSize; de++)
                            _(W.location + de, me / W.locationSize, X, le, me * te, me / W.locationSize * de * te, ve)
                    }
                } else if (B !== void 0) {
                    const le = B[q];
                    if (le !== void 0)
                        switch (le.length) {
                        case 2:
                            s.vertexAttrib2fv(W.location, le);
                            break;
                        case 3:
                            s.vertexAttrib3fv(W.location, le);
                            break;
                        case 4:
                            s.vertexAttrib4fv(W.location, le);
                            break;
                        default:
                            s.vertexAttrib1fv(W.location, le)
                        }
                }
            }
        }
        E()
    }
    function L() {
        w();
        for (const y in n) {
            const D = n[y];
            for (const G in D) {
                const F = D[G];
                for (const O in F)
                    h(F[O].object),
                    delete F[O];
                delete D[G]
            }
            delete n[y]
        }
    }
    function P(y) {
        if (n[y.id] === void 0)
            return;
        const D = n[y.id];
        for (const G in D) {
            const F = D[G];
            for (const O in F)
                h(F[O].object),
                delete F[O];
            delete D[G]
        }
        delete n[y.id]
    }
    function A(y) {
        for (const D in n) {
            const G = n[D];
            if (G[y.id] === void 0)
                continue;
            const F = G[y.id];
            for (const O in F)
                h(F[O].object),
                delete F[O];
            delete G[y.id]
        }
    }
    function w() {
        S(),
        o = !0,
        r !== i && (r = i,
        c(r.object))
    }
    function S() {
        i.geometry = null,
        i.program = null,
        i.wireframe = !1
    }
    return {
        setup: a,
        reset: w,
        resetDefaultState: S,
        dispose: L,
        releaseStatesOfGeometry: P,
        releaseStatesOfProgram: A,
        initAttributes: M,
        enableAttribute: m,
        disableUnusedAttributes: E
    }
}
function Op(s, e, t) {
    let n;
    function i(c) {
        n = c
    }
    function r(c, h) {
        s.drawArrays(n, c, h),
        t.update(h, n, 1)
    }
    function o(c, h, d) {
        d !== 0 && (s.drawArraysInstanced(n, c, h, d),
        t.update(h, n, d))
    }
    function a(c, h, d) {
        if (d === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, h, 0, d);
        let f = 0;
        for (let g = 0; g < d; g++)
            f += h[g];
        t.update(f, n, 1)
    }
    function l(c, h, d, u) {
        if (d === 0)
            return;
        const f = e.get("WEBGL_multi_draw");
        if (f === null)
            for (let g = 0; g < c.length; g++)
                o(c[g], h[g], u[g]);
        else {
            f.multiDrawArraysInstancedWEBGL(n, c, 0, h, 0, u, 0, d);
            let g = 0;
            for (let M = 0; M < d; M++)
                g += h[M];
            for (let M = 0; M < u.length; M++)
                t.update(g, n, u[M])
        }
    }
    this.setMode = i,
    this.render = r,
    this.renderInstances = o,
    this.renderMultiDraw = a,
    this.renderMultiDrawInstances = l
}
function Bp(s, e, t, n) {
    let i;
    function r() {
        if (i !== void 0)
            return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const P = e.get("EXT_texture_filter_anisotropic");
            i = s.getParameter(P.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else
            i = 0;
        return i
    }
    function o(P) {
        return !(P !== Gt && n.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_FORMAT))
    }
    function a(P) {
        const A = P === on && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(P !== Cn && n.convert(P) !== s.getParameter(s.IMPLEMENTATION_COLOR_READ_TYPE) && P !== Pt && !A)
    }
    function l(P) {
        if (P === "highp") {
            if (s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.HIGH_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.HIGH_FLOAT).precision > 0)
                return "highp";
            P = "mediump"
        }
        return P === "mediump" && s.getShaderPrecisionFormat(s.VERTEX_SHADER, s.MEDIUM_FLOAT).precision > 0 && s.getShaderPrecisionFormat(s.FRAGMENT_SHADER, s.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const h = l(c);
    h !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", h, "instead."),
    c = h);
    const d = t.logarithmicDepthBuffer === !0
      , u = s.getParameter(s.MAX_TEXTURE_IMAGE_UNITS)
      , f = s.getParameter(s.MAX_VERTEX_TEXTURE_IMAGE_UNITS)
      , g = s.getParameter(s.MAX_TEXTURE_SIZE)
      , M = s.getParameter(s.MAX_CUBE_MAP_TEXTURE_SIZE)
      , m = s.getParameter(s.MAX_VERTEX_ATTRIBS)
      , p = s.getParameter(s.MAX_VERTEX_UNIFORM_VECTORS)
      , E = s.getParameter(s.MAX_VARYING_VECTORS)
      , _ = s.getParameter(s.MAX_FRAGMENT_UNIFORM_VECTORS)
      , v = f > 0
      , L = s.getParameter(s.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: r,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: d,
        maxTextures: u,
        maxVertexTextures: f,
        maxTextureSize: g,
        maxCubemapSize: M,
        maxAttributes: m,
        maxVertexUniforms: p,
        maxVaryings: E,
        maxFragmentUniforms: _,
        vertexTextures: v,
        maxSamples: L
    }
}
function zp(s) {
    const e = this;
    let t = null
      , n = 0
      , i = !1
      , r = !1;
    const o = new We
      , a = new He
      , l = {
        value: null,
        needsUpdate: !1
    };
    this.uniform = l,
    this.numPlanes = 0,
    this.numIntersection = 0,
    this.init = function(d, u) {
        const f = d.length !== 0 || u || n !== 0 || i;
        return i = u,
        n = d.length,
        f
    }
    ,
    this.beginShadows = function() {
        r = !0,
        h(null)
    }
    ,
    this.endShadows = function() {
        r = !1
    }
    ,
    this.setGlobalState = function(d, u) {
        t = h(d, u, 0)
    }
    ,
    this.setState = function(d, u, f) {
        const g = d.clippingPlanes
          , M = d.clipIntersection
          , m = d.clipShadows
          , p = s.get(d);
        if (!i || g === null || g.length === 0 || r && !m)
            r ? h(null) : c();
        else {
            const E = r ? 0 : n
              , _ = E * 4;
            let v = p.clippingState || null;
            l.value = v,
            v = h(g, u, _, f);
            for (let L = 0; L !== _; ++L)
                v[L] = t[L];
            p.clippingState = v,
            this.numIntersection = M ? this.numPlanes : 0,
            this.numPlanes += E
        }
    }
    ;
    function c() {
        l.value !== t && (l.value = t,
        l.needsUpdate = n > 0),
        e.numPlanes = n,
        e.numIntersection = 0
    }
    function h(d, u, f, g) {
        const M = d !== null ? d.length : 0;
        let m = null;
        if (M !== 0) {
            if (m = l.value,
            g !== !0 || m === null) {
                const p = f + M * 4
                  , E = u.matrixWorldInverse;
                a.getNormalMatrix(E),
                (m === null || m.length < p) && (m = new Float32Array(p));
                for (let _ = 0, v = f; _ !== M; ++_,
                v += 4)
                    o.copy(d[_]).applyMatrix4(E, a),
                    o.normal.toArray(m, v),
                    m[v + 3] = o.constant
            }
            l.value = m,
            l.needsUpdate = !0
        }
        return e.numPlanes = M,
        e.numIntersection = 0,
        m
    }
}
function kp(s) {
    let e = new WeakMap;
    function t(o, a) {
        return a === _o ? o.mapping = Ui : a === vo && (o.mapping = Ni),
        o
    }
    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === _o || a === vo)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new $d(l.height);
                        return c.fromEquirectangularTexture(s, o),
                        e.set(o, c),
                        o.addEventListener("dispose", i),
                        t(c.texture, o.mapping)
                    } else
                        return null
                }
        }
        return o
    }
    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a),
        l.dispose())
    }
    function r() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: r
    }
}
class ma extends Yc {
    constructor(e=-1, t=1, n=1, i=-1, r=.1, o=2e3) {
        super(),
        this.isOrthographicCamera = !0,
        this.type = "OrthographicCamera",
        this.zoom = 1,
        this.view = null,
        this.left = e,
        this.right = t,
        this.top = n,
        this.bottom = i,
        this.near = r,
        this.far = o,
        this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.left = e.left,
        this.right = e.right,
        this.top = e.top,
        this.bottom = e.bottom,
        this.near = e.near,
        this.far = e.far,
        this.zoom = e.zoom,
        this.view = e.view === null ? null : Object.assign({}, e.view),
        this
    }
    setViewOffset(e, t, n, i, r, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }),
        this.view.enabled = !0,
        this.view.fullWidth = e,
        this.view.fullHeight = t,
        this.view.offsetX = n,
        this.view.offsetY = i,
        this.view.width = r,
        this.view.height = o,
        this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1),
        this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom)
          , t = (this.top - this.bottom) / (2 * this.zoom)
          , n = (this.right + this.left) / 2
          , i = (this.top + this.bottom) / 2;
        let r = n - e
          , o = n + e
          , a = i + t
          , l = i - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom
              , h = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            r += c * this.view.offsetX,
            o = r + c * this.view.width,
            a -= h * this.view.offsetY,
            l = a - h * this.view.height
        }
        this.projectionMatrix.makeOrthographic(r, o, a, l, this.near, this.far, this.coordinateSystem),
        this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom,
        t.object.left = this.left,
        t.object.right = this.right,
        t.object.top = this.top,
        t.object.bottom = this.bottom,
        t.object.near = this.near,
        t.object.far = this.far,
        this.view !== null && (t.object.view = Object.assign({}, this.view)),
        t
    }
}
const Ti = 4
  , fl = [.125, .215, .35, .446, .526, .582]
  , ti = 20
  , $r = new ma
  , pl = new be;
let Zr = null
  , Jr = 0
  , Qr = 0
  , eo = !1;
const Qn = (1 + Math.sqrt(5)) / 2
  , Si = 1 / Qn
  , ml = [new C(-Qn,Si,0), new C(Qn,Si,0), new C(-Si,0,Qn), new C(Si,0,Qn), new C(0,Qn,-Si), new C(0,Qn,Si), new C(-1,1,-1), new C(1,1,-1), new C(-1,1,1), new C(1,1,1)];
class ms {
    constructor(e) {
        this._renderer = e,
        this._pingPongRenderTarget = null,
        this._lodMax = 0,
        this._cubeSize = 0,
        this._lodPlanes = [],
        this._sizeLods = [],
        this._sigmas = [],
        this._blurMaterial = null,
        this._cubemapMaterial = null,
        this._equirectMaterial = null,
        this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t=0, n=.1, i=100) {
        Zr = this._renderer.getRenderTarget(),
        Jr = this._renderer.getActiveCubeFace(),
        Qr = this._renderer.getActiveMipmapLevel(),
        eo = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1,
        this._setSize(256);
        const r = this._allocateTargets();
        return r.depthBuffer = !0,
        this._sceneToCubeUV(e, n, i, r),
        t > 0 && this._blur(r, 0, 0, t),
        this._applyPMREM(r),
        this._cleanup(r),
        r
    }
    fromEquirectangular(e, t=null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t=null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = _l(),
        this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = Ml(),
        this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(),
        this._cubemapMaterial !== null && this._cubemapMaterial.dispose(),
        this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)),
        this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(),
        this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++)
            this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Zr, Jr, Qr),
        this._renderer.xr.enabled = eo,
        e.scissorTest = !1,
        Ws(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === Ui || e.mapping === Ni ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4),
        Zr = this._renderer.getRenderTarget(),
        Jr = this._renderer.getActiveCubeFace(),
        Qr = this._renderer.getActiveMipmapLevel(),
        eo = this._renderer.xr.enabled,
        this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n),
        this._applyPMREM(n),
        this._cleanup(n),
        n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112)
          , t = 4 * this._cubeSize
          , n = {
            magFilter: _t,
            minFilter: _t,
            generateMipmaps: !1,
            type: on,
            format: Gt,
            colorSpace: xt,
            depthBuffer: !1
        }
          , i = gl(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(),
            this._pingPongRenderTarget = gl(e, t, n);
            const {_lodMax: r} = this;
            ({sizeLods: this._sizeLods, lodPlanes: this._lodPlanes, sigmas: this._sigmas} = Hp(r)),
            this._blurMaterial = Gp(r, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new ct(this._lodPlanes[0],e);
        this._renderer.compile(t, $r)
    }
    _sceneToCubeUV(e, t, n, i) {
        const a = new wt(90,1,t,n)
          , l = [1, -1, 1, 1, 1, 1]
          , c = [1, 1, 1, -1, -1, -1]
          , h = this._renderer
          , d = h.autoClear
          , u = h.toneMapping;
        h.getClearColor(pl),
        h.toneMapping = Rn,
        h.autoClear = !1;
        const f = new wn({
            name: "PMREM.Background",
            side: It,
            depthWrite: !1,
            depthTest: !1
        })
          , g = new ct(new xs,f);
        let M = !1;
        const m = e.background;
        m ? m.isColor && (f.color.copy(m),
        e.background = null,
        M = !0) : (f.color.copy(pl),
        M = !0);
        for (let p = 0; p < 6; p++) {
            const E = p % 3;
            E === 0 ? (a.up.set(0, l[p], 0),
            a.lookAt(c[p], 0, 0)) : E === 1 ? (a.up.set(0, 0, l[p]),
            a.lookAt(0, c[p], 0)) : (a.up.set(0, l[p], 0),
            a.lookAt(0, 0, c[p]));
            const _ = this._cubeSize;
            Ws(i, E * _, p > 2 ? _ : 0, _, _),
            h.setRenderTarget(i),
            M && h.render(g, a),
            h.render(e, a)
        }
        g.geometry.dispose(),
        g.material.dispose(),
        h.toneMapping = u,
        h.autoClear = d,
        e.background = m
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer
          , i = e.mapping === Ui || e.mapping === Ni;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = _l()),
        this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = Ml());
        const r = i ? this._cubemapMaterial : this._equirectMaterial
          , o = new ct(this._lodPlanes[0],r)
          , a = r.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Ws(t, 0, 0, 3 * l, 2 * l),
        n.setRenderTarget(t),
        n.render(o, $r)
    }
    _applyPMREM(e) {
        const t = this._renderer
          , n = t.autoClear;
        t.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let r = 1; r < i; r++) {
            const o = Math.sqrt(this._sigmas[r] * this._sigmas[r] - this._sigmas[r - 1] * this._sigmas[r - 1])
              , a = ml[(i - r - 1) % ml.length];
            this._blur(e, r - 1, r, o, a)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, r) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, i, "latitudinal", r),
        this._halfBlur(o, e, n, n, i, "longitudinal", r)
    }
    _halfBlur(e, t, n, i, r, o, a) {
        const l = this._renderer
          , c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const h = 3
          , d = new ct(this._lodPlanes[i],c)
          , u = c.uniforms
          , f = this._sizeLods[n] - 1
          , g = isFinite(r) ? Math.PI / (2 * f) : 2 * Math.PI / (2 * ti - 1)
          , M = r / g
          , m = isFinite(r) ? 1 + Math.floor(h * M) : ti;
        m > ti && console.warn(`sigmaRadians, ${r}, is too large and will clip, as it requested ${m} samples when the maximum is set to ${ti}`);
        const p = [];
        let E = 0;
        for (let A = 0; A < ti; ++A) {
            const w = A / M
              , S = Math.exp(-w * w / 2);
            p.push(S),
            A === 0 ? E += S : A < m && (E += 2 * S)
        }
        for (let A = 0; A < p.length; A++)
            p[A] = p[A] / E;
        u.envMap.value = e.texture,
        u.samples.value = m,
        u.weights.value = p,
        u.latitudinal.value = o === "latitudinal",
        a && (u.poleAxis.value = a);
        const {_lodMax: _} = this;
        u.dTheta.value = g,
        u.mipInt.value = _ - n;
        const v = this._sizeLods[i]
          , L = 3 * v * (i > _ - Ti ? i - _ + Ti : 0)
          , P = 4 * (this._cubeSize - v);
        Ws(t, L, P, 3 * v, 2 * v),
        l.setRenderTarget(t),
        l.render(d, $r)
    }
}
function Hp(s) {
    const e = []
      , t = []
      , n = [];
    let i = s;
    const r = s - Ti + 1 + fl.length;
    for (let o = 0; o < r; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let l = 1 / a;
        o > s - Ti ? l = fl[o - s + Ti - 1] : o === 0 && (l = 0),
        n.push(l);
        const c = 1 / (a - 2)
          , h = -c
          , d = 1 + c
          , u = [h, h, d, h, d, d, h, h, d, d, h, d]
          , f = 6
          , g = 6
          , M = 3
          , m = 2
          , p = 1
          , E = new Float32Array(M * g * f)
          , _ = new Float32Array(m * g * f)
          , v = new Float32Array(p * g * f);
        for (let P = 0; P < f; P++) {
            const A = P % 3 * 2 / 3 - 1
              , w = P > 2 ? 0 : -1
              , S = [A, w, 0, A + 2 / 3, w, 0, A + 2 / 3, w + 1, 0, A, w, 0, A + 2 / 3, w + 1, 0, A, w + 1, 0];
            E.set(S, M * g * P),
            _.set(u, m * g * P);
            const y = [P, P, P, P, P, P];
            v.set(y, p * g * P)
        }
        const L = new Qt;
        L.setAttribute("position", new Dt(E,M)),
        L.setAttribute("uv", new Dt(_,m)),
        L.setAttribute("faceIndex", new Dt(v,p)),
        e.push(L),
        i > Ti && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}
function gl(s, e, t) {
    const n = new Wn(s,e,t);
    return n.texture.mapping = vr,
    n.texture.name = "PMREM.cubeUv",
    n.scissorTest = !0,
    n
}
function Ws(s, e, t, n, i) {
    s.viewport.set(e, t, n, i),
    s.scissor.set(e, t, n, i)
}
function Gp(s, e, t) {
    const n = new Float32Array(ti)
      , i = new C(0,1,0);
    return new hn({
        name: "SphericalGaussianBlur",
        defines: {
            n: ti,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${s}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: ga(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: Vn,
        depthTest: !1,
        depthWrite: !1
    })
}
function Ml() {
    return new hn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: ga(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: Vn,
        depthTest: !1,
        depthWrite: !1
    })
}
function _l() {
    return new hn({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: ga(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: Vn,
        depthTest: !1,
        depthWrite: !1
    })
}
function ga() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}
function Vp(s) {
    let e = new WeakMap
      , t = null;
    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping
              , c = l === _o || l === vo
              , h = l === Ui || l === Ni;
            if (c || h) {
                let d = e.get(a);
                const u = d !== void 0 ? d.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== u)
                    return t === null && (t = new ms(s)),
                    d = c ? t.fromEquirectangular(a, d) : t.fromCubemap(a, d),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    d.texture;
                if (d !== void 0)
                    return d.texture;
                {
                    const f = a.image;
                    return c && f && f.height > 0 || h && f && i(f) ? (t === null && (t = new ms(s)),
                    d = c ? t.fromEquirectangular(a) : t.fromCubemap(a),
                    d.texture.pmremVersion = a.pmremVersion,
                    e.set(a, d),
                    a.addEventListener("dispose", r),
                    d.texture) : null
                }
            }
        }
        return a
    }
    function i(a) {
        let l = 0;
        const c = 6;
        for (let h = 0; h < c; h++)
            a[h] !== void 0 && l++;
        return l === c
    }
    function r(a) {
        const l = a.target;
        l.removeEventListener("dispose", r);
        const c = e.get(l);
        c !== void 0 && (e.delete(l),
        c.dispose())
    }
    function o() {
        e = new WeakMap,
        t !== null && (t.dispose(),
        t = null)
    }
    return {
        get: n,
        dispose: o
    }
}
function Wp(s) {
    const e = {};
    function t(n) {
        if (e[n] !== void 0)
            return e[n];
        let i;
        switch (n) {
        case "WEBGL_depth_texture":
            i = s.getExtension("WEBGL_depth_texture") || s.getExtension("MOZ_WEBGL_depth_texture") || s.getExtension("WEBKIT_WEBGL_depth_texture");
            break;
        case "EXT_texture_filter_anisotropic":
            i = s.getExtension("EXT_texture_filter_anisotropic") || s.getExtension("MOZ_EXT_texture_filter_anisotropic") || s.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
            break;
        case "WEBGL_compressed_texture_s3tc":
            i = s.getExtension("WEBGL_compressed_texture_s3tc") || s.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
            break;
        case "WEBGL_compressed_texture_pvrtc":
            i = s.getExtension("WEBGL_compressed_texture_pvrtc") || s.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
            break;
        default:
            i = s.getExtension(n)
        }
        return e[n] = i,
        i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"),
            t("WEBGL_clip_cull_distance"),
            t("OES_texture_float_linear"),
            t("EXT_color_buffer_half_float"),
            t("WEBGL_multisampled_render_to_texture"),
            t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const i = t(n);
            return i === null && Pi("THREE.WebGLRenderer: " + n + " extension not supported."),
            i
        }
    }
}
function Xp(s, e, t, n) {
    const i = {}
      , r = new WeakMap;
    function o(d) {
        const u = d.target;
        u.index !== null && e.remove(u.index);
        for (const g in u.attributes)
            e.remove(u.attributes[g]);
        for (const g in u.morphAttributes) {
            const M = u.morphAttributes[g];
            for (let m = 0, p = M.length; m < p; m++)
                e.remove(M[m])
        }
        u.removeEventListener("dispose", o),
        delete i[u.id];
        const f = r.get(u);
        f && (e.remove(f),
        r.delete(u)),
        n.releaseStatesOfGeometry(u),
        u.isInstancedBufferGeometry === !0 && delete u._maxInstanceCount,
        t.memory.geometries--
    }
    function a(d, u) {
        return i[u.id] === !0 || (u.addEventListener("dispose", o),
        i[u.id] = !0,
        t.memory.geometries++),
        u
    }
    function l(d) {
        const u = d.attributes;
        for (const g in u)
            e.update(u[g], s.ARRAY_BUFFER);
        const f = d.morphAttributes;
        for (const g in f) {
            const M = f[g];
            for (let m = 0, p = M.length; m < p; m++)
                e.update(M[m], s.ARRAY_BUFFER)
        }
    }
    function c(d) {
        const u = []
          , f = d.index
          , g = d.attributes.position;
        let M = 0;
        if (f !== null) {
            const E = f.array;
            M = f.version;
            for (let _ = 0, v = E.length; _ < v; _ += 3) {
                const L = E[_ + 0]
                  , P = E[_ + 1]
                  , A = E[_ + 2];
                u.push(L, P, P, A, A, L)
            }
        } else if (g !== void 0) {
            const E = g.array;
            M = g.version;
            for (let _ = 0, v = E.length / 3 - 1; _ < v; _ += 3) {
                const L = _ + 0
                  , P = _ + 1
                  , A = _ + 2;
                u.push(L, P, P, A, A, L)
            }
        } else
            return;
        const m = new (Bc(u) ? Wc : Vc)(u,1);
        m.version = M;
        const p = r.get(d);
        p && e.remove(p),
        r.set(d, m)
    }
    function h(d) {
        const u = r.get(d);
        if (u) {
            const f = d.index;
            f !== null && u.version < f.version && c(d)
        } else
            c(d);
        return r.get(d)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: h
    }
}
function qp(s, e, t) {
    let n;
    function i(u) {
        n = u
    }
    let r, o;
    function a(u) {
        r = u.type,
        o = u.bytesPerElement
    }
    function l(u, f) {
        s.drawElements(n, f, r, u * o),
        t.update(f, n, 1)
    }
    function c(u, f, g) {
        g !== 0 && (s.drawElementsInstanced(n, f, r, u * o, g),
        t.update(f, n, g))
    }
    function h(u, f, g) {
        if (g === 0)
            return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, f, 0, r, u, 0, g);
        let m = 0;
        for (let p = 0; p < g; p++)
            m += f[p];
        t.update(m, n, 1)
    }
    function d(u, f, g, M) {
        if (g === 0)
            return;
        const m = e.get("WEBGL_multi_draw");
        if (m === null)
            for (let p = 0; p < u.length; p++)
                c(u[p] / o, f[p], M[p]);
        else {
            m.multiDrawElementsInstancedWEBGL(n, f, 0, r, u, 0, M, 0, g);
            let p = 0;
            for (let E = 0; E < g; E++)
                p += f[E];
            for (let E = 0; E < M.length; E++)
                t.update(p, n, M[E])
        }
    }
    this.setMode = i,
    this.setIndex = a,
    this.render = l,
    this.renderInstances = c,
    this.renderMultiDraw = h,
    this.renderMultiDrawInstances = d
}
function Yp(s) {
    const e = {
        geometries: 0,
        textures: 0
    }
      , t = {
        frame: 0,
        calls: 0,
        triangles: 0,
        points: 0,
        lines: 0
    };
    function n(r, o, a) {
        switch (t.calls++,
        o) {
        case s.TRIANGLES:
            t.triangles += a * (r / 3);
            break;
        case s.LINES:
            t.lines += a * (r / 2);
            break;
        case s.LINE_STRIP:
            t.lines += a * (r - 1);
            break;
        case s.LINE_LOOP:
            t.lines += a * r;
            break;
        case s.POINTS:
            t.points += a * r;
            break;
        default:
            console.error("THREE.WebGLInfo: Unknown draw mode:", o);
            break
        }
    }
    function i() {
        t.calls = 0,
        t.triangles = 0,
        t.points = 0,
        t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}
function jp(s, e, t) {
    const n = new WeakMap
      , i = new Qe;
    function r(o, a, l) {
        const c = o.morphTargetInfluences
          , h = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color
          , d = h !== void 0 ? h.length : 0;
        let u = n.get(a);
        if (u === void 0 || u.count !== d) {
            let y = function() {
                w.dispose(),
                n.delete(a),
                a.removeEventListener("dispose", y)
            };
            var f = y;
            u !== void 0 && u.texture.dispose();
            const g = a.morphAttributes.position !== void 0
              , M = a.morphAttributes.normal !== void 0
              , m = a.morphAttributes.color !== void 0
              , p = a.morphAttributes.position || []
              , E = a.morphAttributes.normal || []
              , _ = a.morphAttributes.color || [];
            let v = 0;
            g === !0 && (v = 1),
            M === !0 && (v = 2),
            m === !0 && (v = 3);
            let L = a.attributes.position.count * v
              , P = 1;
            L > e.maxTextureSize && (P = Math.ceil(L / e.maxTextureSize),
            L = e.maxTextureSize);
            const A = new Float32Array(L * P * 4 * d)
              , w = new kc(A,L,P,d);
            w.type = Pt,
            w.needsUpdate = !0;
            const S = v * 4;
            for (let D = 0; D < d; D++) {
                const G = p[D]
                  , F = E[D]
                  , O = _[D]
                  , V = L * P * 4 * D;
                for (let B = 0; B < G.count; B++) {
                    const q = B * S;
                    g === !0 && (i.fromBufferAttribute(G, B),
                    A[V + q + 0] = i.x,
                    A[V + q + 1] = i.y,
                    A[V + q + 2] = i.z,
                    A[V + q + 3] = 0),
                    M === !0 && (i.fromBufferAttribute(F, B),
                    A[V + q + 4] = i.x,
                    A[V + q + 5] = i.y,
                    A[V + q + 6] = i.z,
                    A[V + q + 7] = 0),
                    m === !0 && (i.fromBufferAttribute(O, B),
                    A[V + q + 8] = i.x,
                    A[V + q + 9] = i.y,
                    A[V + q + 10] = i.z,
                    A[V + q + 11] = O.itemSize === 4 ? i.w : 1)
                }
            }
            u = {
                count: d,
                texture: w,
                size: new ee(L,P)
            },
            n.set(a, u),
            a.addEventListener("dispose", y)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null)
            l.getUniforms().setValue(s, "morphTexture", o.morphTexture, t);
        else {
            let g = 0;
            for (let m = 0; m < c.length; m++)
                g += c[m];
            const M = a.morphTargetsRelative ? 1 : 1 - g;
            l.getUniforms().setValue(s, "morphTargetBaseInfluence", M),
            l.getUniforms().setValue(s, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(s, "morphTargetsTexture", u.texture, t),
        l.getUniforms().setValue(s, "morphTargetsTextureSize", u.size)
    }
    return {
        update: r
    }
}
function Kp(s, e, t, n) {
    let i = new WeakMap;
    function r(l) {
        const c = n.render.frame
          , h = l.geometry
          , d = e.get(l, h);
        if (i.get(d) !== c && (e.update(d),
        i.set(d, c)),
        l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a),
        i.get(l) !== c && (t.update(l.instanceMatrix, s.ARRAY_BUFFER),
        l.instanceColor !== null && t.update(l.instanceColor, s.ARRAY_BUFFER),
        i.set(l, c))),
        l.isSkinnedMesh) {
            const u = l.skeleton;
            i.get(u) !== c && (u.update(),
            i.set(u, c))
        }
        return d
    }
    function o() {
        i = new WeakMap
    }
    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a),
        t.remove(c.instanceMatrix),
        c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: r,
        dispose: o
    }
}
class Kc extends vt {
    constructor(e, t, n, i, r, o, a, l, c, h=Ci) {
        if (h !== Ci && h !== Bi)
            throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && h === Ci && (n = ni),
        n === void 0 && h === Bi && (n = Oi),
        super(null, i, r, o, a, l, h, n, c),
        this.isDepthTexture = !0,
        this.image = {
            width: e,
            height: t
        },
        this.magFilter = a !== void 0 ? a : Ct,
        this.minFilter = l !== void 0 ? l : Ct,
        this.flipY = !1,
        this.generateMipmaps = !1,
        this.compareFunction = null
    }
    copy(e) {
        return super.copy(e),
        this.compareFunction = e.compareFunction,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction),
        t
    }
}
const $c = new vt
  , vl = new Kc(1,1)
  , Zc = new kc
  , Jc = new Ld
  , Qc = new fa
  , xl = []
  , yl = []
  , Sl = new Float32Array(16)
  , bl = new Float32Array(9)
  , El = new Float32Array(4);
function Wi(s, e, t) {
    const n = s[0];
    if (n <= 0 || n > 0)
        return s;
    const i = e * t;
    let r = xl[i];
    if (r === void 0 && (r = new Float32Array(i),
    xl[i] = r),
    e !== 0) {
        n.toArray(r, 0);
        for (let o = 1, a = 0; o !== e; ++o)
            a += t,
            s[o].toArray(r, a)
    }
    return r
}
function mt(s, e) {
    if (s.length !== e.length)
        return !1;
    for (let t = 0, n = s.length; t < n; t++)
        if (s[t] !== e[t])
            return !1;
    return !0
}
function gt(s, e) {
    for (let t = 0, n = e.length; t < n; t++)
        s[t] = e[t]
}
function yr(s, e) {
    let t = yl[e];
    t === void 0 && (t = new Int32Array(e),
    yl[e] = t);
    for (let n = 0; n !== e; ++n)
        t[n] = s.allocateTextureUnit();
    return t
}
function $p(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1f(this.addr, e),
    t[0] = e)
}
function Zp(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2f(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (mt(t, e))
            return;
        s.uniform2fv(this.addr, e),
        gt(t, e)
    }
}
function Jp(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3f(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else if (e.r !== void 0)
        (t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (s.uniform3f(this.addr, e.r, e.g, e.b),
        t[0] = e.r,
        t[1] = e.g,
        t[2] = e.b);
    else {
        if (mt(t, e))
            return;
        s.uniform3fv(this.addr, e),
        gt(t, e)
    }
}
function Qp(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4f(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (mt(t, e))
            return;
        s.uniform4fv(this.addr, e),
        gt(t, e)
    }
}
function em(s, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (mt(t, e))
            return;
        s.uniformMatrix2fv(this.addr, !1, e),
        gt(t, e)
    } else {
        if (mt(t, n))
            return;
        El.set(n),
        s.uniformMatrix2fv(this.addr, !1, El),
        gt(t, n)
    }
}
function tm(s, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (mt(t, e))
            return;
        s.uniformMatrix3fv(this.addr, !1, e),
        gt(t, e)
    } else {
        if (mt(t, n))
            return;
        bl.set(n),
        s.uniformMatrix3fv(this.addr, !1, bl),
        gt(t, n)
    }
}
function nm(s, e) {
    const t = this.cache
      , n = e.elements;
    if (n === void 0) {
        if (mt(t, e))
            return;
        s.uniformMatrix4fv(this.addr, !1, e),
        gt(t, e)
    } else {
        if (mt(t, n))
            return;
        Sl.set(n),
        s.uniformMatrix4fv(this.addr, !1, Sl),
        gt(t, n)
    }
}
function im(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1i(this.addr, e),
    t[0] = e)
}
function sm(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2i(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (mt(t, e))
            return;
        s.uniform2iv(this.addr, e),
        gt(t, e)
    }
}
function rm(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3i(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (mt(t, e))
            return;
        s.uniform3iv(this.addr, e),
        gt(t, e)
    }
}
function om(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4i(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (mt(t, e))
            return;
        s.uniform4iv(this.addr, e),
        gt(t, e)
    }
}
function am(s, e) {
    const t = this.cache;
    t[0] !== e && (s.uniform1ui(this.addr, e),
    t[0] = e)
}
function lm(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y) && (s.uniform2ui(this.addr, e.x, e.y),
        t[0] = e.x,
        t[1] = e.y);
    else {
        if (mt(t, e))
            return;
        s.uniform2uiv(this.addr, e),
        gt(t, e)
    }
}
function cm(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (s.uniform3ui(this.addr, e.x, e.y, e.z),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z);
    else {
        if (mt(t, e))
            return;
        s.uniform3uiv(this.addr, e),
        gt(t, e)
    }
}
function hm(s, e) {
    const t = this.cache;
    if (e.x !== void 0)
        (t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (s.uniform4ui(this.addr, e.x, e.y, e.z, e.w),
        t[0] = e.x,
        t[1] = e.y,
        t[2] = e.z,
        t[3] = e.w);
    else {
        if (mt(t, e))
            return;
        s.uniform4uiv(this.addr, e),
        gt(t, e)
    }
}
function dm(s, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i),
    n[0] = i);
    let r;
    this.type === s.SAMPLER_2D_SHADOW ? (vl.compareFunction = Fc,
    r = vl) : r = $c,
    t.setTexture2D(e || r, i)
}
function um(s, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture3D(e || Jc, i)
}
function fm(s, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i),
    n[0] = i),
    t.setTextureCube(e || Qc, i)
}
function pm(s, e, t) {
    const n = this.cache
      , i = t.allocateTextureUnit();
    n[0] !== i && (s.uniform1i(this.addr, i),
    n[0] = i),
    t.setTexture2DArray(e || Zc, i)
}
function mm(s) {
    switch (s) {
    case 5126:
        return $p;
    case 35664:
        return Zp;
    case 35665:
        return Jp;
    case 35666:
        return Qp;
    case 35674:
        return em;
    case 35675:
        return tm;
    case 35676:
        return nm;
    case 5124:
    case 35670:
        return im;
    case 35667:
    case 35671:
        return sm;
    case 35668:
    case 35672:
        return rm;
    case 35669:
    case 35673:
        return om;
    case 5125:
        return am;
    case 36294:
        return lm;
    case 36295:
        return cm;
    case 36296:
        return hm;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return dm;
    case 35679:
    case 36299:
    case 36307:
        return um;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return fm;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return pm
    }
}
function gm(s, e) {
    s.uniform1fv(this.addr, e)
}
function Mm(s, e) {
    const t = Wi(e, this.size, 2);
    s.uniform2fv(this.addr, t)
}
function _m(s, e) {
    const t = Wi(e, this.size, 3);
    s.uniform3fv(this.addr, t)
}
function vm(s, e) {
    const t = Wi(e, this.size, 4);
    s.uniform4fv(this.addr, t)
}
function xm(s, e) {
    const t = Wi(e, this.size, 4);
    s.uniformMatrix2fv(this.addr, !1, t)
}
function ym(s, e) {
    const t = Wi(e, this.size, 9);
    s.uniformMatrix3fv(this.addr, !1, t)
}
function Sm(s, e) {
    const t = Wi(e, this.size, 16);
    s.uniformMatrix4fv(this.addr, !1, t)
}
function bm(s, e) {
    s.uniform1iv(this.addr, e)
}
function Em(s, e) {
    s.uniform2iv(this.addr, e)
}
function Tm(s, e) {
    s.uniform3iv(this.addr, e)
}
function wm(s, e) {
    s.uniform4iv(this.addr, e)
}
function Am(s, e) {
    s.uniform1uiv(this.addr, e)
}
function Rm(s, e) {
    s.uniform2uiv(this.addr, e)
}
function Cm(s, e) {
    s.uniform3uiv(this.addr, e)
}
function Pm(s, e) {
    s.uniform4uiv(this.addr, e)
}
function Dm(s, e, t) {
    const n = this.cache
      , i = e.length
      , r = yr(t, i);
    mt(n, r) || (s.uniform1iv(this.addr, r),
    gt(n, r));
    for (let o = 0; o !== i; ++o)
        t.setTexture2D(e[o] || $c, r[o])
}
function Lm(s, e, t) {
    const n = this.cache
      , i = e.length
      , r = yr(t, i);
    mt(n, r) || (s.uniform1iv(this.addr, r),
    gt(n, r));
    for (let o = 0; o !== i; ++o)
        t.setTexture3D(e[o] || Jc, r[o])
}
function Im(s, e, t) {
    const n = this.cache
      , i = e.length
      , r = yr(t, i);
    mt(n, r) || (s.uniform1iv(this.addr, r),
    gt(n, r));
    for (let o = 0; o !== i; ++o)
        t.setTextureCube(e[o] || Qc, r[o])
}
function Um(s, e, t) {
    const n = this.cache
      , i = e.length
      , r = yr(t, i);
    mt(n, r) || (s.uniform1iv(this.addr, r),
    gt(n, r));
    for (let o = 0; o !== i; ++o)
        t.setTexture2DArray(e[o] || Zc, r[o])
}
function Nm(s) {
    switch (s) {
    case 5126:
        return gm;
    case 35664:
        return Mm;
    case 35665:
        return _m;
    case 35666:
        return vm;
    case 35674:
        return xm;
    case 35675:
        return ym;
    case 35676:
        return Sm;
    case 5124:
    case 35670:
        return bm;
    case 35667:
    case 35671:
        return Em;
    case 35668:
    case 35672:
        return Tm;
    case 35669:
    case 35673:
        return wm;
    case 5125:
        return Am;
    case 36294:
        return Rm;
    case 36295:
        return Cm;
    case 36296:
        return Pm;
    case 35678:
    case 36198:
    case 36298:
    case 36306:
    case 35682:
        return Dm;
    case 35679:
    case 36299:
    case 36307:
        return Lm;
    case 35680:
    case 36300:
    case 36308:
    case 36293:
        return Im;
    case 36289:
    case 36303:
    case 36311:
    case 36292:
        return Um
    }
}
class Fm {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.setValue = mm(t.type)
    }
}
class Om {
    constructor(e, t, n) {
        this.id = e,
        this.addr = n,
        this.cache = [],
        this.type = t.type,
        this.size = t.size,
        this.setValue = Nm(t.type)
    }
}
class Bm {
    constructor(e) {
        this.id = e,
        this.seq = [],
        this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let r = 0, o = i.length; r !== o; ++r) {
            const a = i[r];
            a.setValue(e, t[a.id], n)
        }
    }
}
const to = /(\w+)(\])?(\[|\.)?/g;
function Tl(s, e) {
    s.seq.push(e),
    s.map[e.id] = e
}
function zm(s, e, t) {
    const n = s.name
      , i = n.length;
    for (to.lastIndex = 0; ; ) {
        const r = to.exec(n)
          , o = to.lastIndex;
        let a = r[1];
        const l = r[2] === "]"
          , c = r[3];
        if (l && (a = a | 0),
        c === void 0 || c === "[" && o + 2 === i) {
            Tl(t, c === void 0 ? new Fm(a,s,e) : new Om(a,s,e));
            break
        } else {
            let d = t.map[a];
            d === void 0 && (d = new Bm(a),
            Tl(t, d)),
            t = d
        }
    }
}
class cr {
    constructor(e, t) {
        this.seq = [],
        this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const r = e.getActiveUniform(t, i)
              , o = e.getUniformLocation(t, r.name);
            zm(r, o, this)
        }
    }
    setValue(e, t, n, i) {
        const r = this.map[t];
        r !== void 0 && r.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let r = 0, o = t.length; r !== o; ++r) {
            const a = t[r]
              , l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, r = e.length; i !== r; ++i) {
            const o = e[i];
            o.id in t && n.push(o)
        }
        return n
    }
}
function wl(s, e, t) {
    const n = s.createShader(e);
    return s.shaderSource(n, t),
    s.compileShader(n),
    n
}
const km = 37297;
let Hm = 0;
function Gm(s, e) {
    const t = s.split(`
`)
      , n = []
      , i = Math.max(e - 6, 0)
      , r = Math.min(e + 6, t.length);
    for (let o = i; o < r; o++) {
        const a = o + 1;
        n.push(`${a === e ? ">" : " "} ${a}: ${t[o]}`)
    }
    return n.join(`
`)
}
function Vm(s) {
    const e = je.getPrimaries(je.workingColorSpace)
      , t = je.getPrimaries(s);
    let n;
    switch (e === t ? n = "" : e === mr && t === pr ? n = "LinearDisplayP3ToLinearSRGB" : e === pr && t === mr && (n = "LinearSRGBToLinearDisplayP3"),
    s) {
    case xt:
    case xr:
        return [n, "LinearTransferOETF"];
    case Tt:
    case da:
        return [n, "sRGBTransferOETF"];
    default:
        return console.warn("THREE.WebGLProgram: Unsupported color space:", s),
        [n, "LinearTransferOETF"]
    }
}
function Al(s, e, t) {
    const n = s.getShaderParameter(e, s.COMPILE_STATUS)
      , i = s.getShaderInfoLog(e).trim();
    if (n && i === "")
        return "";
    const r = /ERROR: 0:(\d+)/.exec(i);
    if (r) {
        const o = parseInt(r[1]);
        return t.toUpperCase() + `

` + i + `

` + Gm(s.getShaderSource(e), o)
    } else
        return i
}
function Wm(s, e) {
    const t = Vm(e);
    return `vec4 ${s}( vec4 value ) { return ${t[0]}( ${t[1]}( value ) ); }`
}
function Xm(s, e) {
    let t;
    switch (e) {
    case gc:
        t = "Linear";
        break;
    case Mc:
        t = "Reinhard";
        break;
    case _c:
        t = "Cineon";
        break;
    case vc:
        t = "ACESFilmic";
        break;
    case yc:
        t = "AgX";
        break;
    case Sc:
        t = "Neutral";
        break;
    case xc:
        t = "Custom";
        break;
    default:
        console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e),
        t = "Linear"
    }
    return "vec3 " + s + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const Xs = new C;
function qm() {
    je.getLuminanceCoefficients(Xs);
    const s = Xs.x.toFixed(4)
      , e = Xs.y.toFixed(4)
      , t = Xs.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${s}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}
function Ym(s) {
    return [s.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", s.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(ss).join(`
`)
}
function jm(s) {
    const e = [];
    for (const t in s) {
        const n = s[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}
function Km(s, e) {
    const t = {}
      , n = s.getProgramParameter(e, s.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const r = s.getActiveAttrib(e, i)
          , o = r.name;
        let a = 1;
        r.type === s.FLOAT_MAT2 && (a = 2),
        r.type === s.FLOAT_MAT3 && (a = 3),
        r.type === s.FLOAT_MAT4 && (a = 4),
        t[o] = {
            type: r.type,
            location: s.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}
function ss(s) {
    return s !== ""
}
function Rl(s, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return s.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}
function Cl(s, e) {
    return s.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const $m = /^[ \t]*#include +<([\w\d./]+)>/gm;
function jo(s) {
    return s.replace($m, Jm)
}
const Zm = new Map;
function Jm(s, e) {
    let t = ke[e];
    if (t === void 0) {
        const n = Zm.get(e);
        if (n !== void 0)
            t = ke[n],
            console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else
            throw new Error("Can not resolve #include <" + e + ">")
    }
    return jo(t)
}
const Qm = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;
function Pl(s) {
    return s.replace(Qm, eg)
}
function eg(s, e, t, n) {
    let i = "";
    for (let r = parseInt(e); r < parseInt(t); r++)
        i += n.replace(/\[\s*i\s*\]/g, "[ " + r + " ]").replace(/UNROLLED_LOOP_INDEX/g, r);
    return i
}
function Dl(s) {
    let e = `precision ${s.precision} float;
	precision ${s.precision} int;
	precision ${s.precision} sampler2D;
	precision ${s.precision} samplerCube;
	precision ${s.precision} sampler3D;
	precision ${s.precision} sampler2DArray;
	precision ${s.precision} sampler2DShadow;
	precision ${s.precision} samplerCubeShadow;
	precision ${s.precision} sampler2DArrayShadow;
	precision ${s.precision} isampler2D;
	precision ${s.precision} isampler3D;
	precision ${s.precision} isamplerCube;
	precision ${s.precision} isampler2DArray;
	precision ${s.precision} usampler2D;
	precision ${s.precision} usampler3D;
	precision ${s.precision} usamplerCube;
	precision ${s.precision} usampler2DArray;
	`;
    return s.precision === "highp" ? e += `
#define HIGH_PRECISION` : s.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : s.precision === "lowp" && (e += `
#define LOW_PRECISION`),
    e
}
function tg(s) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return s.shadowMapType === fc ? e = "SHADOWMAP_TYPE_PCF" : s.shadowMapType === pc ? e = "SHADOWMAP_TYPE_PCF_SOFT" : s.shadowMapType === yn && (e = "SHADOWMAP_TYPE_VSM"),
    e
}
function ng(s) {
    let e = "ENVMAP_TYPE_CUBE";
    if (s.envMap)
        switch (s.envMapMode) {
        case Ui:
        case Ni:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case vr:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
        }
    return e
}
function ig(s) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (s.envMap)
        switch (s.envMapMode) {
        case Ni:
            e = "ENVMAP_MODE_REFRACTION";
            break
        }
    return e
}
function sg(s) {
    let e = "ENVMAP_BLENDING_NONE";
    if (s.envMap)
        switch (s.combine) {
        case mc:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case jh:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case Kh:
            e = "ENVMAP_BLENDING_ADD";
            break
        }
    return e
}
function rg(s) {
    const e = s.envMapCubeUVHeight;
    if (e === null)
        return null;
    const t = Math.log2(e) - 2
      , n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}
function og(s, e, t, n) {
    const i = s.getContext()
      , r = t.defines;
    let o = t.vertexShader
      , a = t.fragmentShader;
    const l = tg(t)
      , c = ng(t)
      , h = ig(t)
      , d = sg(t)
      , u = rg(t)
      , f = Ym(t)
      , g = jm(r)
      , M = i.createProgram();
    let m, p, E = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (m = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(ss).join(`
`),
    m.length > 0 && (m += `
`),
    p = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(ss).join(`
`),
    p.length > 0 && (p += `
`)) : (m = [Dl(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + h : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(ss).join(`
`),
    p = [Dl(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + h : "", t.envMap ? "#define " + d : "", u ? "#define CUBEUV_TEXEL_WIDTH " + u.texelWidth : "", u ? "#define CUBEUV_TEXEL_HEIGHT " + u.texelHeight : "", u ? "#define CUBEUV_MAX_MIP " + u.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Rn ? "#define TONE_MAPPING" : "", t.toneMapping !== Rn ? ke.tonemapping_pars_fragment : "", t.toneMapping !== Rn ? Xm("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", ke.colorspace_pars_fragment, Wm("linearToOutputTexel", t.outputColorSpace), qm(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(ss).join(`
`)),
    o = jo(o),
    o = Rl(o, t),
    o = Cl(o, t),
    a = jo(a),
    a = Rl(a, t),
    a = Cl(a, t),
    o = Pl(o),
    a = Pl(a),
    t.isRawShaderMaterial !== !0 && (E = `#version 300 es
`,
    m = [f, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + m,
    p = ["#define varying in", t.glslVersion === qa ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === qa ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + p);
    const _ = E + m + o
      , v = E + p + a
      , L = wl(i, i.VERTEX_SHADER, _)
      , P = wl(i, i.FRAGMENT_SHADER, v);
    i.attachShader(M, L),
    i.attachShader(M, P),
    t.index0AttributeName !== void 0 ? i.bindAttribLocation(M, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(M, 0, "position"),
    i.linkProgram(M);
    function A(D) {
        if (s.debug.checkShaderErrors) {
            const G = i.getProgramInfoLog(M).trim()
              , F = i.getShaderInfoLog(L).trim()
              , O = i.getShaderInfoLog(P).trim();
            let V = !0
              , B = !0;
            if (i.getProgramParameter(M, i.LINK_STATUS) === !1)
                if (V = !1,
                typeof s.debug.onShaderError == "function")
                    s.debug.onShaderError(i, M, L, P);
                else {
                    const q = Al(i, L, "vertex")
                      , W = Al(i, P, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(M, i.VALIDATE_STATUS) + `

Material Name: ` + D.name + `
Material Type: ` + D.type + `

Program Info Log: ` + G + `
` + q + `
` + W)
                }
            else
                G !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", G) : (F === "" || O === "") && (B = !1);
            B && (D.diagnostics = {
                runnable: V,
                programLog: G,
                vertexShader: {
                    log: F,
                    prefix: m
                },
                fragmentShader: {
                    log: O,
                    prefix: p
                }
            })
        }
        i.deleteShader(L),
        i.deleteShader(P),
        w = new cr(i,M),
        S = Km(i, M)
    }
    let w;
    this.getUniforms = function() {
        return w === void 0 && A(this),
        w
    }
    ;
    let S;
    this.getAttributes = function() {
        return S === void 0 && A(this),
        S
    }
    ;
    let y = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return y === !1 && (y = i.getProgramParameter(M, km)),
        y
    }
    ,
    this.destroy = function() {
        n.releaseStatesOfProgram(this),
        i.deleteProgram(M),
        this.program = void 0
    }
    ,
    this.type = t.shaderType,
    this.name = t.shaderName,
    this.id = Hm++,
    this.cacheKey = e,
    this.usedTimes = 1,
    this.program = M,
    this.vertexShader = L,
    this.fragmentShader = P,
    this
}
let ag = 0;
class lg {
    constructor() {
        this.shaderCache = new Map,
        this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader
          , n = e.fragmentShader
          , i = this._getShaderStage(t)
          , r = this._getShaderStage(n)
          , o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i),
        i.usedTimes++),
        o.has(r) === !1 && (o.add(r),
        r.usedTimes++),
        this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t)
            n.usedTimes--,
            n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e),
        this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(),
        this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set,
        t.set(e, n)),
        n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new cg(e),
        t.set(e, n)),
        n
    }
}
class cg {
    constructor(e) {
        this.id = ag++,
        this.code = e,
        this.usedTimes = 0
    }
}
function hg(s, e, t, n, i, r, o) {
    const a = new Hc
      , l = new lg
      , c = new Set
      , h = []
      , d = i.logarithmicDepthBuffer
      , u = i.vertexTextures;
    let f = i.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };
    function M(S) {
        return c.add(S),
        S === 0 ? "uv" : `uv${S}`
    }
    function m(S, y, D, G, F) {
        const O = G.fog
          , V = F.geometry
          , B = S.isMeshStandardMaterial ? G.environment : null
          , q = (S.isMeshStandardMaterial ? t : e).get(S.envMap || B)
          , W = q && q.mapping === vr ? q.image.height : null
          , ae = g[S.type];
        S.precision !== null && (f = i.getMaxPrecision(S.precision),
        f !== S.precision && console.warn("THREE.WebGLProgram.getParameters:", S.precision, "not supported, using", f, "instead."));
        const le = V.morphAttributes.position || V.morphAttributes.normal || V.morphAttributes.color
          , me = le !== void 0 ? le.length : 0;
        let Ce = 0;
        V.morphAttributes.position !== void 0 && (Ce = 1),
        V.morphAttributes.normal !== void 0 && (Ce = 2),
        V.morphAttributes.color !== void 0 && (Ce = 3);
        let ze, X, te, ve;
        if (ae) {
            const Ke = tn[ae];
            ze = Ke.vertexShader,
            X = Ke.fragmentShader
        } else
            ze = S.vertexShader,
            X = S.fragmentShader,
            l.update(S),
            te = l.getVertexShaderID(S),
            ve = l.getFragmentShaderID(S);
        const de = s.getRenderTarget()
          , Ae = F.isInstancedMesh === !0
          , Ne = F.isBatchedMesh === !0
          , Le = !!S.map
          , Ye = !!S.matcap
          , T = !!q
          , ie = !!S.aoMap
          , Q = !!S.lightMap
          , fe = !!S.bumpMap
          , Y = !!S.normalMap
          , Re = !!S.displacementMap
          , ue = !!S.emissiveMap
          , _e = !!S.metalnessMap
          , R = !!S.roughnessMap
          , x = S.anisotropy > 0
          , k = S.clearcoat > 0
          , $ = S.dispersion > 0
          , K = S.iridescence > 0
          , J = S.sheen > 0
          , we = S.transmission > 0
          , ce = x && !!S.anisotropyMap
          , Me = k && !!S.clearcoatMap
          , Be = k && !!S.clearcoatNormalMap
          , ne = k && !!S.clearcoatRoughnessMap
          , ge = K && !!S.iridescenceMap
          , Xe = K && !!S.iridescenceThicknessMap
          , Ue = J && !!S.sheenColorMap
          , xe = J && !!S.sheenRoughnessMap
          , Fe = !!S.specularMap
          , Ge = !!S.specularColorMap
          , rt = !!S.specularIntensityMap
          , I = we && !!S.transmissionMap
          , se = we && !!S.thicknessMap
          , j = !!S.gradientMap
          , Z = !!S.alphaMap
          , oe = S.alphaTest > 0
          , Pe = !!S.alphaHash
          , qe = !!S.extensions;
        let ht = Rn;
        S.toneMapped && (de === null || de.isXRRenderTarget === !0) && (ht = s.toneMapping);
        const yt = {
            shaderID: ae,
            shaderType: S.type,
            shaderName: S.name,
            vertexShader: ze,
            fragmentShader: X,
            defines: S.defines,
            customVertexShaderID: te,
            customFragmentShaderID: ve,
            isRawShaderMaterial: S.isRawShaderMaterial === !0,
            glslVersion: S.glslVersion,
            precision: f,
            batching: Ne,
            batchingColor: Ne && F._colorsTexture !== null,
            instancing: Ae,
            instancingColor: Ae && F.instanceColor !== null,
            instancingMorph: Ae && F.morphTexture !== null,
            supportsVertexTextures: u,
            outputColorSpace: de === null ? s.outputColorSpace : de.isXRRenderTarget === !0 ? de.texture.colorSpace : xt,
            alphaToCoverage: !!S.alphaToCoverage,
            map: Le,
            matcap: Ye,
            envMap: T,
            envMapMode: T && q.mapping,
            envMapCubeUVHeight: W,
            aoMap: ie,
            lightMap: Q,
            bumpMap: fe,
            normalMap: Y,
            displacementMap: u && Re,
            emissiveMap: ue,
            normalMapObjectSpace: Y && S.normalMapType === td,
            normalMapTangentSpace: Y && S.normalMapType === Nc,
            metalnessMap: _e,
            roughnessMap: R,
            anisotropy: x,
            anisotropyMap: ce,
            clearcoat: k,
            clearcoatMap: Me,
            clearcoatNormalMap: Be,
            clearcoatRoughnessMap: ne,
            dispersion: $,
            iridescence: K,
            iridescenceMap: ge,
            iridescenceThicknessMap: Xe,
            sheen: J,
            sheenColorMap: Ue,
            sheenRoughnessMap: xe,
            specularMap: Fe,
            specularColorMap: Ge,
            specularIntensityMap: rt,
            transmission: we,
            transmissionMap: I,
            thicknessMap: se,
            gradientMap: j,
            opaque: S.transparent === !1 && S.blending === Ri && S.alphaToCoverage === !1,
            alphaMap: Z,
            alphaTest: oe,
            alphaHash: Pe,
            combine: S.combine,
            mapUv: Le && M(S.map.channel),
            aoMapUv: ie && M(S.aoMap.channel),
            lightMapUv: Q && M(S.lightMap.channel),
            bumpMapUv: fe && M(S.bumpMap.channel),
            normalMapUv: Y && M(S.normalMap.channel),
            displacementMapUv: Re && M(S.displacementMap.channel),
            emissiveMapUv: ue && M(S.emissiveMap.channel),
            metalnessMapUv: _e && M(S.metalnessMap.channel),
            roughnessMapUv: R && M(S.roughnessMap.channel),
            anisotropyMapUv: ce && M(S.anisotropyMap.channel),
            clearcoatMapUv: Me && M(S.clearcoatMap.channel),
            clearcoatNormalMapUv: Be && M(S.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: ne && M(S.clearcoatRoughnessMap.channel),
            iridescenceMapUv: ge && M(S.iridescenceMap.channel),
            iridescenceThicknessMapUv: Xe && M(S.iridescenceThicknessMap.channel),
            sheenColorMapUv: Ue && M(S.sheenColorMap.channel),
            sheenRoughnessMapUv: xe && M(S.sheenRoughnessMap.channel),
            specularMapUv: Fe && M(S.specularMap.channel),
            specularColorMapUv: Ge && M(S.specularColorMap.channel),
            specularIntensityMapUv: rt && M(S.specularIntensityMap.channel),
            transmissionMapUv: I && M(S.transmissionMap.channel),
            thicknessMapUv: se && M(S.thicknessMap.channel),
            alphaMapUv: Z && M(S.alphaMap.channel),
            vertexTangents: !!V.attributes.tangent && (Y || x),
            vertexColors: S.vertexColors,
            vertexAlphas: S.vertexColors === !0 && !!V.attributes.color && V.attributes.color.itemSize === 4,
            pointsUvs: F.isPoints === !0 && !!V.attributes.uv && (Le || Z),
            fog: !!O,
            useFog: S.fog === !0,
            fogExp2: !!O && O.isFogExp2,
            flatShading: S.flatShading === !0,
            sizeAttenuation: S.sizeAttenuation === !0,
            logarithmicDepthBuffer: d,
            skinning: F.isSkinnedMesh === !0,
            morphTargets: V.morphAttributes.position !== void 0,
            morphNormals: V.morphAttributes.normal !== void 0,
            morphColors: V.morphAttributes.color !== void 0,
            morphTargetsCount: me,
            morphTextureStride: Ce,
            numDirLights: y.directional.length,
            numPointLights: y.point.length,
            numSpotLights: y.spot.length,
            numSpotLightMaps: y.spotLightMap.length,
            numRectAreaLights: y.rectArea.length,
            numHemiLights: y.hemi.length,
            numDirLightShadows: y.directionalShadowMap.length,
            numPointLightShadows: y.pointShadowMap.length,
            numSpotLightShadows: y.spotShadowMap.length,
            numSpotLightShadowsWithMaps: y.numSpotLightShadowsWithMaps,
            numLightProbes: y.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: S.dithering,
            shadowMapEnabled: s.shadowMap.enabled && D.length > 0,
            shadowMapType: s.shadowMap.type,
            toneMapping: ht,
            decodeVideoTexture: Le && S.map.isVideoTexture === !0 && je.getTransfer(S.map.colorSpace) === st,
            premultipliedAlpha: S.premultipliedAlpha,
            doubleSided: S.side === Bt,
            flipSided: S.side === It,
            useDepthPacking: S.depthPacking >= 0,
            depthPacking: S.depthPacking || 0,
            index0AttributeName: S.index0AttributeName,
            extensionClipCullDistance: qe && S.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (qe && S.extensions.multiDraw === !0 || Ne) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: S.customProgramCacheKey()
        };
        return yt.vertexUv1s = c.has(1),
        yt.vertexUv2s = c.has(2),
        yt.vertexUv3s = c.has(3),
        c.clear(),
        yt
    }
    function p(S) {
        const y = [];
        if (S.shaderID ? y.push(S.shaderID) : (y.push(S.customVertexShaderID),
        y.push(S.customFragmentShaderID)),
        S.defines !== void 0)
            for (const D in S.defines)
                y.push(D),
                y.push(S.defines[D]);
        return S.isRawShaderMaterial === !1 && (E(y, S),
        _(y, S),
        y.push(s.outputColorSpace)),
        y.push(S.customProgramCacheKey),
        y.join()
    }
    function E(S, y) {
        S.push(y.precision),
        S.push(y.outputColorSpace),
        S.push(y.envMapMode),
        S.push(y.envMapCubeUVHeight),
        S.push(y.mapUv),
        S.push(y.alphaMapUv),
        S.push(y.lightMapUv),
        S.push(y.aoMapUv),
        S.push(y.bumpMapUv),
        S.push(y.normalMapUv),
        S.push(y.displacementMapUv),
        S.push(y.emissiveMapUv),
        S.push(y.metalnessMapUv),
        S.push(y.roughnessMapUv),
        S.push(y.anisotropyMapUv),
        S.push(y.clearcoatMapUv),
        S.push(y.clearcoatNormalMapUv),
        S.push(y.clearcoatRoughnessMapUv),
        S.push(y.iridescenceMapUv),
        S.push(y.iridescenceThicknessMapUv),
        S.push(y.sheenColorMapUv),
        S.push(y.sheenRoughnessMapUv),
        S.push(y.specularMapUv),
        S.push(y.specularColorMapUv),
        S.push(y.specularIntensityMapUv),
        S.push(y.transmissionMapUv),
        S.push(y.thicknessMapUv),
        S.push(y.combine),
        S.push(y.fogExp2),
        S.push(y.sizeAttenuation),
        S.push(y.morphTargetsCount),
        S.push(y.morphAttributeCount),
        S.push(y.numDirLights),
        S.push(y.numPointLights),
        S.push(y.numSpotLights),
        S.push(y.numSpotLightMaps),
        S.push(y.numHemiLights),
        S.push(y.numRectAreaLights),
        S.push(y.numDirLightShadows),
        S.push(y.numPointLightShadows),
        S.push(y.numSpotLightShadows),
        S.push(y.numSpotLightShadowsWithMaps),
        S.push(y.numLightProbes),
        S.push(y.shadowMapType),
        S.push(y.toneMapping),
        S.push(y.numClippingPlanes),
        S.push(y.numClipIntersection),
        S.push(y.depthPacking)
    }
    function _(S, y) {
        a.disableAll(),
        y.supportsVertexTextures && a.enable(0),
        y.instancing && a.enable(1),
        y.instancingColor && a.enable(2),
        y.instancingMorph && a.enable(3),
        y.matcap && a.enable(4),
        y.envMap && a.enable(5),
        y.normalMapObjectSpace && a.enable(6),
        y.normalMapTangentSpace && a.enable(7),
        y.clearcoat && a.enable(8),
        y.iridescence && a.enable(9),
        y.alphaTest && a.enable(10),
        y.vertexColors && a.enable(11),
        y.vertexAlphas && a.enable(12),
        y.vertexUv1s && a.enable(13),
        y.vertexUv2s && a.enable(14),
        y.vertexUv3s && a.enable(15),
        y.vertexTangents && a.enable(16),
        y.anisotropy && a.enable(17),
        y.alphaHash && a.enable(18),
        y.batching && a.enable(19),
        y.dispersion && a.enable(20),
        y.batchingColor && a.enable(21),
        S.push(a.mask),
        a.disableAll(),
        y.fog && a.enable(0),
        y.useFog && a.enable(1),
        y.flatShading && a.enable(2),
        y.logarithmicDepthBuffer && a.enable(3),
        y.skinning && a.enable(4),
        y.morphTargets && a.enable(5),
        y.morphNormals && a.enable(6),
        y.morphColors && a.enable(7),
        y.premultipliedAlpha && a.enable(8),
        y.shadowMapEnabled && a.enable(9),
        y.doubleSided && a.enable(10),
        y.flipSided && a.enable(11),
        y.useDepthPacking && a.enable(12),
        y.dithering && a.enable(13),
        y.transmission && a.enable(14),
        y.sheen && a.enable(15),
        y.opaque && a.enable(16),
        y.pointsUvs && a.enable(17),
        y.decodeVideoTexture && a.enable(18),
        y.alphaToCoverage && a.enable(19),
        S.push(a.mask)
    }
    function v(S) {
        const y = g[S.type];
        let D;
        if (y) {
            const G = tn[y];
            D = qc.clone(G.uniforms)
        } else
            D = S.uniforms;
        return D
    }
    function L(S, y) {
        let D;
        for (let G = 0, F = h.length; G < F; G++) {
            const O = h[G];
            if (O.cacheKey === y) {
                D = O,
                ++D.usedTimes;
                break
            }
        }
        return D === void 0 && (D = new og(s,y,S,r),
        h.push(D)),
        D
    }
    function P(S) {
        if (--S.usedTimes === 0) {
            const y = h.indexOf(S);
            h[y] = h[h.length - 1],
            h.pop(),
            S.destroy()
        }
    }
    function A(S) {
        l.remove(S)
    }
    function w() {
        l.dispose()
    }
    return {
        getParameters: m,
        getProgramCacheKey: p,
        getUniforms: v,
        acquireProgram: L,
        releaseProgram: P,
        releaseShaderCache: A,
        programs: h,
        dispose: w
    }
}
function dg() {
    let s = new WeakMap;
    function e(o) {
        return s.has(o)
    }
    function t(o) {
        let a = s.get(o);
        return a === void 0 && (a = {},
        s.set(o, a)),
        a
    }
    function n(o) {
        s.delete(o)
    }
    function i(o, a, l) {
        s.get(o)[a] = l
    }
    function r() {
        s = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: i,
        dispose: r
    }
}
function ug(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.material.id !== e.material.id ? s.material.id - e.material.id : s.z !== e.z ? s.z - e.z : s.id - e.id
}
function Ll(s, e) {
    return s.groupOrder !== e.groupOrder ? s.groupOrder - e.groupOrder : s.renderOrder !== e.renderOrder ? s.renderOrder - e.renderOrder : s.z !== e.z ? e.z - s.z : s.id - e.id
}
function Il() {
    const s = [];
    let e = 0;
    const t = []
      , n = []
      , i = [];
    function r() {
        e = 0,
        t.length = 0,
        n.length = 0,
        i.length = 0
    }
    function o(d, u, f, g, M, m) {
        let p = s[e];
        return p === void 0 ? (p = {
            id: d.id,
            object: d,
            geometry: u,
            material: f,
            groupOrder: g,
            renderOrder: d.renderOrder,
            z: M,
            group: m
        },
        s[e] = p) : (p.id = d.id,
        p.object = d,
        p.geometry = u,
        p.material = f,
        p.groupOrder = g,
        p.renderOrder = d.renderOrder,
        p.z = M,
        p.group = m),
        e++,
        p
    }
    function a(d, u, f, g, M, m) {
        const p = o(d, u, f, g, M, m);
        f.transmission > 0 ? n.push(p) : f.transparent === !0 ? i.push(p) : t.push(p)
    }
    function l(d, u, f, g, M, m) {
        const p = o(d, u, f, g, M, m);
        f.transmission > 0 ? n.unshift(p) : f.transparent === !0 ? i.unshift(p) : t.unshift(p)
    }
    function c(d, u) {
        t.length > 1 && t.sort(d || ug),
        n.length > 1 && n.sort(u || Ll),
        i.length > 1 && i.sort(u || Ll)
    }
    function h() {
        for (let d = e, u = s.length; d < u; d++) {
            const f = s[d];
            if (f.id === null)
                break;
            f.id = null,
            f.object = null,
            f.geometry = null,
            f.material = null,
            f.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: r,
        push: a,
        unshift: l,
        finish: h,
        sort: c
    }
}
function fg() {
    let s = new WeakMap;
    function e(n, i) {
        const r = s.get(n);
        let o;
        return r === void 0 ? (o = new Il,
        s.set(n, [o])) : i >= r.length ? (o = new Il,
        r.push(o)) : o = r[i],
        o
    }
    function t() {
        s = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}
function pg() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    direction: new C,
                    color: new be
                };
                break;
            case "SpotLight":
                t = {
                    position: new C,
                    direction: new C,
                    color: new be,
                    distance: 0,
                    coneCos: 0,
                    penumbraCos: 0,
                    decay: 0
                };
                break;
            case "PointLight":
                t = {
                    position: new C,
                    color: new be,
                    distance: 0,
                    decay: 0
                };
                break;
            case "HemisphereLight":
                t = {
                    direction: new C,
                    skyColor: new be,
                    groundColor: new be
                };
                break;
            case "RectAreaLight":
                t = {
                    color: new be,
                    position: new C,
                    halfWidth: new C,
                    halfHeight: new C
                };
                break
            }
            return s[e.id] = t,
            t
        }
    }
}
function mg() {
    const s = {};
    return {
        get: function(e) {
            if (s[e.id] !== void 0)
                return s[e.id];
            let t;
            switch (e.type) {
            case "DirectionalLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ee
                };
                break;
            case "SpotLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ee
                };
                break;
            case "PointLight":
                t = {
                    shadowIntensity: 1,
                    shadowBias: 0,
                    shadowNormalBias: 0,
                    shadowRadius: 1,
                    shadowMapSize: new ee,
                    shadowCameraNear: 1,
                    shadowCameraFar: 1e3
                };
                break
            }
            return s[e.id] = t,
            t
        }
    }
}
let gg = 0;
function Mg(s, e) {
    return (e.castShadow ? 2 : 0) - (s.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (s.map ? 1 : 0)
}
function _g(s) {
    const e = new pg
      , t = mg()
      , n = {
        version: 0,
        hash: {
            directionalLength: -1,
            pointLength: -1,
            spotLength: -1,
            rectAreaLength: -1,
            hemiLength: -1,
            numDirectionalShadows: -1,
            numPointShadows: -1,
            numSpotShadows: -1,
            numSpotMaps: -1,
            numLightProbes: -1
        },
        ambient: [0, 0, 0],
        probe: [],
        directional: [],
        directionalShadow: [],
        directionalShadowMap: [],
        directionalShadowMatrix: [],
        spot: [],
        spotLightMap: [],
        spotShadow: [],
        spotShadowMap: [],
        spotLightMatrix: [],
        rectArea: [],
        rectAreaLTC1: null,
        rectAreaLTC2: null,
        point: [],
        pointShadow: [],
        pointShadowMap: [],
        pointShadowMatrix: [],
        hemi: [],
        numSpotLightShadowsWithMaps: 0,
        numLightProbes: 0
    };
    for (let c = 0; c < 9; c++)
        n.probe.push(new C);
    const i = new C
      , r = new Oe
      , o = new Oe;
    function a(c) {
        let h = 0
          , d = 0
          , u = 0;
        for (let S = 0; S < 9; S++)
            n.probe[S].set(0, 0, 0);
        let f = 0
          , g = 0
          , M = 0
          , m = 0
          , p = 0
          , E = 0
          , _ = 0
          , v = 0
          , L = 0
          , P = 0
          , A = 0;
        c.sort(Mg);
        for (let S = 0, y = c.length; S < y; S++) {
            const D = c[S]
              , G = D.color
              , F = D.intensity
              , O = D.distance
              , V = D.shadow && D.shadow.map ? D.shadow.map.texture : null;
            if (D.isAmbientLight)
                h += G.r * F,
                d += G.g * F,
                u += G.b * F;
            else if (D.isLightProbe) {
                for (let B = 0; B < 9; B++)
                    n.probe[B].addScaledVector(D.sh.coefficients[B], F);
                A++
            } else if (D.isDirectionalLight) {
                const B = e.get(D);
                if (B.color.copy(D.color).multiplyScalar(D.intensity),
                D.castShadow) {
                    const q = D.shadow
                      , W = t.get(D);
                    W.shadowIntensity = q.intensity,
                    W.shadowBias = q.bias,
                    W.shadowNormalBias = q.normalBias,
                    W.shadowRadius = q.radius,
                    W.shadowMapSize = q.mapSize,
                    n.directionalShadow[f] = W,
                    n.directionalShadowMap[f] = V,
                    n.directionalShadowMatrix[f] = D.shadow.matrix,
                    E++
                }
                n.directional[f] = B,
                f++
            } else if (D.isSpotLight) {
                const B = e.get(D);
                B.position.setFromMatrixPosition(D.matrixWorld),
                B.color.copy(G).multiplyScalar(F),
                B.distance = O,
                B.coneCos = Math.cos(D.angle),
                B.penumbraCos = Math.cos(D.angle * (1 - D.penumbra)),
                B.decay = D.decay,
                n.spot[M] = B;
                const q = D.shadow;
                if (D.map && (n.spotLightMap[L] = D.map,
                L++,
                q.updateMatrices(D),
                D.castShadow && P++),
                n.spotLightMatrix[M] = q.matrix,
                D.castShadow) {
                    const W = t.get(D);
                    W.shadowIntensity = q.intensity,
                    W.shadowBias = q.bias,
                    W.shadowNormalBias = q.normalBias,
                    W.shadowRadius = q.radius,
                    W.shadowMapSize = q.mapSize,
                    n.spotShadow[M] = W,
                    n.spotShadowMap[M] = V,
                    v++
                }
                M++
            } else if (D.isRectAreaLight) {
                const B = e.get(D);
                B.color.copy(G).multiplyScalar(F),
                B.halfWidth.set(D.width * .5, 0, 0),
                B.halfHeight.set(0, D.height * .5, 0),
                n.rectArea[m] = B,
                m++
            } else if (D.isPointLight) {
                const B = e.get(D);
                if (B.color.copy(D.color).multiplyScalar(D.intensity),
                B.distance = D.distance,
                B.decay = D.decay,
                D.castShadow) {
                    const q = D.shadow
                      , W = t.get(D);
                    W.shadowIntensity = q.intensity,
                    W.shadowBias = q.bias,
                    W.shadowNormalBias = q.normalBias,
                    W.shadowRadius = q.radius,
                    W.shadowMapSize = q.mapSize,
                    W.shadowCameraNear = q.camera.near,
                    W.shadowCameraFar = q.camera.far,
                    n.pointShadow[g] = W,
                    n.pointShadowMap[g] = V,
                    n.pointShadowMatrix[g] = D.shadow.matrix,
                    _++
                }
                n.point[g] = B,
                g++
            } else if (D.isHemisphereLight) {
                const B = e.get(D);
                B.skyColor.copy(D.color).multiplyScalar(F),
                B.groundColor.copy(D.groundColor).multiplyScalar(F),
                n.hemi[p] = B,
                p++
            }
        }
        m > 0 && (s.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = he.LTC_FLOAT_1,
        n.rectAreaLTC2 = he.LTC_FLOAT_2) : (n.rectAreaLTC1 = he.LTC_HALF_1,
        n.rectAreaLTC2 = he.LTC_HALF_2)),
        n.ambient[0] = h,
        n.ambient[1] = d,
        n.ambient[2] = u;
        const w = n.hash;
        (w.directionalLength !== f || w.pointLength !== g || w.spotLength !== M || w.rectAreaLength !== m || w.hemiLength !== p || w.numDirectionalShadows !== E || w.numPointShadows !== _ || w.numSpotShadows !== v || w.numSpotMaps !== L || w.numLightProbes !== A) && (n.directional.length = f,
        n.spot.length = M,
        n.rectArea.length = m,
        n.point.length = g,
        n.hemi.length = p,
        n.directionalShadow.length = E,
        n.directionalShadowMap.length = E,
        n.pointShadow.length = _,
        n.pointShadowMap.length = _,
        n.spotShadow.length = v,
        n.spotShadowMap.length = v,
        n.directionalShadowMatrix.length = E,
        n.pointShadowMatrix.length = _,
        n.spotLightMatrix.length = v + L - P,
        n.spotLightMap.length = L,
        n.numSpotLightShadowsWithMaps = P,
        n.numLightProbes = A,
        w.directionalLength = f,
        w.pointLength = g,
        w.spotLength = M,
        w.rectAreaLength = m,
        w.hemiLength = p,
        w.numDirectionalShadows = E,
        w.numPointShadows = _,
        w.numSpotShadows = v,
        w.numSpotMaps = L,
        w.numLightProbes = A,
        n.version = gg++)
    }
    function l(c, h) {
        let d = 0
          , u = 0
          , f = 0
          , g = 0
          , M = 0;
        const m = h.matrixWorldInverse;
        for (let p = 0, E = c.length; p < E; p++) {
            const _ = c[p];
            if (_.isDirectionalLight) {
                const v = n.directional[d];
                v.direction.setFromMatrixPosition(_.matrixWorld),
                i.setFromMatrixPosition(_.target.matrixWorld),
                v.direction.sub(i),
                v.direction.transformDirection(m),
                d++
            } else if (_.isSpotLight) {
                const v = n.spot[f];
                v.position.setFromMatrixPosition(_.matrixWorld),
                v.position.applyMatrix4(m),
                v.direction.setFromMatrixPosition(_.matrixWorld),
                i.setFromMatrixPosition(_.target.matrixWorld),
                v.direction.sub(i),
                v.direction.transformDirection(m),
                f++
            } else if (_.isRectAreaLight) {
                const v = n.rectArea[g];
                v.position.setFromMatrixPosition(_.matrixWorld),
                v.position.applyMatrix4(m),
                o.identity(),
                r.copy(_.matrixWorld),
                r.premultiply(m),
                o.extractRotation(r),
                v.halfWidth.set(_.width * .5, 0, 0),
                v.halfHeight.set(0, _.height * .5, 0),
                v.halfWidth.applyMatrix4(o),
                v.halfHeight.applyMatrix4(o),
                g++
            } else if (_.isPointLight) {
                const v = n.point[u];
                v.position.setFromMatrixPosition(_.matrixWorld),
                v.position.applyMatrix4(m),
                u++
            } else if (_.isHemisphereLight) {
                const v = n.hemi[M];
                v.direction.setFromMatrixPosition(_.matrixWorld),
                v.direction.transformDirection(m),
                M++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: n
    }
}
function Ul(s) {
    const e = new _g(s)
      , t = []
      , n = [];
    function i(h) {
        c.camera = h,
        t.length = 0,
        n.length = 0
    }
    function r(h) {
        t.push(h)
    }
    function o(h) {
        n.push(h)
    }
    function a() {
        e.setup(t)
    }
    function l(h) {
        e.setupView(t, h)
    }
    const c = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: r,
        pushShadow: o
    }
}
function vg(s) {
    let e = new WeakMap;
    function t(i, r=0) {
        const o = e.get(i);
        let a;
        return o === void 0 ? (a = new Ul(s),
        e.set(i, [a])) : r >= o.length ? (a = new Ul(s),
        o.push(a)) : a = o[r],
        a
    }
    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
class xg extends $t {
    constructor(e) {
        super(),
        this.isMeshDepthMaterial = !0,
        this.type = "MeshDepthMaterial",
        this.depthPacking = Qh,
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.depthPacking = e.depthPacking,
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this
    }
}
class yg extends $t {
    constructor(e) {
        super(),
        this.isMeshDistanceMaterial = !0,
        this.type = "MeshDistanceMaterial",
        this.map = null,
        this.alphaMap = null,
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this
    }
}
const Sg = `void main() {
	gl_Position = vec4( position, 1.0 );
}`
  , bg = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;
function Eg(s, e, t) {
    let n = new pa;
    const i = new ee
      , r = new ee
      , o = new Qe
      , a = new xg({
        depthPacking: ed
    })
      , l = new yg
      , c = {}
      , h = t.maxTextureSize
      , d = {
        [Jt]: It,
        [It]: Jt,
        [Bt]: Bt
    }
      , u = new hn({
        defines: {
            VSM_SAMPLES: 8
        },
        uniforms: {
            shadow_pass: {
                value: null
            },
            resolution: {
                value: new ee
            },
            radius: {
                value: 4
            }
        },
        vertexShader: Sg,
        fragmentShader: bg
    })
      , f = u.clone();
    f.defines.HORIZONTAL_PASS = 1;
    const g = new Qt;
    g.setAttribute("position", new Dt(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]),3));
    const M = new ct(g,u)
      , m = this;
    this.enabled = !1,
    this.autoUpdate = !0,
    this.needsUpdate = !1,
    this.type = fc;
    let p = this.type;
    this.render = function(P, A, w) {
        if (m.enabled === !1 || m.autoUpdate === !1 && m.needsUpdate === !1 || P.length === 0)
            return;
        const S = s.getRenderTarget()
          , y = s.getActiveCubeFace()
          , D = s.getActiveMipmapLevel()
          , G = s.state;
        G.setBlending(Vn),
        G.buffers.color.setClear(1, 1, 1, 1),
        G.buffers.depth.setTest(!0),
        G.setScissorTest(!1);
        const F = p !== yn && this.type === yn
          , O = p === yn && this.type !== yn;
        for (let V = 0, B = P.length; V < B; V++) {
            const q = P[V]
              , W = q.shadow;
            if (W === void 0) {
                console.warn("THREE.WebGLShadowMap:", q, "has no shadow.");
                continue
            }
            if (W.autoUpdate === !1 && W.needsUpdate === !1)
                continue;
            i.copy(W.mapSize);
            const ae = W.getFrameExtents();
            if (i.multiply(ae),
            r.copy(W.mapSize),
            (i.x > h || i.y > h) && (i.x > h && (r.x = Math.floor(h / ae.x),
            i.x = r.x * ae.x,
            W.mapSize.x = r.x),
            i.y > h && (r.y = Math.floor(h / ae.y),
            i.y = r.y * ae.y,
            W.mapSize.y = r.y)),
            W.map === null || F === !0 || O === !0) {
                const me = this.type !== yn ? {
                    minFilter: Ct,
                    magFilter: Ct
                } : {};
                W.map !== null && W.map.dispose(),
                W.map = new Wn(i.x,i.y,me),
                W.map.texture.name = q.name + ".shadowMap",
                W.camera.updateProjectionMatrix()
            }
            s.setRenderTarget(W.map),
            s.clear();
            const le = W.getViewportCount();
            for (let me = 0; me < le; me++) {
                const Ce = W.getViewport(me);
                o.set(r.x * Ce.x, r.y * Ce.y, r.x * Ce.z, r.y * Ce.w),
                G.viewport(o),
                W.updateMatrices(q, me),
                n = W.getFrustum(),
                v(A, w, W.camera, q, this.type)
            }
            W.isPointLightShadow !== !0 && this.type === yn && E(W, w),
            W.needsUpdate = !1
        }
        p = this.type,
        m.needsUpdate = !1,
        s.setRenderTarget(S, y, D)
    }
    ;
    function E(P, A) {
        const w = e.update(M);
        u.defines.VSM_SAMPLES !== P.blurSamples && (u.defines.VSM_SAMPLES = P.blurSamples,
        f.defines.VSM_SAMPLES = P.blurSamples,
        u.needsUpdate = !0,
        f.needsUpdate = !0),
        P.mapPass === null && (P.mapPass = new Wn(i.x,i.y)),
        u.uniforms.shadow_pass.value = P.map.texture,
        u.uniforms.resolution.value = P.mapSize,
        u.uniforms.radius.value = P.radius,
        s.setRenderTarget(P.mapPass),
        s.clear(),
        s.renderBufferDirect(A, null, w, u, M, null),
        f.uniforms.shadow_pass.value = P.mapPass.texture,
        f.uniforms.resolution.value = P.mapSize,
        f.uniforms.radius.value = P.radius,
        s.setRenderTarget(P.map),
        s.clear(),
        s.renderBufferDirect(A, null, w, f, M, null)
    }
    function _(P, A, w, S) {
        let y = null;
        const D = w.isPointLight === !0 ? P.customDistanceMaterial : P.customDepthMaterial;
        if (D !== void 0)
            y = D;
        else if (y = w.isPointLight === !0 ? l : a,
        s.localClippingEnabled && A.clipShadows === !0 && Array.isArray(A.clippingPlanes) && A.clippingPlanes.length !== 0 || A.displacementMap && A.displacementScale !== 0 || A.alphaMap && A.alphaTest > 0 || A.map && A.alphaTest > 0) {
            const G = y.uuid
              , F = A.uuid;
            let O = c[G];
            O === void 0 && (O = {},
            c[G] = O);
            let V = O[F];
            V === void 0 && (V = y.clone(),
            O[F] = V,
            A.addEventListener("dispose", L)),
            y = V
        }
        if (y.visible = A.visible,
        y.wireframe = A.wireframe,
        S === yn ? y.side = A.shadowSide !== null ? A.shadowSide : A.side : y.side = A.shadowSide !== null ? A.shadowSide : d[A.side],
        y.alphaMap = A.alphaMap,
        y.alphaTest = A.alphaTest,
        y.map = A.map,
        y.clipShadows = A.clipShadows,
        y.clippingPlanes = A.clippingPlanes,
        y.clipIntersection = A.clipIntersection,
        y.displacementMap = A.displacementMap,
        y.displacementScale = A.displacementScale,
        y.displacementBias = A.displacementBias,
        y.wireframeLinewidth = A.wireframeLinewidth,
        y.linewidth = A.linewidth,
        w.isPointLight === !0 && y.isMeshDistanceMaterial === !0) {
            const G = s.properties.get(y);
            G.light = w
        }
        return y
    }
    function v(P, A, w, S, y) {
        if (P.visible === !1)
            return;
        if (P.layers.test(A.layers) && (P.isMesh || P.isLine || P.isPoints) && (P.castShadow || P.receiveShadow && y === yn) && (!P.frustumCulled || n.intersectsObject(P))) {
            P.modelViewMatrix.multiplyMatrices(w.matrixWorldInverse, P.matrixWorld);
            const F = e.update(P)
              , O = P.material;
            if (Array.isArray(O)) {
                const V = F.groups;
                for (let B = 0, q = V.length; B < q; B++) {
                    const W = V[B]
                      , ae = O[W.materialIndex];
                    if (ae && ae.visible) {
                        const le = _(P, ae, S, y);
                        P.onBeforeShadow(s, P, A, w, F, le, W),
                        s.renderBufferDirect(w, null, F, le, P, W),
                        P.onAfterShadow(s, P, A, w, F, le, W)
                    }
                }
            } else if (O.visible) {
                const V = _(P, O, S, y);
                P.onBeforeShadow(s, P, A, w, F, V, null),
                s.renderBufferDirect(w, null, F, V, P, null),
                P.onAfterShadow(s, P, A, w, F, V, null)
            }
        }
        const G = P.children;
        for (let F = 0, O = G.length; F < O; F++)
            v(G[F], A, w, S, y)
    }
    function L(P) {
        P.target.removeEventListener("dispose", L);
        for (const w in c) {
            const S = c[w]
              , y = P.target.uuid;
            y in S && (S[y].dispose(),
            delete S[y])
        }
    }
}
function Tg(s) {
    function e() {
        let I = !1;
        const se = new Qe;
        let j = null;
        const Z = new Qe(0,0,0,0);
        return {
            setMask: function(oe) {
                j !== oe && !I && (s.colorMask(oe, oe, oe, oe),
                j = oe)
            },
            setLocked: function(oe) {
                I = oe
            },
            setClear: function(oe, Pe, qe, ht, yt) {
                yt === !0 && (oe *= ht,
                Pe *= ht,
                qe *= ht),
                se.set(oe, Pe, qe, ht),
                Z.equals(se) === !1 && (s.clearColor(oe, Pe, qe, ht),
                Z.copy(se))
            },
            reset: function() {
                I = !1,
                j = null,
                Z.set(-1, 0, 0, 0)
            }
        }
    }
    function t() {
        let I = !1
          , se = null
          , j = null
          , Z = null;
        return {
            setTest: function(oe) {
                oe ? ve(s.DEPTH_TEST) : de(s.DEPTH_TEST)
            },
            setMask: function(oe) {
                se !== oe && !I && (s.depthMask(oe),
                se = oe)
            },
            setFunc: function(oe) {
                if (j !== oe) {
                    switch (oe) {
                    case Hh:
                        s.depthFunc(s.NEVER);
                        break;
                    case Gh:
                        s.depthFunc(s.ALWAYS);
                        break;
                    case Vh:
                        s.depthFunc(s.LESS);
                        break;
                    case dr:
                        s.depthFunc(s.LEQUAL);
                        break;
                    case Wh:
                        s.depthFunc(s.EQUAL);
                        break;
                    case Xh:
                        s.depthFunc(s.GEQUAL);
                        break;
                    case qh:
                        s.depthFunc(s.GREATER);
                        break;
                    case Yh:
                        s.depthFunc(s.NOTEQUAL);
                        break;
                    default:
                        s.depthFunc(s.LEQUAL)
                    }
                    j = oe
                }
            },
            setLocked: function(oe) {
                I = oe
            },
            setClear: function(oe) {
                Z !== oe && (s.clearDepth(oe),
                Z = oe)
            },
            reset: function() {
                I = !1,
                se = null,
                j = null,
                Z = null
            }
        }
    }
    function n() {
        let I = !1
          , se = null
          , j = null
          , Z = null
          , oe = null
          , Pe = null
          , qe = null
          , ht = null
          , yt = null;
        return {
            setTest: function(Ke) {
                I || (Ke ? ve(s.STENCIL_TEST) : de(s.STENCIL_TEST))
            },
            setMask: function(Ke) {
                se !== Ke && !I && (s.stencilMask(Ke),
                se = Ke)
            },
            setFunc: function(Ke, pn, en) {
                (j !== Ke || Z !== pn || oe !== en) && (s.stencilFunc(Ke, pn, en),
                j = Ke,
                Z = pn,
                oe = en)
            },
            setOp: function(Ke, pn, en) {
                (Pe !== Ke || qe !== pn || ht !== en) && (s.stencilOp(Ke, pn, en),
                Pe = Ke,
                qe = pn,
                ht = en)
            },
            setLocked: function(Ke) {
                I = Ke
            },
            setClear: function(Ke) {
                yt !== Ke && (s.clearStencil(Ke),
                yt = Ke)
            },
            reset: function() {
                I = !1,
                se = null,
                j = null,
                Z = null,
                oe = null,
                Pe = null,
                qe = null,
                ht = null,
                yt = null
            }
        }
    }
    const i = new e
      , r = new t
      , o = new n
      , a = new WeakMap
      , l = new WeakMap;
    let c = {}
      , h = {}
      , d = new WeakMap
      , u = []
      , f = null
      , g = !1
      , M = null
      , m = null
      , p = null
      , E = null
      , _ = null
      , v = null
      , L = null
      , P = new be(0,0,0)
      , A = 0
      , w = !1
      , S = null
      , y = null
      , D = null
      , G = null
      , F = null;
    const O = s.getParameter(s.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let V = !1
      , B = 0;
    const q = s.getParameter(s.VERSION);
    q.indexOf("WebGL") !== -1 ? (B = parseFloat(/^WebGL (\d)/.exec(q)[1]),
    V = B >= 1) : q.indexOf("OpenGL ES") !== -1 && (B = parseFloat(/^OpenGL ES (\d)/.exec(q)[1]),
    V = B >= 2);
    let W = null
      , ae = {};
    const le = s.getParameter(s.SCISSOR_BOX)
      , me = s.getParameter(s.VIEWPORT)
      , Ce = new Qe().fromArray(le)
      , ze = new Qe().fromArray(me);
    function X(I, se, j, Z) {
        const oe = new Uint8Array(4)
          , Pe = s.createTexture();
        s.bindTexture(I, Pe),
        s.texParameteri(I, s.TEXTURE_MIN_FILTER, s.NEAREST),
        s.texParameteri(I, s.TEXTURE_MAG_FILTER, s.NEAREST);
        for (let qe = 0; qe < j; qe++)
            I === s.TEXTURE_3D || I === s.TEXTURE_2D_ARRAY ? s.texImage3D(se, 0, s.RGBA, 1, 1, Z, 0, s.RGBA, s.UNSIGNED_BYTE, oe) : s.texImage2D(se + qe, 0, s.RGBA, 1, 1, 0, s.RGBA, s.UNSIGNED_BYTE, oe);
        return Pe
    }
    const te = {};
    te[s.TEXTURE_2D] = X(s.TEXTURE_2D, s.TEXTURE_2D, 1),
    te[s.TEXTURE_CUBE_MAP] = X(s.TEXTURE_CUBE_MAP, s.TEXTURE_CUBE_MAP_POSITIVE_X, 6),
    te[s.TEXTURE_2D_ARRAY] = X(s.TEXTURE_2D_ARRAY, s.TEXTURE_2D_ARRAY, 1, 1),
    te[s.TEXTURE_3D] = X(s.TEXTURE_3D, s.TEXTURE_3D, 1, 1),
    i.setClear(0, 0, 0, 1),
    r.setClear(1),
    o.setClear(0),
    ve(s.DEPTH_TEST),
    r.setFunc(dr),
    fe(!1),
    Y(Oa),
    ve(s.CULL_FACE),
    ie(Vn);
    function ve(I) {
        c[I] !== !0 && (s.enable(I),
        c[I] = !0)
    }
    function de(I) {
        c[I] !== !1 && (s.disable(I),
        c[I] = !1)
    }
    function Ae(I, se) {
        return h[I] !== se ? (s.bindFramebuffer(I, se),
        h[I] = se,
        I === s.DRAW_FRAMEBUFFER && (h[s.FRAMEBUFFER] = se),
        I === s.FRAMEBUFFER && (h[s.DRAW_FRAMEBUFFER] = se),
        !0) : !1
    }
    function Ne(I, se) {
        let j = u
          , Z = !1;
        if (I) {
            j = d.get(se),
            j === void 0 && (j = [],
            d.set(se, j));
            const oe = I.textures;
            if (j.length !== oe.length || j[0] !== s.COLOR_ATTACHMENT0) {
                for (let Pe = 0, qe = oe.length; Pe < qe; Pe++)
                    j[Pe] = s.COLOR_ATTACHMENT0 + Pe;
                j.length = oe.length,
                Z = !0
            }
        } else
            j[0] !== s.BACK && (j[0] = s.BACK,
            Z = !0);
        Z && s.drawBuffers(j)
    }
    function Le(I) {
        return f !== I ? (s.useProgram(I),
        f = I,
        !0) : !1
    }
    const Ye = {
        [ei]: s.FUNC_ADD,
        [Eh]: s.FUNC_SUBTRACT,
        [Th]: s.FUNC_REVERSE_SUBTRACT
    };
    Ye[wh] = s.MIN,
    Ye[Ah] = s.MAX;
    const T = {
        [Rh]: s.ZERO,
        [Ch]: s.ONE,
        [Ph]: s.SRC_COLOR,
        [go]: s.SRC_ALPHA,
        [Fh]: s.SRC_ALPHA_SATURATE,
        [Uh]: s.DST_COLOR,
        [Lh]: s.DST_ALPHA,
        [Dh]: s.ONE_MINUS_SRC_COLOR,
        [Mo]: s.ONE_MINUS_SRC_ALPHA,
        [Nh]: s.ONE_MINUS_DST_COLOR,
        [Ih]: s.ONE_MINUS_DST_ALPHA,
        [Oh]: s.CONSTANT_COLOR,
        [Bh]: s.ONE_MINUS_CONSTANT_COLOR,
        [zh]: s.CONSTANT_ALPHA,
        [kh]: s.ONE_MINUS_CONSTANT_ALPHA
    };
    function ie(I, se, j, Z, oe, Pe, qe, ht, yt, Ke) {
        if (I === Vn) {
            g === !0 && (de(s.BLEND),
            g = !1);
            return
        }
        if (g === !1 && (ve(s.BLEND),
        g = !0),
        I !== bh) {
            if (I !== M || Ke !== w) {
                if ((m !== ei || _ !== ei) && (s.blendEquation(s.FUNC_ADD),
                m = ei,
                _ = ei),
                Ke)
                    switch (I) {
                    case Ri:
                        s.blendFuncSeparate(s.ONE, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Ba:
                        s.blendFunc(s.ONE, s.ONE);
                        break;
                    case za:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case ka:
                        s.blendFuncSeparate(s.ZERO, s.SRC_COLOR, s.ZERO, s.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", I);
                        break
                    }
                else
                    switch (I) {
                    case Ri:
                        s.blendFuncSeparate(s.SRC_ALPHA, s.ONE_MINUS_SRC_ALPHA, s.ONE, s.ONE_MINUS_SRC_ALPHA);
                        break;
                    case Ba:
                        s.blendFunc(s.SRC_ALPHA, s.ONE);
                        break;
                    case za:
                        s.blendFuncSeparate(s.ZERO, s.ONE_MINUS_SRC_COLOR, s.ZERO, s.ONE);
                        break;
                    case ka:
                        s.blendFunc(s.ZERO, s.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", I);
                        break
                    }
                p = null,
                E = null,
                v = null,
                L = null,
                P.set(0, 0, 0),
                A = 0,
                M = I,
                w = Ke
            }
            return
        }
        oe = oe || se,
        Pe = Pe || j,
        qe = qe || Z,
        (se !== m || oe !== _) && (s.blendEquationSeparate(Ye[se], Ye[oe]),
        m = se,
        _ = oe),
        (j !== p || Z !== E || Pe !== v || qe !== L) && (s.blendFuncSeparate(T[j], T[Z], T[Pe], T[qe]),
        p = j,
        E = Z,
        v = Pe,
        L = qe),
        (ht.equals(P) === !1 || yt !== A) && (s.blendColor(ht.r, ht.g, ht.b, yt),
        P.copy(ht),
        A = yt),
        M = I,
        w = !1
    }
    function Q(I, se) {
        I.side === Bt ? de(s.CULL_FACE) : ve(s.CULL_FACE);
        let j = I.side === It;
        se && (j = !j),
        fe(j),
        I.blending === Ri && I.transparent === !1 ? ie(Vn) : ie(I.blending, I.blendEquation, I.blendSrc, I.blendDst, I.blendEquationAlpha, I.blendSrcAlpha, I.blendDstAlpha, I.blendColor, I.blendAlpha, I.premultipliedAlpha),
        r.setFunc(I.depthFunc),
        r.setTest(I.depthTest),
        r.setMask(I.depthWrite),
        i.setMask(I.colorWrite);
        const Z = I.stencilWrite;
        o.setTest(Z),
        Z && (o.setMask(I.stencilWriteMask),
        o.setFunc(I.stencilFunc, I.stencilRef, I.stencilFuncMask),
        o.setOp(I.stencilFail, I.stencilZFail, I.stencilZPass)),
        ue(I.polygonOffset, I.polygonOffsetFactor, I.polygonOffsetUnits),
        I.alphaToCoverage === !0 ? ve(s.SAMPLE_ALPHA_TO_COVERAGE) : de(s.SAMPLE_ALPHA_TO_COVERAGE)
    }
    function fe(I) {
        S !== I && (I ? s.frontFace(s.CW) : s.frontFace(s.CCW),
        S = I)
    }
    function Y(I) {
        I !== yh ? (ve(s.CULL_FACE),
        I !== y && (I === Oa ? s.cullFace(s.BACK) : I === Sh ? s.cullFace(s.FRONT) : s.cullFace(s.FRONT_AND_BACK))) : de(s.CULL_FACE),
        y = I
    }
    function Re(I) {
        I !== D && (V && s.lineWidth(I),
        D = I)
    }
    function ue(I, se, j) {
        I ? (ve(s.POLYGON_OFFSET_FILL),
        (G !== se || F !== j) && (s.polygonOffset(se, j),
        G = se,
        F = j)) : de(s.POLYGON_OFFSET_FILL)
    }
    function _e(I) {
        I ? ve(s.SCISSOR_TEST) : de(s.SCISSOR_TEST)
    }
    function R(I) {
        I === void 0 && (I = s.TEXTURE0 + O - 1),
        W !== I && (s.activeTexture(I),
        W = I)
    }
    function x(I, se, j) {
        j === void 0 && (W === null ? j = s.TEXTURE0 + O - 1 : j = W);
        let Z = ae[j];
        Z === void 0 && (Z = {
            type: void 0,
            texture: void 0
        },
        ae[j] = Z),
        (Z.type !== I || Z.texture !== se) && (W !== j && (s.activeTexture(j),
        W = j),
        s.bindTexture(I, se || te[I]),
        Z.type = I,
        Z.texture = se)
    }
    function k() {
        const I = ae[W];
        I !== void 0 && I.type !== void 0 && (s.bindTexture(I.type, null),
        I.type = void 0,
        I.texture = void 0)
    }
    function $() {
        try {
            s.compressedTexImage2D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function K() {
        try {
            s.compressedTexImage3D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function J() {
        try {
            s.texSubImage2D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function we() {
        try {
            s.texSubImage3D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function ce() {
        try {
            s.compressedTexSubImage2D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Me() {
        try {
            s.compressedTexSubImage3D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Be() {
        try {
            s.texStorage2D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function ne() {
        try {
            s.texStorage3D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function ge() {
        try {
            s.texImage2D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Xe() {
        try {
            s.texImage3D.apply(s, arguments)
        } catch (I) {
            console.error("THREE.WebGLState:", I)
        }
    }
    function Ue(I) {
        Ce.equals(I) === !1 && (s.scissor(I.x, I.y, I.z, I.w),
        Ce.copy(I))
    }
    function xe(I) {
        ze.equals(I) === !1 && (s.viewport(I.x, I.y, I.z, I.w),
        ze.copy(I))
    }
    function Fe(I, se) {
        let j = l.get(se);
        j === void 0 && (j = new WeakMap,
        l.set(se, j));
        let Z = j.get(I);
        Z === void 0 && (Z = s.getUniformBlockIndex(se, I.name),
        j.set(I, Z))
    }
    function Ge(I, se) {
        const Z = l.get(se).get(I);
        a.get(se) !== Z && (s.uniformBlockBinding(se, Z, I.__bindingPointIndex),
        a.set(se, Z))
    }
    function rt() {
        s.disable(s.BLEND),
        s.disable(s.CULL_FACE),
        s.disable(s.DEPTH_TEST),
        s.disable(s.POLYGON_OFFSET_FILL),
        s.disable(s.SCISSOR_TEST),
        s.disable(s.STENCIL_TEST),
        s.disable(s.SAMPLE_ALPHA_TO_COVERAGE),
        s.blendEquation(s.FUNC_ADD),
        s.blendFunc(s.ONE, s.ZERO),
        s.blendFuncSeparate(s.ONE, s.ZERO, s.ONE, s.ZERO),
        s.blendColor(0, 0, 0, 0),
        s.colorMask(!0, !0, !0, !0),
        s.clearColor(0, 0, 0, 0),
        s.depthMask(!0),
        s.depthFunc(s.LESS),
        s.clearDepth(1),
        s.stencilMask(4294967295),
        s.stencilFunc(s.ALWAYS, 0, 4294967295),
        s.stencilOp(s.KEEP, s.KEEP, s.KEEP),
        s.clearStencil(0),
        s.cullFace(s.BACK),
        s.frontFace(s.CCW),
        s.polygonOffset(0, 0),
        s.activeTexture(s.TEXTURE0),
        s.bindFramebuffer(s.FRAMEBUFFER, null),
        s.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
        s.bindFramebuffer(s.READ_FRAMEBUFFER, null),
        s.useProgram(null),
        s.lineWidth(1),
        s.scissor(0, 0, s.canvas.width, s.canvas.height),
        s.viewport(0, 0, s.canvas.width, s.canvas.height),
        c = {},
        W = null,
        ae = {},
        h = {},
        d = new WeakMap,
        u = [],
        f = null,
        g = !1,
        M = null,
        m = null,
        p = null,
        E = null,
        _ = null,
        v = null,
        L = null,
        P = new be(0,0,0),
        A = 0,
        w = !1,
        S = null,
        y = null,
        D = null,
        G = null,
        F = null,
        Ce.set(0, 0, s.canvas.width, s.canvas.height),
        ze.set(0, 0, s.canvas.width, s.canvas.height),
        i.reset(),
        r.reset(),
        o.reset()
    }
    return {
        buffers: {
            color: i,
            depth: r,
            stencil: o
        },
        enable: ve,
        disable: de,
        bindFramebuffer: Ae,
        drawBuffers: Ne,
        useProgram: Le,
        setBlending: ie,
        setMaterial: Q,
        setFlipSided: fe,
        setCullFace: Y,
        setLineWidth: Re,
        setPolygonOffset: ue,
        setScissorTest: _e,
        activeTexture: R,
        bindTexture: x,
        unbindTexture: k,
        compressedTexImage2D: $,
        compressedTexImage3D: K,
        texImage2D: ge,
        texImage3D: Xe,
        updateUBOMapping: Fe,
        uniformBlockBinding: Ge,
        texStorage2D: Be,
        texStorage3D: ne,
        texSubImage2D: J,
        texSubImage3D: we,
        compressedTexSubImage2D: ce,
        compressedTexSubImage3D: Me,
        scissor: Ue,
        viewport: xe,
        reset: rt
    }
}
function Nl(s, e, t, n) {
    const i = wg(n);
    switch (t) {
    case Rc:
        return s * e;
    case Pc:
        return s * e;
    case Dc:
        return s * e * 2;
    case aa:
        return s * e / i.components * i.byteLength;
    case la:
        return s * e / i.components * i.byteLength;
    case Lc:
        return s * e * 2 / i.components * i.byteLength;
    case ca:
        return s * e * 2 / i.components * i.byteLength;
    case Cc:
        return s * e * 3 / i.components * i.byteLength;
    case Gt:
        return s * e * 4 / i.components * i.byteLength;
    case ha:
        return s * e * 4 / i.components * i.byteLength;
    case sr:
    case rr:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case or:
    case ar:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case yo:
    case bo:
        return Math.max(s, 16) * Math.max(e, 8) / 4;
    case xo:
    case So:
        return Math.max(s, 8) * Math.max(e, 8) / 2;
    case Eo:
    case To:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 8;
    case wo:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ao:
        return Math.floor((s + 3) / 4) * Math.floor((e + 3) / 4) * 16;
    case Ro:
        return Math.floor((s + 4) / 5) * Math.floor((e + 3) / 4) * 16;
    case Co:
        return Math.floor((s + 4) / 5) * Math.floor((e + 4) / 5) * 16;
    case Po:
        return Math.floor((s + 5) / 6) * Math.floor((e + 4) / 5) * 16;
    case Do:
        return Math.floor((s + 5) / 6) * Math.floor((e + 5) / 6) * 16;
    case Lo:
        return Math.floor((s + 7) / 8) * Math.floor((e + 4) / 5) * 16;
    case Io:
        return Math.floor((s + 7) / 8) * Math.floor((e + 5) / 6) * 16;
    case Uo:
        return Math.floor((s + 7) / 8) * Math.floor((e + 7) / 8) * 16;
    case No:
        return Math.floor((s + 9) / 10) * Math.floor((e + 4) / 5) * 16;
    case Fo:
        return Math.floor((s + 9) / 10) * Math.floor((e + 5) / 6) * 16;
    case Oo:
        return Math.floor((s + 9) / 10) * Math.floor((e + 7) / 8) * 16;
    case Bo:
        return Math.floor((s + 9) / 10) * Math.floor((e + 9) / 10) * 16;
    case zo:
        return Math.floor((s + 11) / 12) * Math.floor((e + 9) / 10) * 16;
    case ko:
        return Math.floor((s + 11) / 12) * Math.floor((e + 11) / 12) * 16;
    case lr:
    case Ho:
    case Go:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16;
    case Ic:
    case Vo:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 8;
    case Wo:
    case Xo:
        return Math.ceil(s / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}
function wg(s) {
    switch (s) {
    case Cn:
    case Tc:
        return {
            byteLength: 1,
            components: 1
        };
    case hs:
    case wc:
    case on:
        return {
            byteLength: 2,
            components: 1
        };
    case ra:
    case oa:
        return {
            byteLength: 2,
            components: 4
        };
    case ni:
    case sa:
    case Pt:
        return {
            byteLength: 4,
            components: 1
        };
    case Ac:
        return {
            byteLength: 4,
            components: 3
        }
    }
    throw new Error(`Unknown texture type ${s}.`)
}
function Ag(s, e, t, n, i, r, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null
      , l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent)
      , c = new ee
      , h = new WeakMap;
    let d;
    const u = new WeakMap;
    let f = !1;
    try {
        f = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") !== null
    } catch {}
    function g(R, x) {
        return f ? new OffscreenCanvas(R,x) : ps("canvas")
    }
    function M(R, x, k) {
        let $ = 1;
        const K = _e(R);
        if ((K.width > k || K.height > k) && ($ = k / Math.max(K.width, K.height)),
        $ < 1)
            if (typeof HTMLImageElement < "u" && R instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && R instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && R instanceof ImageBitmap || typeof VideoFrame < "u" && R instanceof VideoFrame) {
                const J = Math.floor($ * K.width)
                  , we = Math.floor($ * K.height);
                d === void 0 && (d = g(J, we));
                const ce = x ? g(J, we) : d;
                return ce.width = J,
                ce.height = we,
                ce.getContext("2d").drawImage(R, 0, 0, J, we),
                console.warn("THREE.WebGLRenderer: Texture has been resized from (" + K.width + "x" + K.height + ") to (" + J + "x" + we + ")."),
                ce
            } else
                return "data"in R && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + K.width + "x" + K.height + ")."),
                R;
        return R
    }
    function m(R) {
        return R.generateMipmaps && R.minFilter !== Ct && R.minFilter !== _t
    }
    function p(R) {
        s.generateMipmap(R)
    }
    function E(R, x, k, $, K=!1) {
        if (R !== null) {
            if (s[R] !== void 0)
                return s[R];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + R + "'")
        }
        let J = x;
        if (x === s.RED && (k === s.FLOAT && (J = s.R32F),
        k === s.HALF_FLOAT && (J = s.R16F),
        k === s.UNSIGNED_BYTE && (J = s.R8)),
        x === s.RED_INTEGER && (k === s.UNSIGNED_BYTE && (J = s.R8UI),
        k === s.UNSIGNED_SHORT && (J = s.R16UI),
        k === s.UNSIGNED_INT && (J = s.R32UI),
        k === s.BYTE && (J = s.R8I),
        k === s.SHORT && (J = s.R16I),
        k === s.INT && (J = s.R32I)),
        x === s.RG && (k === s.FLOAT && (J = s.RG32F),
        k === s.HALF_FLOAT && (J = s.RG16F),
        k === s.UNSIGNED_BYTE && (J = s.RG8)),
        x === s.RG_INTEGER && (k === s.UNSIGNED_BYTE && (J = s.RG8UI),
        k === s.UNSIGNED_SHORT && (J = s.RG16UI),
        k === s.UNSIGNED_INT && (J = s.RG32UI),
        k === s.BYTE && (J = s.RG8I),
        k === s.SHORT && (J = s.RG16I),
        k === s.INT && (J = s.RG32I)),
        x === s.RGB && k === s.UNSIGNED_INT_5_9_9_9_REV && (J = s.RGB9_E5),
        x === s.RGBA) {
            const we = K ? fr : je.getTransfer($);
            k === s.FLOAT && (J = s.RGBA32F),
            k === s.HALF_FLOAT && (J = s.RGBA16F),
            k === s.UNSIGNED_BYTE && (J = we === st ? s.SRGB8_ALPHA8 : s.RGBA8),
            k === s.UNSIGNED_SHORT_4_4_4_4 && (J = s.RGBA4),
            k === s.UNSIGNED_SHORT_5_5_5_1 && (J = s.RGB5_A1)
        }
        return (J === s.R16F || J === s.R32F || J === s.RG16F || J === s.RG32F || J === s.RGBA16F || J === s.RGBA32F) && e.get("EXT_color_buffer_float"),
        J
    }
    function _(R, x) {
        let k;
        return R ? x === null || x === ni || x === Oi ? k = s.DEPTH24_STENCIL8 : x === Pt ? k = s.DEPTH32F_STENCIL8 : x === hs && (k = s.DEPTH24_STENCIL8,
        console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : x === null || x === ni || x === Oi ? k = s.DEPTH_COMPONENT24 : x === Pt ? k = s.DEPTH_COMPONENT32F : x === hs && (k = s.DEPTH_COMPONENT16),
        k
    }
    function v(R, x) {
        return m(R) === !0 || R.isFramebufferTexture && R.minFilter !== Ct && R.minFilter !== _t ? Math.log2(Math.max(x.width, x.height)) + 1 : R.mipmaps !== void 0 && R.mipmaps.length > 0 ? R.mipmaps.length : R.isCompressedTexture && Array.isArray(R.image) ? x.mipmaps.length : 1
    }
    function L(R) {
        const x = R.target;
        x.removeEventListener("dispose", L),
        A(x),
        x.isVideoTexture && h.delete(x)
    }
    function P(R) {
        const x = R.target;
        x.removeEventListener("dispose", P),
        S(x)
    }
    function A(R) {
        const x = n.get(R);
        if (x.__webglInit === void 0)
            return;
        const k = R.source
          , $ = u.get(k);
        if ($) {
            const K = $[x.__cacheKey];
            K.usedTimes--,
            K.usedTimes === 0 && w(R),
            Object.keys($).length === 0 && u.delete(k)
        }
        n.remove(R)
    }
    function w(R) {
        const x = n.get(R);
        s.deleteTexture(x.__webglTexture);
        const k = R.source
          , $ = u.get(k);
        delete $[x.__cacheKey],
        o.memory.textures--
    }
    function S(R) {
        const x = n.get(R);
        if (R.depthTexture && R.depthTexture.dispose(),
        R.isWebGLCubeRenderTarget)
            for (let $ = 0; $ < 6; $++) {
                if (Array.isArray(x.__webglFramebuffer[$]))
                    for (let K = 0; K < x.__webglFramebuffer[$].length; K++)
                        s.deleteFramebuffer(x.__webglFramebuffer[$][K]);
                else
                    s.deleteFramebuffer(x.__webglFramebuffer[$]);
                x.__webglDepthbuffer && s.deleteRenderbuffer(x.__webglDepthbuffer[$])
            }
        else {
            if (Array.isArray(x.__webglFramebuffer))
                for (let $ = 0; $ < x.__webglFramebuffer.length; $++)
                    s.deleteFramebuffer(x.__webglFramebuffer[$]);
            else
                s.deleteFramebuffer(x.__webglFramebuffer);
            if (x.__webglDepthbuffer && s.deleteRenderbuffer(x.__webglDepthbuffer),
            x.__webglMultisampledFramebuffer && s.deleteFramebuffer(x.__webglMultisampledFramebuffer),
            x.__webglColorRenderbuffer)
                for (let $ = 0; $ < x.__webglColorRenderbuffer.length; $++)
                    x.__webglColorRenderbuffer[$] && s.deleteRenderbuffer(x.__webglColorRenderbuffer[$]);
            x.__webglDepthRenderbuffer && s.deleteRenderbuffer(x.__webglDepthRenderbuffer)
        }
        const k = R.textures;
        for (let $ = 0, K = k.length; $ < K; $++) {
            const J = n.get(k[$]);
            J.__webglTexture && (s.deleteTexture(J.__webglTexture),
            o.memory.textures--),
            n.remove(k[$])
        }
        n.remove(R)
    }
    let y = 0;
    function D() {
        y = 0
    }
    function G() {
        const R = y;
        return R >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + R + " texture units while this GPU supports only " + i.maxTextures),
        y += 1,
        R
    }
    function F(R) {
        const x = [];
        return x.push(R.wrapS),
        x.push(R.wrapT),
        x.push(R.wrapR || 0),
        x.push(R.magFilter),
        x.push(R.minFilter),
        x.push(R.anisotropy),
        x.push(R.internalFormat),
        x.push(R.format),
        x.push(R.type),
        x.push(R.generateMipmaps),
        x.push(R.premultiplyAlpha),
        x.push(R.flipY),
        x.push(R.unpackAlignment),
        x.push(R.colorSpace),
        x.join()
    }
    function O(R, x) {
        const k = n.get(R);
        if (R.isVideoTexture && Re(R),
        R.isRenderTargetTexture === !1 && R.version > 0 && k.__version !== R.version) {
            const $ = R.image;
            if ($ === null)
                console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if ($.complete === !1)
                console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                ze(k, R, x);
                return
            }
        }
        t.bindTexture(s.TEXTURE_2D, k.__webglTexture, s.TEXTURE0 + x)
    }
    function V(R, x) {
        const k = n.get(R);
        if (R.version > 0 && k.__version !== R.version) {
            ze(k, R, x);
            return
        }
        t.bindTexture(s.TEXTURE_2D_ARRAY, k.__webglTexture, s.TEXTURE0 + x)
    }
    function B(R, x) {
        const k = n.get(R);
        if (R.version > 0 && k.__version !== R.version) {
            ze(k, R, x);
            return
        }
        t.bindTexture(s.TEXTURE_3D, k.__webglTexture, s.TEXTURE0 + x)
    }
    function q(R, x) {
        const k = n.get(R);
        if (R.version > 0 && k.__version !== R.version) {
            X(k, R, x);
            return
        }
        t.bindTexture(s.TEXTURE_CUBE_MAP, k.__webglTexture, s.TEXTURE0 + x)
    }
    const W = {
        [Fi]: s.REPEAT,
        [sn]: s.CLAMP_TO_EDGE,
        [ur]: s.MIRRORED_REPEAT
    }
      , ae = {
        [Ct]: s.NEAREST,
        [Ec]: s.NEAREST_MIPMAP_NEAREST,
        [is]: s.NEAREST_MIPMAP_LINEAR,
        [_t]: s.LINEAR,
        [ir]: s.LINEAR_MIPMAP_NEAREST,
        [rn]: s.LINEAR_MIPMAP_LINEAR
    }
      , le = {
        [nd]: s.NEVER,
        [ld]: s.ALWAYS,
        [id]: s.LESS,
        [Fc]: s.LEQUAL,
        [sd]: s.EQUAL,
        [ad]: s.GEQUAL,
        [rd]: s.GREATER,
        [od]: s.NOTEQUAL
    };
    function me(R, x) {
        if (x.type === Pt && e.has("OES_texture_float_linear") === !1 && (x.magFilter === _t || x.magFilter === ir || x.magFilter === is || x.magFilter === rn || x.minFilter === _t || x.minFilter === ir || x.minFilter === is || x.minFilter === rn) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."),
        s.texParameteri(R, s.TEXTURE_WRAP_S, W[x.wrapS]),
        s.texParameteri(R, s.TEXTURE_WRAP_T, W[x.wrapT]),
        (R === s.TEXTURE_3D || R === s.TEXTURE_2D_ARRAY) && s.texParameteri(R, s.TEXTURE_WRAP_R, W[x.wrapR]),
        s.texParameteri(R, s.TEXTURE_MAG_FILTER, ae[x.magFilter]),
        s.texParameteri(R, s.TEXTURE_MIN_FILTER, ae[x.minFilter]),
        x.compareFunction && (s.texParameteri(R, s.TEXTURE_COMPARE_MODE, s.COMPARE_REF_TO_TEXTURE),
        s.texParameteri(R, s.TEXTURE_COMPARE_FUNC, le[x.compareFunction])),
        e.has("EXT_texture_filter_anisotropic") === !0) {
            if (x.magFilter === Ct || x.minFilter !== is && x.minFilter !== rn || x.type === Pt && e.has("OES_texture_float_linear") === !1)
                return;
            if (x.anisotropy > 1 || n.get(x).__currentAnisotropy) {
                const k = e.get("EXT_texture_filter_anisotropic");
                s.texParameterf(R, k.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(x.anisotropy, i.getMaxAnisotropy())),
                n.get(x).__currentAnisotropy = x.anisotropy
            }
        }
    }
    function Ce(R, x) {
        let k = !1;
        R.__webglInit === void 0 && (R.__webglInit = !0,
        x.addEventListener("dispose", L));
        const $ = x.source;
        let K = u.get($);
        K === void 0 && (K = {},
        u.set($, K));
        const J = F(x);
        if (J !== R.__cacheKey) {
            K[J] === void 0 && (K[J] = {
                texture: s.createTexture(),
                usedTimes: 0
            },
            o.memory.textures++,
            k = !0),
            K[J].usedTimes++;
            const we = K[R.__cacheKey];
            we !== void 0 && (K[R.__cacheKey].usedTimes--,
            we.usedTimes === 0 && w(x)),
            R.__cacheKey = J,
            R.__webglTexture = K[J].texture
        }
        return k
    }
    function ze(R, x, k) {
        let $ = s.TEXTURE_2D;
        (x.isDataArrayTexture || x.isCompressedArrayTexture) && ($ = s.TEXTURE_2D_ARRAY),
        x.isData3DTexture && ($ = s.TEXTURE_3D);
        const K = Ce(R, x)
          , J = x.source;
        t.bindTexture($, R.__webglTexture, s.TEXTURE0 + k);
        const we = n.get(J);
        if (J.version !== we.__version || K === !0) {
            t.activeTexture(s.TEXTURE0 + k);
            const ce = je.getPrimaries(je.workingColorSpace)
              , Me = x.colorSpace === Hn ? null : je.getPrimaries(x.colorSpace)
              , Be = x.colorSpace === Hn || ce === Me ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, x.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, x.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Be);
            let ne = M(x.image, !1, i.maxTextureSize);
            ne = ue(x, ne);
            const ge = r.convert(x.format, x.colorSpace)
              , Xe = r.convert(x.type);
            let Ue = E(x.internalFormat, ge, Xe, x.colorSpace, x.isVideoTexture);
            me($, x);
            let xe;
            const Fe = x.mipmaps
              , Ge = x.isVideoTexture !== !0
              , rt = we.__version === void 0 || K === !0
              , I = J.dataReady
              , se = v(x, ne);
            if (x.isDepthTexture)
                Ue = _(x.format === Bi, x.type),
                rt && (Ge ? t.texStorage2D(s.TEXTURE_2D, 1, Ue, ne.width, ne.height) : t.texImage2D(s.TEXTURE_2D, 0, Ue, ne.width, ne.height, 0, ge, Xe, null));
            else if (x.isDataTexture)
                if (Fe.length > 0) {
                    Ge && rt && t.texStorage2D(s.TEXTURE_2D, se, Ue, Fe[0].width, Fe[0].height);
                    for (let j = 0, Z = Fe.length; j < Z; j++)
                        xe = Fe[j],
                        Ge ? I && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, xe.width, xe.height, ge, Xe, xe.data) : t.texImage2D(s.TEXTURE_2D, j, Ue, xe.width, xe.height, 0, ge, Xe, xe.data);
                    x.generateMipmaps = !1
                } else
                    Ge ? (rt && t.texStorage2D(s.TEXTURE_2D, se, Ue, ne.width, ne.height),
                    I && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ne.width, ne.height, ge, Xe, ne.data)) : t.texImage2D(s.TEXTURE_2D, 0, Ue, ne.width, ne.height, 0, ge, Xe, ne.data);
            else if (x.isCompressedTexture)
                if (x.isCompressedArrayTexture) {
                    Ge && rt && t.texStorage3D(s.TEXTURE_2D_ARRAY, se, Ue, Fe[0].width, Fe[0].height, ne.depth);
                    for (let j = 0, Z = Fe.length; j < Z; j++)
                        if (xe = Fe[j],
                        x.format !== Gt)
                            if (ge !== null)
                                if (Ge) {
                                    if (I)
                                        if (x.layerUpdates.size > 0) {
                                            const oe = Nl(xe.width, xe.height, x.format, x.type);
                                            for (const Pe of x.layerUpdates) {
                                                const qe = xe.data.subarray(Pe * oe / xe.data.BYTES_PER_ELEMENT, (Pe + 1) * oe / xe.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, Pe, xe.width, xe.height, 1, ge, qe, 0, 0)
                                            }
                                            x.clearLayerUpdates()
                                        } else
                                            t.compressedTexSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, xe.width, xe.height, ne.depth, ge, xe.data, 0, 0)
                                } else
                                    t.compressedTexImage3D(s.TEXTURE_2D_ARRAY, j, Ue, xe.width, xe.height, ne.depth, 0, xe.data, 0, 0);
                            else
                                console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                        else
                            Ge ? I && t.texSubImage3D(s.TEXTURE_2D_ARRAY, j, 0, 0, 0, xe.width, xe.height, ne.depth, ge, Xe, xe.data) : t.texImage3D(s.TEXTURE_2D_ARRAY, j, Ue, xe.width, xe.height, ne.depth, 0, ge, Xe, xe.data)
                } else {
                    Ge && rt && t.texStorage2D(s.TEXTURE_2D, se, Ue, Fe[0].width, Fe[0].height);
                    for (let j = 0, Z = Fe.length; j < Z; j++)
                        xe = Fe[j],
                        x.format !== Gt ? ge !== null ? Ge ? I && t.compressedTexSubImage2D(s.TEXTURE_2D, j, 0, 0, xe.width, xe.height, ge, xe.data) : t.compressedTexImage2D(s.TEXTURE_2D, j, Ue, xe.width, xe.height, 0, xe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : Ge ? I && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, xe.width, xe.height, ge, Xe, xe.data) : t.texImage2D(s.TEXTURE_2D, j, Ue, xe.width, xe.height, 0, ge, Xe, xe.data)
                }
            else if (x.isDataArrayTexture)
                if (Ge) {
                    if (rt && t.texStorage3D(s.TEXTURE_2D_ARRAY, se, Ue, ne.width, ne.height, ne.depth),
                    I)
                        if (x.layerUpdates.size > 0) {
                            const j = Nl(ne.width, ne.height, x.format, x.type);
                            for (const Z of x.layerUpdates) {
                                const oe = ne.data.subarray(Z * j / ne.data.BYTES_PER_ELEMENT, (Z + 1) * j / ne.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, Z, ne.width, ne.height, 1, ge, Xe, oe)
                            }
                            x.clearLayerUpdates()
                        } else
                            t.texSubImage3D(s.TEXTURE_2D_ARRAY, 0, 0, 0, 0, ne.width, ne.height, ne.depth, ge, Xe, ne.data)
                } else
                    t.texImage3D(s.TEXTURE_2D_ARRAY, 0, Ue, ne.width, ne.height, ne.depth, 0, ge, Xe, ne.data);
            else if (x.isData3DTexture)
                Ge ? (rt && t.texStorage3D(s.TEXTURE_3D, se, Ue, ne.width, ne.height, ne.depth),
                I && t.texSubImage3D(s.TEXTURE_3D, 0, 0, 0, 0, ne.width, ne.height, ne.depth, ge, Xe, ne.data)) : t.texImage3D(s.TEXTURE_3D, 0, Ue, ne.width, ne.height, ne.depth, 0, ge, Xe, ne.data);
            else if (x.isFramebufferTexture) {
                if (rt)
                    if (Ge)
                        t.texStorage2D(s.TEXTURE_2D, se, Ue, ne.width, ne.height);
                    else {
                        let j = ne.width
                          , Z = ne.height;
                        for (let oe = 0; oe < se; oe++)
                            t.texImage2D(s.TEXTURE_2D, oe, Ue, j, Z, 0, ge, Xe, null),
                            j >>= 1,
                            Z >>= 1
                    }
            } else if (Fe.length > 0) {
                if (Ge && rt) {
                    const j = _e(Fe[0]);
                    t.texStorage2D(s.TEXTURE_2D, se, Ue, j.width, j.height)
                }
                for (let j = 0, Z = Fe.length; j < Z; j++)
                    xe = Fe[j],
                    Ge ? I && t.texSubImage2D(s.TEXTURE_2D, j, 0, 0, ge, Xe, xe) : t.texImage2D(s.TEXTURE_2D, j, Ue, ge, Xe, xe);
                x.generateMipmaps = !1
            } else if (Ge) {
                if (rt) {
                    const j = _e(ne);
                    t.texStorage2D(s.TEXTURE_2D, se, Ue, j.width, j.height)
                }
                I && t.texSubImage2D(s.TEXTURE_2D, 0, 0, 0, ge, Xe, ne)
            } else
                t.texImage2D(s.TEXTURE_2D, 0, Ue, ge, Xe, ne);
            m(x) && p($),
            we.__version = J.version,
            x.onUpdate && x.onUpdate(x)
        }
        R.__version = x.version
    }
    function X(R, x, k) {
        if (x.image.length !== 6)
            return;
        const $ = Ce(R, x)
          , K = x.source;
        t.bindTexture(s.TEXTURE_CUBE_MAP, R.__webglTexture, s.TEXTURE0 + k);
        const J = n.get(K);
        if (K.version !== J.__version || $ === !0) {
            t.activeTexture(s.TEXTURE0 + k);
            const we = je.getPrimaries(je.workingColorSpace)
              , ce = x.colorSpace === Hn ? null : je.getPrimaries(x.colorSpace)
              , Me = x.colorSpace === Hn || we === ce ? s.NONE : s.BROWSER_DEFAULT_WEBGL;
            s.pixelStorei(s.UNPACK_FLIP_Y_WEBGL, x.flipY),
            s.pixelStorei(s.UNPACK_PREMULTIPLY_ALPHA_WEBGL, x.premultiplyAlpha),
            s.pixelStorei(s.UNPACK_ALIGNMENT, x.unpackAlignment),
            s.pixelStorei(s.UNPACK_COLORSPACE_CONVERSION_WEBGL, Me);
            const Be = x.isCompressedTexture || x.image[0].isCompressedTexture
              , ne = x.image[0] && x.image[0].isDataTexture
              , ge = [];
            for (let Z = 0; Z < 6; Z++)
                !Be && !ne ? ge[Z] = M(x.image[Z], !0, i.maxCubemapSize) : ge[Z] = ne ? x.image[Z].image : x.image[Z],
                ge[Z] = ue(x, ge[Z]);
            const Xe = ge[0]
              , Ue = r.convert(x.format, x.colorSpace)
              , xe = r.convert(x.type)
              , Fe = E(x.internalFormat, Ue, xe, x.colorSpace)
              , Ge = x.isVideoTexture !== !0
              , rt = J.__version === void 0 || $ === !0
              , I = K.dataReady;
            let se = v(x, Xe);
            me(s.TEXTURE_CUBE_MAP, x);
            let j;
            if (Be) {
                Ge && rt && t.texStorage2D(s.TEXTURE_CUBE_MAP, se, Fe, Xe.width, Xe.height);
                for (let Z = 0; Z < 6; Z++) {
                    j = ge[Z].mipmaps;
                    for (let oe = 0; oe < j.length; oe++) {
                        const Pe = j[oe];
                        x.format !== Gt ? Ue !== null ? Ge ? I && t.compressedTexSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe, 0, 0, Pe.width, Pe.height, Ue, Pe.data) : t.compressedTexImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe, Fe, Pe.width, Pe.height, 0, Pe.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : Ge ? I && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe, 0, 0, Pe.width, Pe.height, Ue, xe, Pe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe, Fe, Pe.width, Pe.height, 0, Ue, xe, Pe.data)
                    }
                }
            } else {
                if (j = x.mipmaps,
                Ge && rt) {
                    j.length > 0 && se++;
                    const Z = _e(ge[0]);
                    t.texStorage2D(s.TEXTURE_CUBE_MAP, se, Fe, Z.width, Z.height)
                }
                for (let Z = 0; Z < 6; Z++)
                    if (ne) {
                        Ge ? I && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, ge[Z].width, ge[Z].height, Ue, xe, ge[Z].data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Fe, ge[Z].width, ge[Z].height, 0, Ue, xe, ge[Z].data);
                        for (let oe = 0; oe < j.length; oe++) {
                            const qe = j[oe].image[Z].image;
                            Ge ? I && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe + 1, 0, 0, qe.width, qe.height, Ue, xe, qe.data) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe + 1, Fe, qe.width, qe.height, 0, Ue, xe, qe.data)
                        }
                    } else {
                        Ge ? I && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, 0, 0, Ue, xe, ge[Z]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, 0, Fe, Ue, xe, ge[Z]);
                        for (let oe = 0; oe < j.length; oe++) {
                            const Pe = j[oe];
                            Ge ? I && t.texSubImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe + 1, 0, 0, Ue, xe, Pe.image[Z]) : t.texImage2D(s.TEXTURE_CUBE_MAP_POSITIVE_X + Z, oe + 1, Fe, Ue, xe, Pe.image[Z])
                        }
                    }
            }
            m(x) && p(s.TEXTURE_CUBE_MAP),
            J.__version = K.version,
            x.onUpdate && x.onUpdate(x)
        }
        R.__version = x.version
    }
    function te(R, x, k, $, K, J) {
        const we = r.convert(k.format, k.colorSpace)
          , ce = r.convert(k.type)
          , Me = E(k.internalFormat, we, ce, k.colorSpace);
        if (!n.get(x).__hasExternalTextures) {
            const ne = Math.max(1, x.width >> J)
              , ge = Math.max(1, x.height >> J);
            K === s.TEXTURE_3D || K === s.TEXTURE_2D_ARRAY ? t.texImage3D(K, J, Me, ne, ge, x.depth, 0, we, ce, null) : t.texImage2D(K, J, Me, ne, ge, 0, we, ce, null)
        }
        t.bindFramebuffer(s.FRAMEBUFFER, R),
        Y(x) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, $, K, n.get(k).__webglTexture, 0, fe(x)) : (K === s.TEXTURE_2D || K >= s.TEXTURE_CUBE_MAP_POSITIVE_X && K <= s.TEXTURE_CUBE_MAP_NEGATIVE_Z) && s.framebufferTexture2D(s.FRAMEBUFFER, $, K, n.get(k).__webglTexture, J),
        t.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function ve(R, x, k) {
        if (s.bindRenderbuffer(s.RENDERBUFFER, R),
        x.depthBuffer) {
            const $ = x.depthTexture
              , K = $ && $.isDepthTexture ? $.type : null
              , J = _(x.stencilBuffer, K)
              , we = x.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
              , ce = fe(x);
            Y(x) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, ce, J, x.width, x.height) : k ? s.renderbufferStorageMultisample(s.RENDERBUFFER, ce, J, x.width, x.height) : s.renderbufferStorage(s.RENDERBUFFER, J, x.width, x.height),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, we, s.RENDERBUFFER, R)
        } else {
            const $ = x.textures;
            for (let K = 0; K < $.length; K++) {
                const J = $[K]
                  , we = r.convert(J.format, J.colorSpace)
                  , ce = r.convert(J.type)
                  , Me = E(J.internalFormat, we, ce, J.colorSpace)
                  , Be = fe(x);
                k && Y(x) === !1 ? s.renderbufferStorageMultisample(s.RENDERBUFFER, Be, Me, x.width, x.height) : Y(x) ? a.renderbufferStorageMultisampleEXT(s.RENDERBUFFER, Be, Me, x.width, x.height) : s.renderbufferStorage(s.RENDERBUFFER, Me, x.width, x.height)
            }
        }
        s.bindRenderbuffer(s.RENDERBUFFER, null)
    }
    function de(R, x) {
        if (x && x.isWebGLCubeRenderTarget)
            throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(s.FRAMEBUFFER, R),
        !(x.depthTexture && x.depthTexture.isDepthTexture))
            throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        (!n.get(x.depthTexture).__webglTexture || x.depthTexture.image.width !== x.width || x.depthTexture.image.height !== x.height) && (x.depthTexture.image.width = x.width,
        x.depthTexture.image.height = x.height,
        x.depthTexture.needsUpdate = !0),
        O(x.depthTexture, 0);
        const $ = n.get(x.depthTexture).__webglTexture
          , K = fe(x);
        if (x.depthTexture.format === Ci)
            Y(x) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, $, 0, K) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_ATTACHMENT, s.TEXTURE_2D, $, 0);
        else if (x.depthTexture.format === Bi)
            Y(x) ? a.framebufferTexture2DMultisampleEXT(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, $, 0, K) : s.framebufferTexture2D(s.FRAMEBUFFER, s.DEPTH_STENCIL_ATTACHMENT, s.TEXTURE_2D, $, 0);
        else
            throw new Error("Unknown depthTexture format")
    }
    function Ae(R) {
        const x = n.get(R)
          , k = R.isWebGLCubeRenderTarget === !0;
        if (x.__boundDepthTexture !== R.depthTexture) {
            const $ = R.depthTexture;
            if (x.__depthDisposeCallback && x.__depthDisposeCallback(),
            $) {
                const K = () => {
                    delete x.__boundDepthTexture,
                    delete x.__depthDisposeCallback,
                    $.removeEventListener("dispose", K)
                }
                ;
                $.addEventListener("dispose", K),
                x.__depthDisposeCallback = K
            }
            x.__boundDepthTexture = $
        }
        if (R.depthTexture && !x.__autoAllocateDepthBuffer) {
            if (k)
                throw new Error("target.depthTexture not supported in Cube render targets");
            de(x.__webglFramebuffer, R)
        } else if (k) {
            x.__webglDepthbuffer = [];
            for (let $ = 0; $ < 6; $++)
                if (t.bindFramebuffer(s.FRAMEBUFFER, x.__webglFramebuffer[$]),
                x.__webglDepthbuffer[$] === void 0)
                    x.__webglDepthbuffer[$] = s.createRenderbuffer(),
                    ve(x.__webglDepthbuffer[$], R, !1);
                else {
                    const K = R.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                      , J = x.__webglDepthbuffer[$];
                    s.bindRenderbuffer(s.RENDERBUFFER, J),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, K, s.RENDERBUFFER, J)
                }
        } else if (t.bindFramebuffer(s.FRAMEBUFFER, x.__webglFramebuffer),
        x.__webglDepthbuffer === void 0)
            x.__webglDepthbuffer = s.createRenderbuffer(),
            ve(x.__webglDepthbuffer, R, !1);
        else {
            const $ = R.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
              , K = x.__webglDepthbuffer;
            s.bindRenderbuffer(s.RENDERBUFFER, K),
            s.framebufferRenderbuffer(s.FRAMEBUFFER, $, s.RENDERBUFFER, K)
        }
        t.bindFramebuffer(s.FRAMEBUFFER, null)
    }
    function Ne(R, x, k) {
        const $ = n.get(R);
        x !== void 0 && te($.__webglFramebuffer, R, R.texture, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, 0),
        k !== void 0 && Ae(R)
    }
    function Le(R) {
        const x = R.texture
          , k = n.get(R)
          , $ = n.get(x);
        R.addEventListener("dispose", P);
        const K = R.textures
          , J = R.isWebGLCubeRenderTarget === !0
          , we = K.length > 1;
        if (we || ($.__webglTexture === void 0 && ($.__webglTexture = s.createTexture()),
        $.__version = x.version,
        o.memory.textures++),
        J) {
            k.__webglFramebuffer = [];
            for (let ce = 0; ce < 6; ce++)
                if (x.mipmaps && x.mipmaps.length > 0) {
                    k.__webglFramebuffer[ce] = [];
                    for (let Me = 0; Me < x.mipmaps.length; Me++)
                        k.__webglFramebuffer[ce][Me] = s.createFramebuffer()
                } else
                    k.__webglFramebuffer[ce] = s.createFramebuffer()
        } else {
            if (x.mipmaps && x.mipmaps.length > 0) {
                k.__webglFramebuffer = [];
                for (let ce = 0; ce < x.mipmaps.length; ce++)
                    k.__webglFramebuffer[ce] = s.createFramebuffer()
            } else
                k.__webglFramebuffer = s.createFramebuffer();
            if (we)
                for (let ce = 0, Me = K.length; ce < Me; ce++) {
                    const Be = n.get(K[ce]);
                    Be.__webglTexture === void 0 && (Be.__webglTexture = s.createTexture(),
                    o.memory.textures++)
                }
            if (R.samples > 0 && Y(R) === !1) {
                k.__webglMultisampledFramebuffer = s.createFramebuffer(),
                k.__webglColorRenderbuffer = [],
                t.bindFramebuffer(s.FRAMEBUFFER, k.__webglMultisampledFramebuffer);
                for (let ce = 0; ce < K.length; ce++) {
                    const Me = K[ce];
                    k.__webglColorRenderbuffer[ce] = s.createRenderbuffer(),
                    s.bindRenderbuffer(s.RENDERBUFFER, k.__webglColorRenderbuffer[ce]);
                    const Be = r.convert(Me.format, Me.colorSpace)
                      , ne = r.convert(Me.type)
                      , ge = E(Me.internalFormat, Be, ne, Me.colorSpace, R.isXRRenderTarget === !0)
                      , Xe = fe(R);
                    s.renderbufferStorageMultisample(s.RENDERBUFFER, Xe, ge, R.width, R.height),
                    s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + ce, s.RENDERBUFFER, k.__webglColorRenderbuffer[ce])
                }
                s.bindRenderbuffer(s.RENDERBUFFER, null),
                R.depthBuffer && (k.__webglDepthRenderbuffer = s.createRenderbuffer(),
                ve(k.__webglDepthRenderbuffer, R, !0)),
                t.bindFramebuffer(s.FRAMEBUFFER, null)
            }
        }
        if (J) {
            t.bindTexture(s.TEXTURE_CUBE_MAP, $.__webglTexture),
            me(s.TEXTURE_CUBE_MAP, x);
            for (let ce = 0; ce < 6; ce++)
                if (x.mipmaps && x.mipmaps.length > 0)
                    for (let Me = 0; Me < x.mipmaps.length; Me++)
                        te(k.__webglFramebuffer[ce][Me], R, x, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + ce, Me);
                else
                    te(k.__webglFramebuffer[ce], R, x, s.COLOR_ATTACHMENT0, s.TEXTURE_CUBE_MAP_POSITIVE_X + ce, 0);
            m(x) && p(s.TEXTURE_CUBE_MAP),
            t.unbindTexture()
        } else if (we) {
            for (let ce = 0, Me = K.length; ce < Me; ce++) {
                const Be = K[ce]
                  , ne = n.get(Be);
                t.bindTexture(s.TEXTURE_2D, ne.__webglTexture),
                me(s.TEXTURE_2D, Be),
                te(k.__webglFramebuffer, R, Be, s.COLOR_ATTACHMENT0 + ce, s.TEXTURE_2D, 0),
                m(Be) && p(s.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let ce = s.TEXTURE_2D;
            if ((R.isWebGL3DRenderTarget || R.isWebGLArrayRenderTarget) && (ce = R.isWebGL3DRenderTarget ? s.TEXTURE_3D : s.TEXTURE_2D_ARRAY),
            t.bindTexture(ce, $.__webglTexture),
            me(ce, x),
            x.mipmaps && x.mipmaps.length > 0)
                for (let Me = 0; Me < x.mipmaps.length; Me++)
                    te(k.__webglFramebuffer[Me], R, x, s.COLOR_ATTACHMENT0, ce, Me);
            else
                te(k.__webglFramebuffer, R, x, s.COLOR_ATTACHMENT0, ce, 0);
            m(x) && p(ce),
            t.unbindTexture()
        }
        R.depthBuffer && Ae(R)
    }
    function Ye(R) {
        const x = R.textures;
        for (let k = 0, $ = x.length; k < $; k++) {
            const K = x[k];
            if (m(K)) {
                const J = R.isWebGLCubeRenderTarget ? s.TEXTURE_CUBE_MAP : s.TEXTURE_2D
                  , we = n.get(K).__webglTexture;
                t.bindTexture(J, we),
                p(J),
                t.unbindTexture()
            }
        }
    }
    const T = []
      , ie = [];
    function Q(R) {
        if (R.samples > 0) {
            if (Y(R) === !1) {
                const x = R.textures
                  , k = R.width
                  , $ = R.height;
                let K = s.COLOR_BUFFER_BIT;
                const J = R.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT
                  , we = n.get(R)
                  , ce = x.length > 1;
                if (ce)
                    for (let Me = 0; Me < x.length; Me++)
                        t.bindFramebuffer(s.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Me, s.RENDERBUFFER, null),
                        t.bindFramebuffer(s.FRAMEBUFFER, we.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Me, s.TEXTURE_2D, null, 0);
                t.bindFramebuffer(s.READ_FRAMEBUFFER, we.__webglMultisampledFramebuffer),
                t.bindFramebuffer(s.DRAW_FRAMEBUFFER, we.__webglFramebuffer);
                for (let Me = 0; Me < x.length; Me++) {
                    if (R.resolveDepthBuffer && (R.depthBuffer && (K |= s.DEPTH_BUFFER_BIT),
                    R.stencilBuffer && R.resolveStencilBuffer && (K |= s.STENCIL_BUFFER_BIT)),
                    ce) {
                        s.framebufferRenderbuffer(s.READ_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.RENDERBUFFER, we.__webglColorRenderbuffer[Me]);
                        const Be = n.get(x[Me]).__webglTexture;
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0, s.TEXTURE_2D, Be, 0)
                    }
                    s.blitFramebuffer(0, 0, k, $, 0, 0, k, $, K, s.NEAREST),
                    l === !0 && (T.length = 0,
                    ie.length = 0,
                    T.push(s.COLOR_ATTACHMENT0 + Me),
                    R.depthBuffer && R.resolveDepthBuffer === !1 && (T.push(J),
                    ie.push(J),
                    s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, ie)),
                    s.invalidateFramebuffer(s.READ_FRAMEBUFFER, T))
                }
                if (t.bindFramebuffer(s.READ_FRAMEBUFFER, null),
                t.bindFramebuffer(s.DRAW_FRAMEBUFFER, null),
                ce)
                    for (let Me = 0; Me < x.length; Me++) {
                        t.bindFramebuffer(s.FRAMEBUFFER, we.__webglMultisampledFramebuffer),
                        s.framebufferRenderbuffer(s.FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Me, s.RENDERBUFFER, we.__webglColorRenderbuffer[Me]);
                        const Be = n.get(x[Me]).__webglTexture;
                        t.bindFramebuffer(s.FRAMEBUFFER, we.__webglFramebuffer),
                        s.framebufferTexture2D(s.DRAW_FRAMEBUFFER, s.COLOR_ATTACHMENT0 + Me, s.TEXTURE_2D, Be, 0)
                    }
                t.bindFramebuffer(s.DRAW_FRAMEBUFFER, we.__webglMultisampledFramebuffer)
            } else if (R.depthBuffer && R.resolveDepthBuffer === !1 && l) {
                const x = R.stencilBuffer ? s.DEPTH_STENCIL_ATTACHMENT : s.DEPTH_ATTACHMENT;
                s.invalidateFramebuffer(s.DRAW_FRAMEBUFFER, [x])
            }
        }
    }
    function fe(R) {
        return Math.min(i.maxSamples, R.samples)
    }
    function Y(R) {
        const x = n.get(R);
        return R.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && x.__useRenderToTexture !== !1
    }
    function Re(R) {
        const x = o.render.frame;
        h.get(R) !== x && (h.set(R, x),
        R.update())
    }
    function ue(R, x) {
        const k = R.colorSpace
          , $ = R.format
          , K = R.type;
        return R.isCompressedTexture === !0 || R.isVideoTexture === !0 || k !== xt && k !== Hn && (je.getTransfer(k) === st ? ($ !== Gt || K !== Cn) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", k)),
        x
    }
    function _e(R) {
        return typeof HTMLImageElement < "u" && R instanceof HTMLImageElement ? (c.width = R.naturalWidth || R.width,
        c.height = R.naturalHeight || R.height) : typeof VideoFrame < "u" && R instanceof VideoFrame ? (c.width = R.displayWidth,
        c.height = R.displayHeight) : (c.width = R.width,
        c.height = R.height),
        c
    }
    this.allocateTextureUnit = G,
    this.resetTextureUnits = D,
    this.setTexture2D = O,
    this.setTexture2DArray = V,
    this.setTexture3D = B,
    this.setTextureCube = q,
    this.rebindTextures = Ne,
    this.setupRenderTarget = Le,
    this.updateRenderTargetMipmap = Ye,
    this.updateMultisampleRenderTarget = Q,
    this.setupDepthRenderbuffer = Ae,
    this.setupFrameBufferTexture = te,
    this.useMultisampledRTT = Y
}
function Rg(s, e) {
    function t(n, i=Hn) {
        let r;
        const o = je.getTransfer(i);
        if (n === Cn)
            return s.UNSIGNED_BYTE;
        if (n === ra)
            return s.UNSIGNED_SHORT_4_4_4_4;
        if (n === oa)
            return s.UNSIGNED_SHORT_5_5_5_1;
        if (n === Ac)
            return s.UNSIGNED_INT_5_9_9_9_REV;
        if (n === Tc)
            return s.BYTE;
        if (n === wc)
            return s.SHORT;
        if (n === hs)
            return s.UNSIGNED_SHORT;
        if (n === sa)
            return s.INT;
        if (n === ni)
            return s.UNSIGNED_INT;
        if (n === Pt)
            return s.FLOAT;
        if (n === on)
            return s.HALF_FLOAT;
        if (n === Rc)
            return s.ALPHA;
        if (n === Cc)
            return s.RGB;
        if (n === Gt)
            return s.RGBA;
        if (n === Pc)
            return s.LUMINANCE;
        if (n === Dc)
            return s.LUMINANCE_ALPHA;
        if (n === Ci)
            return s.DEPTH_COMPONENT;
        if (n === Bi)
            return s.DEPTH_STENCIL;
        if (n === aa)
            return s.RED;
        if (n === la)
            return s.RED_INTEGER;
        if (n === Lc)
            return s.RG;
        if (n === ca)
            return s.RG_INTEGER;
        if (n === ha)
            return s.RGBA_INTEGER;
        if (n === sr || n === rr || n === or || n === ar)
            if (o === st)
                if (r = e.get("WEBGL_compressed_texture_s3tc_srgb"),
                r !== null) {
                    if (n === sr)
                        return r.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === rr)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === or)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === ar)
                        return r.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else
                    return null;
            else if (r = e.get("WEBGL_compressed_texture_s3tc"),
            r !== null) {
                if (n === sr)
                    return r.COMPRESSED_RGB_S3TC_DXT1_EXT;
                if (n === rr)
                    return r.COMPRESSED_RGBA_S3TC_DXT1_EXT;
                if (n === or)
                    return r.COMPRESSED_RGBA_S3TC_DXT3_EXT;
                if (n === ar)
                    return r.COMPRESSED_RGBA_S3TC_DXT5_EXT
            } else
                return null;
        if (n === xo || n === yo || n === So || n === bo)
            if (r = e.get("WEBGL_compressed_texture_pvrtc"),
            r !== null) {
                if (n === xo)
                    return r.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === yo)
                    return r.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === So)
                    return r.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === bo)
                    return r.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else
                return null;
        if (n === Eo || n === To || n === wo)
            if (r = e.get("WEBGL_compressed_texture_etc"),
            r !== null) {
                if (n === Eo || n === To)
                    return o === st ? r.COMPRESSED_SRGB8_ETC2 : r.COMPRESSED_RGB8_ETC2;
                if (n === wo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : r.COMPRESSED_RGBA8_ETC2_EAC
            } else
                return null;
        if (n === Ao || n === Ro || n === Co || n === Po || n === Do || n === Lo || n === Io || n === Uo || n === No || n === Fo || n === Oo || n === Bo || n === zo || n === ko)
            if (r = e.get("WEBGL_compressed_texture_astc"),
            r !== null) {
                if (n === Ao)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : r.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === Ro)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : r.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === Co)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : r.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === Po)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : r.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === Do)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : r.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === Lo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : r.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === Io)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : r.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === Uo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : r.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === No)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : r.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Fo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : r.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Oo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : r.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Bo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : r.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === zo)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : r.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === ko)
                    return o === st ? r.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : r.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else
                return null;
        if (n === lr || n === Ho || n === Go)
            if (r = e.get("EXT_texture_compression_bptc"),
            r !== null) {
                if (n === lr)
                    return o === st ? r.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : r.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Ho)
                    return r.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Go)
                    return r.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else
                return null;
        if (n === Ic || n === Vo || n === Wo || n === Xo)
            if (r = e.get("EXT_texture_compression_rgtc"),
            r !== null) {
                if (n === lr)
                    return r.COMPRESSED_RED_RGTC1_EXT;
                if (n === Vo)
                    return r.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Wo)
                    return r.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Xo)
                    return r.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else
                return null;
        return n === Oi ? s.UNSIGNED_INT_24_8 : s[n] !== void 0 ? s[n] : null
    }
    return {
        convert: t
    }
}
class Cg extends wt {
    constructor(e=[]) {
        super(),
        this.isArrayCamera = !0,
        this.cameras = e
    }
}
class An extends it {
    constructor() {
        super(),
        this.isGroup = !0,
        this.type = "Group"
    }
}
const Pg = {
    type: "move"
};
class no {
    constructor() {
        this._targetRay = null,
        this._grip = null,
        this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new An,
        this._hand.matrixAutoUpdate = !1,
        this._hand.visible = !1,
        this._hand.joints = {},
        this._hand.inputState = {
            pinching: !1
        }),
        this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new An,
        this._targetRay.matrixAutoUpdate = !1,
        this._targetRay.visible = !1,
        this._targetRay.hasLinearVelocity = !1,
        this._targetRay.linearVelocity = new C,
        this._targetRay.hasAngularVelocity = !1,
        this._targetRay.angularVelocity = new C),
        this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new An,
        this._grip.matrixAutoUpdate = !1,
        this._grip.visible = !1,
        this._grip.hasLinearVelocity = !1,
        this._grip.linearVelocity = new C,
        this._grip.hasAngularVelocity = !1,
        this._grip.angularVelocity = new C),
        this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e),
        this._grip !== null && this._grip.dispatchEvent(e),
        this._hand !== null && this._hand.dispatchEvent(e),
        this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values())
                    this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }),
        this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }),
        this._targetRay !== null && (this._targetRay.visible = !1),
        this._grip !== null && (this._grip.visible = !1),
        this._hand !== null && (this._hand.visible = !1),
        this
    }
    update(e, t, n) {
        let i = null
          , r = null
          , o = null;
        const a = this._targetRay
          , l = this._grip
          , c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const M of e.hand.values()) {
                    const m = t.getJointPose(M, n)
                      , p = this._getHandJoint(c, M);
                    m !== null && (p.matrix.fromArray(m.transform.matrix),
                    p.matrix.decompose(p.position, p.rotation, p.scale),
                    p.matrixWorldNeedsUpdate = !0,
                    p.jointRadius = m.radius),
                    p.visible = m !== null
                }
                const h = c.joints["index-finger-tip"]
                  , d = c.joints["thumb-tip"]
                  , u = h.position.distanceTo(d.position)
                  , f = .02
                  , g = .005;
                c.inputState.pinching && u > f + g ? (c.inputState.pinching = !1,
                this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && u <= f - g && (c.inputState.pinching = !0,
                this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else
                l !== null && e.gripSpace && (r = t.getPose(e.gripSpace, n),
                r !== null && (l.matrix.fromArray(r.transform.matrix),
                l.matrix.decompose(l.position, l.rotation, l.scale),
                l.matrixWorldNeedsUpdate = !0,
                r.linearVelocity ? (l.hasLinearVelocity = !0,
                l.linearVelocity.copy(r.linearVelocity)) : l.hasLinearVelocity = !1,
                r.angularVelocity ? (l.hasAngularVelocity = !0,
                l.angularVelocity.copy(r.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, n),
            i === null && r !== null && (i = r),
            i !== null && (a.matrix.fromArray(i.transform.matrix),
            a.matrix.decompose(a.position, a.rotation, a.scale),
            a.matrixWorldNeedsUpdate = !0,
            i.linearVelocity ? (a.hasLinearVelocity = !0,
            a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1,
            i.angularVelocity ? (a.hasAngularVelocity = !0,
            a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1,
            this.dispatchEvent(Pg)))
        }
        return a !== null && (a.visible = i !== null),
        l !== null && (l.visible = r !== null),
        c !== null && (c.visible = o !== null),
        this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new An;
            n.matrixAutoUpdate = !1,
            n.visible = !1,
            e.joints[t.jointName] = n,
            e.add(n)
        }
        return e.joints[t.jointName]
    }
}
const Dg = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`
  , Lg = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class Ig {
    constructor() {
        this.texture = null,
        this.mesh = null,
        this.depthNear = 0,
        this.depthFar = 0
    }
    init(e, t, n) {
        if (this.texture === null) {
            const i = new vt
              , r = e.properties.get(i);
            r.__webglTexture = t.texture,
            (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear,
            this.depthFar = t.depthFar),
            this.texture = i
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport
              , n = new hn({
                vertexShader: Dg,
                fragmentShader: Lg,
                uniforms: {
                    depthColor: {
                        value: this.texture
                    },
                    depthWidth: {
                        value: t.z
                    },
                    depthHeight: {
                        value: t.w
                    }
                }
            });
            this.mesh = new ct(new an(20,20),n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null,
        this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class Ug extends ri {
    constructor(e, t) {
        super();
        const n = this;
        let i = null
          , r = 1
          , o = null
          , a = "local-floor"
          , l = 1
          , c = null
          , h = null
          , d = null
          , u = null
          , f = null
          , g = null;
        const M = new Ig
          , m = t.getContextAttributes();
        let p = null
          , E = null;
        const _ = []
          , v = []
          , L = new ee;
        let P = null;
        const A = new wt;
        A.layers.enable(1),
        A.viewport = new Qe;
        const w = new wt;
        w.layers.enable(2),
        w.viewport = new Qe;
        const S = [A, w]
          , y = new Cg;
        y.layers.enable(1),
        y.layers.enable(2);
        let D = null
          , G = null;
        this.cameraAutoUpdate = !0,
        this.enabled = !1,
        this.isPresenting = !1,
        this.getController = function(X) {
            let te = _[X];
            return te === void 0 && (te = new no,
            _[X] = te),
            te.getTargetRaySpace()
        }
        ,
        this.getControllerGrip = function(X) {
            let te = _[X];
            return te === void 0 && (te = new no,
            _[X] = te),
            te.getGripSpace()
        }
        ,
        this.getHand = function(X) {
            let te = _[X];
            return te === void 0 && (te = new no,
            _[X] = te),
            te.getHandSpace()
        }
        ;
        function F(X) {
            const te = v.indexOf(X.inputSource);
            if (te === -1)
                return;
            const ve = _[te];
            ve !== void 0 && (ve.update(X.inputSource, X.frame, c || o),
            ve.dispatchEvent({
                type: X.type,
                data: X.inputSource
            }))
        }
        function O() {
            i.removeEventListener("select", F),
            i.removeEventListener("selectstart", F),
            i.removeEventListener("selectend", F),
            i.removeEventListener("squeeze", F),
            i.removeEventListener("squeezestart", F),
            i.removeEventListener("squeezeend", F),
            i.removeEventListener("end", O),
            i.removeEventListener("inputsourceschange", V);
            for (let X = 0; X < _.length; X++) {
                const te = v[X];
                te !== null && (v[X] = null,
                _[X].disconnect(te))
            }
            D = null,
            G = null,
            M.reset(),
            e.setRenderTarget(p),
            f = null,
            u = null,
            d = null,
            i = null,
            E = null,
            ze.stop(),
            n.isPresenting = !1,
            e.setPixelRatio(P),
            e.setSize(L.width, L.height, !1),
            n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function(X) {
            r = X,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }
        ,
        this.setReferenceSpaceType = function(X) {
            a = X,
            n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }
        ,
        this.getReferenceSpace = function() {
            return c || o
        }
        ,
        this.setReferenceSpace = function(X) {
            c = X
        }
        ,
        this.getBaseLayer = function() {
            return u !== null ? u : f
        }
        ,
        this.getBinding = function() {
            return d
        }
        ,
        this.getFrame = function() {
            return g
        }
        ,
        this.getSession = function() {
            return i
        }
        ,
        this.setSession = async function(X) {
            if (i = X,
            i !== null) {
                if (p = e.getRenderTarget(),
                i.addEventListener("select", F),
                i.addEventListener("selectstart", F),
                i.addEventListener("selectend", F),
                i.addEventListener("squeeze", F),
                i.addEventListener("squeezestart", F),
                i.addEventListener("squeezeend", F),
                i.addEventListener("end", O),
                i.addEventListener("inputsourceschange", V),
                m.xrCompatible !== !0 && await t.makeXRCompatible(),
                P = e.getPixelRatio(),
                e.getSize(L),
                i.renderState.layers === void 0) {
                    const te = {
                        antialias: m.antialias,
                        alpha: !0,
                        depth: m.depth,
                        stencil: m.stencil,
                        framebufferScaleFactor: r
                    };
                    f = new XRWebGLLayer(i,t,te),
                    i.updateRenderState({
                        baseLayer: f
                    }),
                    e.setPixelRatio(1),
                    e.setSize(f.framebufferWidth, f.framebufferHeight, !1),
                    E = new Wn(f.framebufferWidth,f.framebufferHeight,{
                        format: Gt,
                        type: Cn,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: m.stencil
                    })
                } else {
                    let te = null
                      , ve = null
                      , de = null;
                    m.depth && (de = m.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24,
                    te = m.stencil ? Bi : Ci,
                    ve = m.stencil ? Oi : ni);
                    const Ae = {
                        colorFormat: t.RGBA8,
                        depthFormat: de,
                        scaleFactor: r
                    };
                    d = new XRWebGLBinding(i,t),
                    u = d.createProjectionLayer(Ae),
                    i.updateRenderState({
                        layers: [u]
                    }),
                    e.setPixelRatio(1),
                    e.setSize(u.textureWidth, u.textureHeight, !1),
                    E = new Wn(u.textureWidth,u.textureHeight,{
                        format: Gt,
                        type: Cn,
                        depthTexture: new Kc(u.textureWidth,u.textureHeight,ve,void 0,void 0,void 0,void 0,void 0,void 0,te),
                        stencilBuffer: m.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: m.antialias ? 4 : 0,
                        resolveDepthBuffer: u.ignoreDepthValues === !1
                    })
                }
                E.isXRRenderTarget = !0,
                this.setFoveation(l),
                c = null,
                o = await i.requestReferenceSpace(a),
                ze.setContext(i),
                ze.start(),
                n.isPresenting = !0,
                n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }
        ,
        this.getEnvironmentBlendMode = function() {
            if (i !== null)
                return i.environmentBlendMode
        }
        ,
        this.getDepthTexture = function() {
            return M.getDepthTexture()
        }
        ;
        function V(X) {
            for (let te = 0; te < X.removed.length; te++) {
                const ve = X.removed[te]
                  , de = v.indexOf(ve);
                de >= 0 && (v[de] = null,
                _[de].disconnect(ve))
            }
            for (let te = 0; te < X.added.length; te++) {
                const ve = X.added[te];
                let de = v.indexOf(ve);
                if (de === -1) {
                    for (let Ne = 0; Ne < _.length; Ne++)
                        if (Ne >= v.length) {
                            v.push(ve),
                            de = Ne;
                            break
                        } else if (v[Ne] === null) {
                            v[Ne] = ve,
                            de = Ne;
                            break
                        }
                    if (de === -1)
                        break
                }
                const Ae = _[de];
                Ae && Ae.connect(ve)
            }
        }
        const B = new C
          , q = new C;
        function W(X, te, ve) {
            B.setFromMatrixPosition(te.matrixWorld),
            q.setFromMatrixPosition(ve.matrixWorld);
            const de = B.distanceTo(q)
              , Ae = te.projectionMatrix.elements
              , Ne = ve.projectionMatrix.elements
              , Le = Ae[14] / (Ae[10] - 1)
              , Ye = Ae[14] / (Ae[10] + 1)
              , T = (Ae[9] + 1) / Ae[5]
              , ie = (Ae[9] - 1) / Ae[5]
              , Q = (Ae[8] - 1) / Ae[0]
              , fe = (Ne[8] + 1) / Ne[0]
              , Y = Le * Q
              , Re = Le * fe
              , ue = de / (-Q + fe)
              , _e = ue * -Q;
            if (te.matrixWorld.decompose(X.position, X.quaternion, X.scale),
            X.translateX(_e),
            X.translateZ(ue),
            X.matrixWorld.compose(X.position, X.quaternion, X.scale),
            X.matrixWorldInverse.copy(X.matrixWorld).invert(),
            Ae[10] === -1)
                X.projectionMatrix.copy(te.projectionMatrix),
                X.projectionMatrixInverse.copy(te.projectionMatrixInverse);
            else {
                const R = Le + ue
                  , x = Ye + ue
                  , k = Y - _e
                  , $ = Re + (de - _e)
                  , K = T * Ye / x * R
                  , J = ie * Ye / x * R;
                X.projectionMatrix.makePerspective(k, $, K, J, R, x),
                X.projectionMatrixInverse.copy(X.projectionMatrix).invert()
            }
        }
        function ae(X, te) {
            te === null ? X.matrixWorld.copy(X.matrix) : X.matrixWorld.multiplyMatrices(te.matrixWorld, X.matrix),
            X.matrixWorldInverse.copy(X.matrixWorld).invert()
        }
        this.updateCamera = function(X) {
            if (i === null)
                return;
            let te = X.near
              , ve = X.far;
            M.texture !== null && (M.depthNear > 0 && (te = M.depthNear),
            M.depthFar > 0 && (ve = M.depthFar)),
            y.near = w.near = A.near = te,
            y.far = w.far = A.far = ve,
            (D !== y.near || G !== y.far) && (i.updateRenderState({
                depthNear: y.near,
                depthFar: y.far
            }),
            D = y.near,
            G = y.far);
            const de = X.parent
              , Ae = y.cameras;
            ae(y, de);
            for (let Ne = 0; Ne < Ae.length; Ne++)
                ae(Ae[Ne], de);
            Ae.length === 2 ? W(y, A, w) : y.projectionMatrix.copy(A.projectionMatrix),
            le(X, y, de)
        }
        ;
        function le(X, te, ve) {
            ve === null ? X.matrix.copy(te.matrixWorld) : (X.matrix.copy(ve.matrixWorld),
            X.matrix.invert(),
            X.matrix.multiply(te.matrixWorld)),
            X.matrix.decompose(X.position, X.quaternion, X.scale),
            X.updateMatrixWorld(!0),
            X.projectionMatrix.copy(te.projectionMatrix),
            X.projectionMatrixInverse.copy(te.projectionMatrixInverse),
            X.isPerspectiveCamera && (X.fov = zi * 2 * Math.atan(1 / X.projectionMatrix.elements[5]),
            X.zoom = 1)
        }
        this.getCamera = function() {
            return y
        }
        ,
        this.getFoveation = function() {
            if (!(u === null && f === null))
                return l
        }
        ,
        this.setFoveation = function(X) {
            l = X,
            u !== null && (u.fixedFoveation = X),
            f !== null && f.fixedFoveation !== void 0 && (f.fixedFoveation = X)
        }
        ,
        this.hasDepthSensing = function() {
            return M.texture !== null
        }
        ,
        this.getDepthSensingMesh = function() {
            return M.getMesh(y)
        }
        ;
        let me = null;
        function Ce(X, te) {
            if (h = te.getViewerPose(c || o),
            g = te,
            h !== null) {
                const ve = h.views;
                f !== null && (e.setRenderTargetFramebuffer(E, f.framebuffer),
                e.setRenderTarget(E));
                let de = !1;
                ve.length !== y.cameras.length && (y.cameras.length = 0,
                de = !0);
                for (let Ne = 0; Ne < ve.length; Ne++) {
                    const Le = ve[Ne];
                    let Ye = null;
                    if (f !== null)
                        Ye = f.getViewport(Le);
                    else {
                        const ie = d.getViewSubImage(u, Le);
                        Ye = ie.viewport,
                        Ne === 0 && (e.setRenderTargetTextures(E, ie.colorTexture, u.ignoreDepthValues ? void 0 : ie.depthStencilTexture),
                        e.setRenderTarget(E))
                    }
                    let T = S[Ne];
                    T === void 0 && (T = new wt,
                    T.layers.enable(Ne),
                    T.viewport = new Qe,
                    S[Ne] = T),
                    T.matrix.fromArray(Le.transform.matrix),
                    T.matrix.decompose(T.position, T.quaternion, T.scale),
                    T.projectionMatrix.fromArray(Le.projectionMatrix),
                    T.projectionMatrixInverse.copy(T.projectionMatrix).invert(),
                    T.viewport.set(Ye.x, Ye.y, Ye.width, Ye.height),
                    Ne === 0 && (y.matrix.copy(T.matrix),
                    y.matrix.decompose(y.position, y.quaternion, y.scale)),
                    de === !0 && y.cameras.push(T)
                }
                const Ae = i.enabledFeatures;
                if (Ae && Ae.includes("depth-sensing")) {
                    const Ne = d.getDepthInformation(ve[0]);
                    Ne && Ne.isValid && Ne.texture && M.init(e, Ne, i.renderState)
                }
            }
            for (let ve = 0; ve < _.length; ve++) {
                const de = v[ve]
                  , Ae = _[ve];
                de !== null && Ae !== void 0 && Ae.update(de, te, c || o)
            }
            me && me(X, te),
            te.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: te
            }),
            g = null
        }
        const ze = new jc;
        ze.setAnimationLoop(Ce),
        this.setAnimationLoop = function(X) {
            me = X
        }
        ,
        this.dispose = function() {}
    }
}
const Zn = new cn
  , Ng = new Oe;
function Fg(s, e) {
    function t(m, p) {
        m.matrixAutoUpdate === !0 && m.updateMatrix(),
        p.value.copy(m.matrix)
    }
    function n(m, p) {
        p.color.getRGB(m.fogColor.value, Xc(s)),
        p.isFog ? (m.fogNear.value = p.near,
        m.fogFar.value = p.far) : p.isFogExp2 && (m.fogDensity.value = p.density)
    }
    function i(m, p, E, _, v) {
        p.isMeshBasicMaterial || p.isMeshLambertMaterial ? r(m, p) : p.isMeshToonMaterial ? (r(m, p),
        d(m, p)) : p.isMeshPhongMaterial ? (r(m, p),
        h(m, p)) : p.isMeshStandardMaterial ? (r(m, p),
        u(m, p),
        p.isMeshPhysicalMaterial && f(m, p, v)) : p.isMeshMatcapMaterial ? (r(m, p),
        g(m, p)) : p.isMeshDepthMaterial ? r(m, p) : p.isMeshDistanceMaterial ? (r(m, p),
        M(m, p)) : p.isMeshNormalMaterial ? r(m, p) : p.isLineBasicMaterial ? (o(m, p),
        p.isLineDashedMaterial && a(m, p)) : p.isPointsMaterial ? l(m, p, E, _) : p.isSpriteMaterial ? c(m, p) : p.isShadowMaterial ? (m.color.value.copy(p.color),
        m.opacity.value = p.opacity) : p.isShaderMaterial && (p.uniformsNeedUpdate = !1)
    }
    function r(m, p) {
        m.opacity.value = p.opacity,
        p.color && m.diffuse.value.copy(p.color),
        p.emissive && m.emissive.value.copy(p.emissive).multiplyScalar(p.emissiveIntensity),
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.bumpMap && (m.bumpMap.value = p.bumpMap,
        t(p.bumpMap, m.bumpMapTransform),
        m.bumpScale.value = p.bumpScale,
        p.side === It && (m.bumpScale.value *= -1)),
        p.normalMap && (m.normalMap.value = p.normalMap,
        t(p.normalMap, m.normalMapTransform),
        m.normalScale.value.copy(p.normalScale),
        p.side === It && m.normalScale.value.negate()),
        p.displacementMap && (m.displacementMap.value = p.displacementMap,
        t(p.displacementMap, m.displacementMapTransform),
        m.displacementScale.value = p.displacementScale,
        m.displacementBias.value = p.displacementBias),
        p.emissiveMap && (m.emissiveMap.value = p.emissiveMap,
        t(p.emissiveMap, m.emissiveMapTransform)),
        p.specularMap && (m.specularMap.value = p.specularMap,
        t(p.specularMap, m.specularMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest);
        const E = e.get(p)
          , _ = E.envMap
          , v = E.envMapRotation;
        _ && (m.envMap.value = _,
        Zn.copy(v),
        Zn.x *= -1,
        Zn.y *= -1,
        Zn.z *= -1,
        _.isCubeTexture && _.isRenderTargetTexture === !1 && (Zn.y *= -1,
        Zn.z *= -1),
        m.envMapRotation.value.setFromMatrix4(Ng.makeRotationFromEuler(Zn)),
        m.flipEnvMap.value = _.isCubeTexture && _.isRenderTargetTexture === !1 ? -1 : 1,
        m.reflectivity.value = p.reflectivity,
        m.ior.value = p.ior,
        m.refractionRatio.value = p.refractionRatio),
        p.lightMap && (m.lightMap.value = p.lightMap,
        m.lightMapIntensity.value = p.lightMapIntensity,
        t(p.lightMap, m.lightMapTransform)),
        p.aoMap && (m.aoMap.value = p.aoMap,
        m.aoMapIntensity.value = p.aoMapIntensity,
        t(p.aoMap, m.aoMapTransform))
    }
    function o(m, p) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform))
    }
    function a(m, p) {
        m.dashSize.value = p.dashSize,
        m.totalSize.value = p.dashSize + p.gapSize,
        m.scale.value = p.scale
    }
    function l(m, p, E, _) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        m.size.value = p.size * E,
        m.scale.value = _ * .5,
        p.map && (m.map.value = p.map,
        t(p.map, m.uvTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
    }
    function c(m, p) {
        m.diffuse.value.copy(p.color),
        m.opacity.value = p.opacity,
        m.rotation.value = p.rotation,
        p.map && (m.map.value = p.map,
        t(p.map, m.mapTransform)),
        p.alphaMap && (m.alphaMap.value = p.alphaMap,
        t(p.alphaMap, m.alphaMapTransform)),
        p.alphaTest > 0 && (m.alphaTest.value = p.alphaTest)
    }
    function h(m, p) {
        m.specular.value.copy(p.specular),
        m.shininess.value = Math.max(p.shininess, 1e-4)
    }
    function d(m, p) {
        p.gradientMap && (m.gradientMap.value = p.gradientMap)
    }
    function u(m, p) {
        m.metalness.value = p.metalness,
        p.metalnessMap && (m.metalnessMap.value = p.metalnessMap,
        t(p.metalnessMap, m.metalnessMapTransform)),
        m.roughness.value = p.roughness,
        p.roughnessMap && (m.roughnessMap.value = p.roughnessMap,
        t(p.roughnessMap, m.roughnessMapTransform)),
        p.envMap && (m.envMapIntensity.value = p.envMapIntensity)
    }
    function f(m, p, E) {
        m.ior.value = p.ior,
        p.sheen > 0 && (m.sheenColor.value.copy(p.sheenColor).multiplyScalar(p.sheen),
        m.sheenRoughness.value = p.sheenRoughness,
        p.sheenColorMap && (m.sheenColorMap.value = p.sheenColorMap,
        t(p.sheenColorMap, m.sheenColorMapTransform)),
        p.sheenRoughnessMap && (m.sheenRoughnessMap.value = p.sheenRoughnessMap,
        t(p.sheenRoughnessMap, m.sheenRoughnessMapTransform))),
        p.clearcoat > 0 && (m.clearcoat.value = p.clearcoat,
        m.clearcoatRoughness.value = p.clearcoatRoughness,
        p.clearcoatMap && (m.clearcoatMap.value = p.clearcoatMap,
        t(p.clearcoatMap, m.clearcoatMapTransform)),
        p.clearcoatRoughnessMap && (m.clearcoatRoughnessMap.value = p.clearcoatRoughnessMap,
        t(p.clearcoatRoughnessMap, m.clearcoatRoughnessMapTransform)),
        p.clearcoatNormalMap && (m.clearcoatNormalMap.value = p.clearcoatNormalMap,
        t(p.clearcoatNormalMap, m.clearcoatNormalMapTransform),
        m.clearcoatNormalScale.value.copy(p.clearcoatNormalScale),
        p.side === It && m.clearcoatNormalScale.value.negate())),
        p.dispersion > 0 && (m.dispersion.value = p.dispersion),
        p.iridescence > 0 && (m.iridescence.value = p.iridescence,
        m.iridescenceIOR.value = p.iridescenceIOR,
        m.iridescenceThicknessMinimum.value = p.iridescenceThicknessRange[0],
        m.iridescenceThicknessMaximum.value = p.iridescenceThicknessRange[1],
        p.iridescenceMap && (m.iridescenceMap.value = p.iridescenceMap,
        t(p.iridescenceMap, m.iridescenceMapTransform)),
        p.iridescenceThicknessMap && (m.iridescenceThicknessMap.value = p.iridescenceThicknessMap,
        t(p.iridescenceThicknessMap, m.iridescenceThicknessMapTransform))),
        p.transmission > 0 && (m.transmission.value = p.transmission,
        m.transmissionSamplerMap.value = E.texture,
        m.transmissionSamplerSize.value.set(E.width, E.height),
        p.transmissionMap && (m.transmissionMap.value = p.transmissionMap,
        t(p.transmissionMap, m.transmissionMapTransform)),
        m.thickness.value = p.thickness,
        p.thicknessMap && (m.thicknessMap.value = p.thicknessMap,
        t(p.thicknessMap, m.thicknessMapTransform)),
        m.attenuationDistance.value = p.attenuationDistance,
        m.attenuationColor.value.copy(p.attenuationColor)),
        p.anisotropy > 0 && (m.anisotropyVector.value.set(p.anisotropy * Math.cos(p.anisotropyRotation), p.anisotropy * Math.sin(p.anisotropyRotation)),
        p.anisotropyMap && (m.anisotropyMap.value = p.anisotropyMap,
        t(p.anisotropyMap, m.anisotropyMapTransform))),
        m.specularIntensity.value = p.specularIntensity,
        m.specularColor.value.copy(p.specularColor),
        p.specularColorMap && (m.specularColorMap.value = p.specularColorMap,
        t(p.specularColorMap, m.specularColorMapTransform)),
        p.specularIntensityMap && (m.specularIntensityMap.value = p.specularIntensityMap,
        t(p.specularIntensityMap, m.specularIntensityMapTransform))
    }
    function g(m, p) {
        p.matcap && (m.matcap.value = p.matcap)
    }
    function M(m, p) {
        const E = e.get(p).light;
        m.referencePosition.value.setFromMatrixPosition(E.matrixWorld),
        m.nearDistance.value = E.shadow.camera.near,
        m.farDistance.value = E.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}
function Og(s, e, t, n) {
    let i = {}
      , r = {}
      , o = [];
    const a = s.getParameter(s.MAX_UNIFORM_BUFFER_BINDINGS);
    function l(E, _) {
        const v = _.program;
        n.uniformBlockBinding(E, v)
    }
    function c(E, _) {
        let v = i[E.id];
        v === void 0 && (g(E),
        v = h(E),
        i[E.id] = v,
        E.addEventListener("dispose", m));
        const L = _.program;
        n.updateUBOMapping(E, L);
        const P = e.render.frame;
        r[E.id] !== P && (u(E),
        r[E.id] = P)
    }
    function h(E) {
        const _ = d();
        E.__bindingPointIndex = _;
        const v = s.createBuffer()
          , L = E.__size
          , P = E.usage;
        return s.bindBuffer(s.UNIFORM_BUFFER, v),
        s.bufferData(s.UNIFORM_BUFFER, L, P),
        s.bindBuffer(s.UNIFORM_BUFFER, null),
        s.bindBufferBase(s.UNIFORM_BUFFER, _, v),
        v
    }
    function d() {
        for (let E = 0; E < a; E++)
            if (o.indexOf(E) === -1)
                return o.push(E),
                E;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."),
        0
    }
    function u(E) {
        const _ = i[E.id]
          , v = E.uniforms
          , L = E.__cache;
        s.bindBuffer(s.UNIFORM_BUFFER, _);
        for (let P = 0, A = v.length; P < A; P++) {
            const w = Array.isArray(v[P]) ? v[P] : [v[P]];
            for (let S = 0, y = w.length; S < y; S++) {
                const D = w[S];
                if (f(D, P, S, L) === !0) {
                    const G = D.__offset
                      , F = Array.isArray(D.value) ? D.value : [D.value];
                    let O = 0;
                    for (let V = 0; V < F.length; V++) {
                        const B = F[V]
                          , q = M(B);
                        typeof B == "number" || typeof B == "boolean" ? (D.__data[0] = B,
                        s.bufferSubData(s.UNIFORM_BUFFER, G + O, D.__data)) : B.isMatrix3 ? (D.__data[0] = B.elements[0],
                        D.__data[1] = B.elements[1],
                        D.__data[2] = B.elements[2],
                        D.__data[3] = 0,
                        D.__data[4] = B.elements[3],
                        D.__data[5] = B.elements[4],
                        D.__data[6] = B.elements[5],
                        D.__data[7] = 0,
                        D.__data[8] = B.elements[6],
                        D.__data[9] = B.elements[7],
                        D.__data[10] = B.elements[8],
                        D.__data[11] = 0) : (B.toArray(D.__data, O),
                        O += q.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    s.bufferSubData(s.UNIFORM_BUFFER, G, D.__data)
                }
            }
        }
        s.bindBuffer(s.UNIFORM_BUFFER, null)
    }
    function f(E, _, v, L) {
        const P = E.value
          , A = _ + "_" + v;
        if (L[A] === void 0)
            return typeof P == "number" || typeof P == "boolean" ? L[A] = P : L[A] = P.clone(),
            !0;
        {
            const w = L[A];
            if (typeof P == "number" || typeof P == "boolean") {
                if (w !== P)
                    return L[A] = P,
                    !0
            } else if (w.equals(P) === !1)
                return w.copy(P),
                !0
        }
        return !1
    }
    function g(E) {
        const _ = E.uniforms;
        let v = 0;
        const L = 16;
        for (let A = 0, w = _.length; A < w; A++) {
            const S = Array.isArray(_[A]) ? _[A] : [_[A]];
            for (let y = 0, D = S.length; y < D; y++) {
                const G = S[y]
                  , F = Array.isArray(G.value) ? G.value : [G.value];
                for (let O = 0, V = F.length; O < V; O++) {
                    const B = F[O]
                      , q = M(B)
                      , W = v % L
                      , ae = W % q.boundary
                      , le = W + ae;
                    v += ae,
                    le !== 0 && L - le < q.storage && (v += L - le),
                    G.__data = new Float32Array(q.storage / Float32Array.BYTES_PER_ELEMENT),
                    G.__offset = v,
                    v += q.storage
                }
            }
        }
        const P = v % L;
        return P > 0 && (v += L - P),
        E.__size = v,
        E.__cache = {},
        this
    }
    function M(E) {
        const _ = {
            boundary: 0,
            storage: 0
        };
        return typeof E == "number" || typeof E == "boolean" ? (_.boundary = 4,
        _.storage = 4) : E.isVector2 ? (_.boundary = 8,
        _.storage = 8) : E.isVector3 || E.isColor ? (_.boundary = 16,
        _.storage = 12) : E.isVector4 ? (_.boundary = 16,
        _.storage = 16) : E.isMatrix3 ? (_.boundary = 48,
        _.storage = 48) : E.isMatrix4 ? (_.boundary = 64,
        _.storage = 64) : E.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", E),
        _
    }
    function m(E) {
        const _ = E.target;
        _.removeEventListener("dispose", m);
        const v = o.indexOf(_.__bindingPointIndex);
        o.splice(v, 1),
        s.deleteBuffer(i[_.id]),
        delete i[_.id],
        delete r[_.id]
    }
    function p() {
        for (const E in i)
            s.deleteBuffer(i[E]);
        o = [],
        i = {},
        r = {}
    }
    return {
        bind: l,
        update: c,
        dispose: p
    }
}
class Bg {
    constructor(e={}) {
        const {canvas: t=Td(), context: n=null, depth: i=!0, stencil: r=!1, alpha: o=!1, antialias: a=!1, premultipliedAlpha: l=!0, preserveDrawingBuffer: c=!1, powerPreference: h="default", failIfMajorPerformanceCaveat: d=!1} = e;
        this.isWebGLRenderer = !0;
        let u;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext)
                throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            u = n.getContextAttributes().alpha
        } else
            u = o;
        const f = new Uint32Array(4)
          , g = new Int32Array(4);
        let M = null
          , m = null;
        const p = []
          , E = [];
        this.domElement = t,
        this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        },
        this.autoClear = !0,
        this.autoClearColor = !0,
        this.autoClearDepth = !0,
        this.autoClearStencil = !0,
        this.sortObjects = !0,
        this.clippingPlanes = [],
        this.localClippingEnabled = !1,
        this._outputColorSpace = Tt,
        this.toneMapping = Rn,
        this.toneMappingExposure = 1;
        const _ = this;
        let v = !1
          , L = 0
          , P = 0
          , A = null
          , w = -1
          , S = null;
        const y = new Qe
          , D = new Qe;
        let G = null;
        const F = new be(0);
        let O = 0
          , V = t.width
          , B = t.height
          , q = 1
          , W = null
          , ae = null;
        const le = new Qe(0,0,V,B)
          , me = new Qe(0,0,V,B);
        let Ce = !1;
        const ze = new pa;
        let X = !1
          , te = !1;
        const ve = new Oe
          , de = new C
          , Ae = new Qe
          , Ne = {
            background: null,
            fog: null,
            environment: null,
            overrideMaterial: null,
            isScene: !0
        };
        let Le = !1;
        function Ye() {
            return A === null ? q : 1
        }
        let T = n;
        function ie(b, U) {
            return t.getContext(b, U)
        }
        try {
            const b = {
                alpha: !0,
                depth: i,
                stencil: r,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: h,
                failIfMajorPerformanceCaveat: d
            };
            if ("setAttribute"in t && t.setAttribute("data-engine", `three.js r${ia}`),
            t.addEventListener("webglcontextlost", j, !1),
            t.addEventListener("webglcontextrestored", Z, !1),
            t.addEventListener("webglcontextcreationerror", oe, !1),
            T === null) {
                const U = "webgl2";
                if (T = ie(U, b),
                T === null)
                    throw ie(U) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (b) {
            throw console.error("THREE.WebGLRenderer: " + b.message),
            b
        }
        let Q, fe, Y, Re, ue, _e, R, x, k, $, K, J, we, ce, Me, Be, ne, ge, Xe, Ue, xe, Fe, Ge, rt;
        function I() {
            Q = new Wp(T),
            Q.init(),
            Fe = new Rg(T,Q),
            fe = new Bp(T,Q,e,Fe),
            Y = new Tg(T),
            Re = new Yp(T),
            ue = new dg,
            _e = new Ag(T,Q,Y,ue,fe,Fe,Re),
            R = new kp(_),
            x = new Vp(_),
            k = new Qd(T),
            Ge = new Fp(T,k),
            $ = new Xp(T,k,Re,Ge),
            K = new Kp(T,$,k,Re),
            Xe = new jp(T,fe,_e),
            Be = new zp(ue),
            J = new hg(_,R,x,Q,fe,Ge,Be),
            we = new Fg(_,ue),
            ce = new fg,
            Me = new vg(Q),
            ge = new Np(_,R,x,Y,K,u,l),
            ne = new Eg(_,K,fe),
            rt = new Og(T,Re,fe,Y),
            Ue = new Op(T,Q,Re),
            xe = new qp(T,Q,Re),
            Re.programs = J.programs,
            _.capabilities = fe,
            _.extensions = Q,
            _.properties = ue,
            _.renderLists = ce,
            _.shadowMap = ne,
            _.state = Y,
            _.info = Re
        }
        I();
        const se = new Ug(_,T);
        this.xr = se,
        this.getContext = function() {
            return T
        }
        ,
        this.getContextAttributes = function() {
            return T.getContextAttributes()
        }
        ,
        this.forceContextLoss = function() {
            const b = Q.get("WEBGL_lose_context");
            b && b.loseContext()
        }
        ,
        this.forceContextRestore = function() {
            const b = Q.get("WEBGL_lose_context");
            b && b.restoreContext()
        }
        ,
        this.getPixelRatio = function() {
            return q
        }
        ,
        this.setPixelRatio = function(b) {
            b !== void 0 && (q = b,
            this.setSize(V, B, !1))
        }
        ,
        this.getSize = function(b) {
            return b.set(V, B)
        }
        ,
        this.setSize = function(b, U, z=!0) {
            if (se.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            V = b,
            B = U,
            t.width = Math.floor(b * q),
            t.height = Math.floor(U * q),
            z === !0 && (t.style.width = b + "px",
            t.style.height = U + "px"),
            this.setViewport(0, 0, b, U)
        }
        ,
        this.getDrawingBufferSize = function(b) {
            return b.set(V * q, B * q).floor()
        }
        ,
        this.setDrawingBufferSize = function(b, U, z) {
            V = b,
            B = U,
            q = z,
            t.width = Math.floor(b * z),
            t.height = Math.floor(U * z),
            this.setViewport(0, 0, b, U)
        }
        ,
        this.getCurrentViewport = function(b) {
            return b.copy(y)
        }
        ,
        this.getViewport = function(b) {
            return b.copy(le)
        }
        ,
        this.setViewport = function(b, U, z, H) {
            b.isVector4 ? le.set(b.x, b.y, b.z, b.w) : le.set(b, U, z, H),
            Y.viewport(y.copy(le).multiplyScalar(q).round())
        }
        ,
        this.getScissor = function(b) {
            return b.copy(me)
        }
        ,
        this.setScissor = function(b, U, z, H) {
            b.isVector4 ? me.set(b.x, b.y, b.z, b.w) : me.set(b, U, z, H),
            Y.scissor(D.copy(me).multiplyScalar(q).round())
        }
        ,
        this.getScissorTest = function() {
            return Ce
        }
        ,
        this.setScissorTest = function(b) {
            Y.setScissorTest(Ce = b)
        }
        ,
        this.setOpaqueSort = function(b) {
            W = b
        }
        ,
        this.setTransparentSort = function(b) {
            ae = b
        }
        ,
        this.getClearColor = function(b) {
            return b.copy(ge.getClearColor())
        }
        ,
        this.setClearColor = function() {
            ge.setClearColor.apply(ge, arguments)
        }
        ,
        this.getClearAlpha = function() {
            return ge.getClearAlpha()
        }
        ,
        this.setClearAlpha = function() {
            ge.setClearAlpha.apply(ge, arguments)
        }
        ,
        this.clear = function(b=!0, U=!0, z=!0) {
            let H = 0;
            if (b) {
                let N = !1;
                if (A !== null) {
                    const re = A.texture.format;
                    N = re === ha || re === ca || re === la
                }
                if (N) {
                    const re = A.texture.type
                      , pe = re === Cn || re === ni || re === hs || re === Oi || re === ra || re === oa
                      , ye = ge.getClearColor()
                      , Se = ge.getClearAlpha()
                      , De = ye.r
                      , Ie = ye.g
                      , Ee = ye.b;
                    pe ? (f[0] = De,
                    f[1] = Ie,
                    f[2] = Ee,
                    f[3] = Se,
                    T.clearBufferuiv(T.COLOR, 0, f)) : (g[0] = De,
                    g[1] = Ie,
                    g[2] = Ee,
                    g[3] = Se,
                    T.clearBufferiv(T.COLOR, 0, g))
                } else
                    H |= T.COLOR_BUFFER_BIT
            }
            U && (H |= T.DEPTH_BUFFER_BIT),
            z && (H |= T.STENCIL_BUFFER_BIT,
            this.state.buffers.stencil.setMask(4294967295)),
            T.clear(H)
        }
        ,
        this.clearColor = function() {
            this.clear(!0, !1, !1)
        }
        ,
        this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }
        ,
        this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }
        ,
        this.dispose = function() {
            t.removeEventListener("webglcontextlost", j, !1),
            t.removeEventListener("webglcontextrestored", Z, !1),
            t.removeEventListener("webglcontextcreationerror", oe, !1),
            ce.dispose(),
            Me.dispose(),
            ue.dispose(),
            R.dispose(),
            x.dispose(),
            K.dispose(),
            Ge.dispose(),
            rt.dispose(),
            J.dispose(),
            se.dispose(),
            se.removeEventListener("sessionstart", en),
            se.removeEventListener("sessionend", Pa),
            Xn.stop()
        }
        ;
        function j(b) {
            b.preventDefault(),
            console.log("THREE.WebGLRenderer: Context Lost."),
            v = !0
        }
        function Z() {
            console.log("THREE.WebGLRenderer: Context Restored."),
            v = !1;
            const b = Re.autoReset
              , U = ne.enabled
              , z = ne.autoUpdate
              , H = ne.needsUpdate
              , N = ne.type;
            I(),
            Re.autoReset = b,
            ne.enabled = U,
            ne.autoUpdate = z,
            ne.needsUpdate = H,
            ne.type = N
        }
        function oe(b) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", b.statusMessage)
        }
        function Pe(b) {
            const U = b.target;
            U.removeEventListener("dispose", Pe),
            qe(U)
        }
        function qe(b) {
            ht(b),
            ue.remove(b)
        }
        function ht(b) {
            const U = ue.get(b).programs;
            U !== void 0 && (U.forEach(function(z) {
                J.releaseProgram(z)
            }),
            b.isShaderMaterial && J.releaseShaderCache(b))
        }
        this.renderBufferDirect = function(b, U, z, H, N, re) {
            U === null && (U = Ne);
            const pe = N.isMesh && N.matrixWorld.determinant() < 0
              , ye = Mh(b, U, z, H, N);
            Y.setMaterial(H, pe);
            let Se = z.index
              , De = 1;
            if (H.wireframe === !0) {
                if (Se = $.getWireframeAttribute(z),
                Se === void 0)
                    return;
                De = 2
            }
            const Ie = z.drawRange
              , Ee = z.attributes.position;
            let $e = Ie.start * De
              , at = (Ie.start + Ie.count) * De;
            re !== null && ($e = Math.max($e, re.start * De),
            at = Math.min(at, (re.start + re.count) * De)),
            Se !== null ? ($e = Math.max($e, 0),
            at = Math.min(at, Se.count)) : Ee != null && ($e = Math.max($e, 0),
            at = Math.min(at, Ee.count));
            const lt = at - $e;
            if (lt < 0 || lt === 1 / 0)
                return;
            Ge.setup(N, H, ye, z, Se);
            let Ut, Ze = Ue;
            if (Se !== null && (Ut = k.get(Se),
            Ze = xe,
            Ze.setIndex(Ut)),
            N.isMesh)
                H.wireframe === !0 ? (Y.setLineWidth(H.wireframeLinewidth * Ye()),
                Ze.setMode(T.LINES)) : Ze.setMode(T.TRIANGLES);
            else if (N.isLine) {
                let Te = H.linewidth;
                Te === void 0 && (Te = 1),
                Y.setLineWidth(Te * Ye()),
                N.isLineSegments ? Ze.setMode(T.LINES) : N.isLineLoop ? Ze.setMode(T.LINE_LOOP) : Ze.setMode(T.LINE_STRIP)
            } else
                N.isPoints ? Ze.setMode(T.POINTS) : N.isSprite && Ze.setMode(T.TRIANGLES);
            if (N.isBatchedMesh)
                if (N._multiDrawInstances !== null)
                    Ze.renderMultiDrawInstances(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount, N._multiDrawInstances);
                else if (Q.get("WEBGL_multi_draw"))
                    Ze.renderMultiDraw(N._multiDrawStarts, N._multiDrawCounts, N._multiDrawCount);
                else {
                    const Te = N._multiDrawStarts
                      , St = N._multiDrawCounts
                      , Je = N._multiDrawCount
                      , Xt = Se ? k.get(Se).bytesPerElement : 1
                      , oi = ue.get(H).currentProgram.getUniforms();
                    for (let Nt = 0; Nt < Je; Nt++)
                        oi.setValue(T, "_gl_DrawID", Nt),
                        Ze.render(Te[Nt] / Xt, St[Nt])
                }
            else if (N.isInstancedMesh)
                Ze.renderInstances($e, lt, N.count);
            else if (z.isInstancedBufferGeometry) {
                const Te = z._maxInstanceCount !== void 0 ? z._maxInstanceCount : 1 / 0
                  , St = Math.min(z.instanceCount, Te);
                Ze.renderInstances($e, lt, St)
            } else
                Ze.render($e, lt)
        }
        ;
        function yt(b, U, z) {
            b.transparent === !0 && b.side === Bt && b.forceSinglePass === !1 ? (b.side = It,
            b.needsUpdate = !0,
            bs(b, U, z),
            b.side = Jt,
            b.needsUpdate = !0,
            bs(b, U, z),
            b.side = Bt) : bs(b, U, z)
        }
        this.compile = function(b, U, z=null) {
            z === null && (z = b),
            m = Me.get(z),
            m.init(U),
            E.push(m),
            z.traverseVisible(function(N) {
                N.isLight && N.layers.test(U.layers) && (m.pushLight(N),
                N.castShadow && m.pushShadow(N))
            }),
            b !== z && b.traverseVisible(function(N) {
                N.isLight && N.layers.test(U.layers) && (m.pushLight(N),
                N.castShadow && m.pushShadow(N))
            }),
            m.setupLights();
            const H = new Set;
            return b.traverse(function(N) {
                const re = N.material;
                if (re)
                    if (Array.isArray(re))
                        for (let pe = 0; pe < re.length; pe++) {
                            const ye = re[pe];
                            yt(ye, z, N),
                            H.add(ye)
                        }
                    else
                        yt(re, z, N),
                        H.add(re)
            }),
            E.pop(),
            m = null,
            H
        }
        ,
        this.compileAsync = function(b, U, z=null) {
            const H = this.compile(b, U, z);
            return new Promise(N => {
                function re() {
                    if (H.forEach(function(pe) {
                        ue.get(pe).currentProgram.isReady() && H.delete(pe)
                    }),
                    H.size === 0) {
                        N(b);
                        return
                    }
                    setTimeout(re, 10)
                }
                Q.get("KHR_parallel_shader_compile") !== null ? re() : setTimeout(re, 10)
            }
            )
        }
        ;
        let Ke = null;
        function pn(b) {
            Ke && Ke(b)
        }
        function en() {
            Xn.stop()
        }
        function Pa() {
            Xn.start()
        }
        const Xn = new jc;
        Xn.setAnimationLoop(pn),
        typeof self < "u" && Xn.setContext(self),
        this.setAnimationLoop = function(b) {
            Ke = b,
            se.setAnimationLoop(b),
            b === null ? Xn.stop() : Xn.start()
        }
        ,
        se.addEventListener("sessionstart", en),
        se.addEventListener("sessionend", Pa),
        this.render = function(b, U) {
            if (U !== void 0 && U.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (v === !0)
                return;
            if (b.matrixWorldAutoUpdate === !0 && b.updateMatrixWorld(),
            U.parent === null && U.matrixWorldAutoUpdate === !0 && U.updateMatrixWorld(),
            se.enabled === !0 && se.isPresenting === !0 && (se.cameraAutoUpdate === !0 && se.updateCamera(U),
            U = se.getCamera()),
            b.isScene === !0 && b.onBeforeRender(_, b, U, A),
            m = Me.get(b, E.length),
            m.init(U),
            E.push(m),
            ve.multiplyMatrices(U.projectionMatrix, U.matrixWorldInverse),
            ze.setFromProjectionMatrix(ve),
            te = this.localClippingEnabled,
            X = Be.init(this.clippingPlanes, te),
            M = ce.get(b, p.length),
            M.init(),
            p.push(M),
            se.enabled === !0 && se.isPresenting === !0) {
                const re = _.xr.getDepthSensingMesh();
                re !== null && Ar(re, U, -1 / 0, _.sortObjects)
            }
            Ar(b, U, 0, _.sortObjects),
            M.finish(),
            _.sortObjects === !0 && M.sort(W, ae),
            Le = se.enabled === !1 || se.isPresenting === !1 || se.hasDepthSensing() === !1,
            Le && ge.addToRenderList(M, b),
            this.info.render.frame++,
            X === !0 && Be.beginShadows();
            const z = m.state.shadowsArray;
            ne.render(z, b, U),
            X === !0 && Be.endShadows(),
            this.info.autoReset === !0 && this.info.reset();
            const H = M.opaque
              , N = M.transmissive;
            if (m.setupLights(),
            U.isArrayCamera) {
                const re = U.cameras;
                if (N.length > 0)
                    for (let pe = 0, ye = re.length; pe < ye; pe++) {
                        const Se = re[pe];
                        La(H, N, b, Se)
                    }
                Le && ge.render(b);
                for (let pe = 0, ye = re.length; pe < ye; pe++) {
                    const Se = re[pe];
                    Da(M, b, Se, Se.viewport)
                }
            } else
                N.length > 0 && La(H, N, b, U),
                Le && ge.render(b),
                Da(M, b, U);
            A !== null && (_e.updateMultisampleRenderTarget(A),
            _e.updateRenderTargetMipmap(A)),
            b.isScene === !0 && b.onAfterRender(_, b, U),
            Ge.resetDefaultState(),
            w = -1,
            S = null,
            E.pop(),
            E.length > 0 ? (m = E[E.length - 1],
            X === !0 && Be.setGlobalState(_.clippingPlanes, m.state.camera)) : m = null,
            p.pop(),
            p.length > 0 ? M = p[p.length - 1] : M = null
        }
        ;
        function Ar(b, U, z, H) {
            if (b.visible === !1)
                return;
            if (b.layers.test(U.layers)) {
                if (b.isGroup)
                    z = b.renderOrder;
                else if (b.isLOD)
                    b.autoUpdate === !0 && b.update(U);
                else if (b.isLight)
                    m.pushLight(b),
                    b.castShadow && m.pushShadow(b);
                else if (b.isSprite) {
                    if (!b.frustumCulled || ze.intersectsSprite(b)) {
                        H && Ae.setFromMatrixPosition(b.matrixWorld).applyMatrix4(ve);
                        const pe = K.update(b)
                          , ye = b.material;
                        ye.visible && M.push(b, pe, ye, z, Ae.z, null)
                    }
                } else if ((b.isMesh || b.isLine || b.isPoints) && (!b.frustumCulled || ze.intersectsObject(b))) {
                    const pe = K.update(b)
                      , ye = b.material;
                    if (H && (b.boundingSphere !== void 0 ? (b.boundingSphere === null && b.computeBoundingSphere(),
                    Ae.copy(b.boundingSphere.center)) : (pe.boundingSphere === null && pe.computeBoundingSphere(),
                    Ae.copy(pe.boundingSphere.center)),
                    Ae.applyMatrix4(b.matrixWorld).applyMatrix4(ve)),
                    Array.isArray(ye)) {
                        const Se = pe.groups;
                        for (let De = 0, Ie = Se.length; De < Ie; De++) {
                            const Ee = Se[De]
                              , $e = ye[Ee.materialIndex];
                            $e && $e.visible && M.push(b, pe, $e, z, Ae.z, Ee)
                        }
                    } else
                        ye.visible && M.push(b, pe, ye, z, Ae.z, null)
                }
            }
            const re = b.children;
            for (let pe = 0, ye = re.length; pe < ye; pe++)
                Ar(re[pe], U, z, H)
        }
        function Da(b, U, z, H) {
            const N = b.opaque
              , re = b.transmissive
              , pe = b.transparent;
            m.setupLightsView(z),
            X === !0 && Be.setGlobalState(_.clippingPlanes, z),
            H && Y.viewport(y.copy(H)),
            N.length > 0 && Ss(N, U, z),
            re.length > 0 && Ss(re, U, z),
            pe.length > 0 && Ss(pe, U, z),
            Y.buffers.depth.setTest(!0),
            Y.buffers.depth.setMask(!0),
            Y.buffers.color.setMask(!0),
            Y.setPolygonOffset(!1)
        }
        function La(b, U, z, H) {
            if ((z.isScene === !0 ? z.overrideMaterial : null) !== null)
                return;
            m.state.transmissionRenderTarget[H.id] === void 0 && (m.state.transmissionRenderTarget[H.id] = new Wn(1,1,{
                generateMipmaps: !0,
                type: Q.has("EXT_color_buffer_half_float") || Q.has("EXT_color_buffer_float") ? on : Cn,
                minFilter: rn,
                samples: 4,
                stencilBuffer: r,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: je.workingColorSpace
            }));
            const re = m.state.transmissionRenderTarget[H.id]
              , pe = H.viewport || y;
            re.setSize(pe.z, pe.w);
            const ye = _.getRenderTarget();
            _.setRenderTarget(re),
            _.getClearColor(F),
            O = _.getClearAlpha(),
            O < 1 && _.setClearColor(16777215, .5),
            _.clear(),
            Le && ge.render(z);
            const Se = _.toneMapping;
            _.toneMapping = Rn;
            const De = H.viewport;
            if (H.viewport !== void 0 && (H.viewport = void 0),
            m.setupLightsView(H),
            X === !0 && Be.setGlobalState(_.clippingPlanes, H),
            Ss(b, z, H),
            _e.updateMultisampleRenderTarget(re),
            _e.updateRenderTargetMipmap(re),
            Q.has("WEBGL_multisampled_render_to_texture") === !1) {
                let Ie = !1;
                for (let Ee = 0, $e = U.length; Ee < $e; Ee++) {
                    const at = U[Ee]
                      , lt = at.object
                      , Ut = at.geometry
                      , Ze = at.material
                      , Te = at.group;
                    if (Ze.side === Bt && lt.layers.test(H.layers)) {
                        const St = Ze.side;
                        Ze.side = It,
                        Ze.needsUpdate = !0,
                        Ia(lt, z, H, Ut, Ze, Te),
                        Ze.side = St,
                        Ze.needsUpdate = !0,
                        Ie = !0
                    }
                }
                Ie === !0 && (_e.updateMultisampleRenderTarget(re),
                _e.updateRenderTargetMipmap(re))
            }
            _.setRenderTarget(ye),
            _.setClearColor(F, O),
            De !== void 0 && (H.viewport = De),
            _.toneMapping = Se
        }
        function Ss(b, U, z) {
            const H = U.isScene === !0 ? U.overrideMaterial : null;
            for (let N = 0, re = b.length; N < re; N++) {
                const pe = b[N]
                  , ye = pe.object
                  , Se = pe.geometry
                  , De = H === null ? pe.material : H
                  , Ie = pe.group;
                ye.layers.test(z.layers) && Ia(ye, U, z, Se, De, Ie)
            }
        }
        function Ia(b, U, z, H, N, re) {
            b.onBeforeRender(_, U, z, H, N, re),
            b.modelViewMatrix.multiplyMatrices(z.matrixWorldInverse, b.matrixWorld),
            b.normalMatrix.getNormalMatrix(b.modelViewMatrix),
            N.onBeforeRender(_, U, z, H, b, re),
            N.transparent === !0 && N.side === Bt && N.forceSinglePass === !1 ? (N.side = It,
            N.needsUpdate = !0,
            _.renderBufferDirect(z, U, H, N, b, re),
            N.side = Jt,
            N.needsUpdate = !0,
            _.renderBufferDirect(z, U, H, N, b, re),
            N.side = Bt) : _.renderBufferDirect(z, U, H, N, b, re),
            b.onAfterRender(_, U, z, H, N, re)
        }
        function bs(b, U, z) {
            U.isScene !== !0 && (U = Ne);
            const H = ue.get(b)
              , N = m.state.lights
              , re = m.state.shadowsArray
              , pe = N.state.version
              , ye = J.getParameters(b, N.state, re, U, z)
              , Se = J.getProgramCacheKey(ye);
            let De = H.programs;
            H.environment = b.isMeshStandardMaterial ? U.environment : null,
            H.fog = U.fog,
            H.envMap = (b.isMeshStandardMaterial ? x : R).get(b.envMap || H.environment),
            H.envMapRotation = H.environment !== null && b.envMap === null ? U.environmentRotation : b.envMapRotation,
            De === void 0 && (b.addEventListener("dispose", Pe),
            De = new Map,
            H.programs = De);
            let Ie = De.get(Se);
            if (Ie !== void 0) {
                if (H.currentProgram === Ie && H.lightsStateVersion === pe)
                    return Na(b, ye),
                    Ie
            } else
                ye.uniforms = J.getUniforms(b),
                b.onBeforeCompile(ye, _),
                Ie = J.acquireProgram(ye, Se),
                De.set(Se, Ie),
                H.uniforms = ye.uniforms;
            const Ee = H.uniforms;
            return (!b.isShaderMaterial && !b.isRawShaderMaterial || b.clipping === !0) && (Ee.clippingPlanes = Be.uniform),
            Na(b, ye),
            H.needsLights = vh(b),
            H.lightsStateVersion = pe,
            H.needsLights && (Ee.ambientLightColor.value = N.state.ambient,
            Ee.lightProbe.value = N.state.probe,
            Ee.directionalLights.value = N.state.directional,
            Ee.directionalLightShadows.value = N.state.directionalShadow,
            Ee.spotLights.value = N.state.spot,
            Ee.spotLightShadows.value = N.state.spotShadow,
            Ee.rectAreaLights.value = N.state.rectArea,
            Ee.ltc_1.value = N.state.rectAreaLTC1,
            Ee.ltc_2.value = N.state.rectAreaLTC2,
            Ee.pointLights.value = N.state.point,
            Ee.pointLightShadows.value = N.state.pointShadow,
            Ee.hemisphereLights.value = N.state.hemi,
            Ee.directionalShadowMap.value = N.state.directionalShadowMap,
            Ee.directionalShadowMatrix.value = N.state.directionalShadowMatrix,
            Ee.spotShadowMap.value = N.state.spotShadowMap,
            Ee.spotLightMatrix.value = N.state.spotLightMatrix,
            Ee.spotLightMap.value = N.state.spotLightMap,
            Ee.pointShadowMap.value = N.state.pointShadowMap,
            Ee.pointShadowMatrix.value = N.state.pointShadowMatrix),
            H.currentProgram = Ie,
            H.uniformsList = null,
            Ie
        }
        function Ua(b) {
            if (b.uniformsList === null) {
                const U = b.currentProgram.getUniforms();
                b.uniformsList = cr.seqWithValue(U.seq, b.uniforms)
            }
            return b.uniformsList
        }
        function Na(b, U) {
            const z = ue.get(b);
            z.outputColorSpace = U.outputColorSpace,
            z.batching = U.batching,
            z.batchingColor = U.batchingColor,
            z.instancing = U.instancing,
            z.instancingColor = U.instancingColor,
            z.instancingMorph = U.instancingMorph,
            z.skinning = U.skinning,
            z.morphTargets = U.morphTargets,
            z.morphNormals = U.morphNormals,
            z.morphColors = U.morphColors,
            z.morphTargetsCount = U.morphTargetsCount,
            z.numClippingPlanes = U.numClippingPlanes,
            z.numIntersection = U.numClipIntersection,
            z.vertexAlphas = U.vertexAlphas,
            z.vertexTangents = U.vertexTangents,
            z.toneMapping = U.toneMapping
        }
        function Mh(b, U, z, H, N) {
            U.isScene !== !0 && (U = Ne),
            _e.resetTextureUnits();
            const re = U.fog
              , pe = H.isMeshStandardMaterial ? U.environment : null
              , ye = A === null ? _.outputColorSpace : A.isXRRenderTarget === !0 ? A.texture.colorSpace : xt
              , Se = (H.isMeshStandardMaterial ? x : R).get(H.envMap || pe)
              , De = H.vertexColors === !0 && !!z.attributes.color && z.attributes.color.itemSize === 4
              , Ie = !!z.attributes.tangent && (!!H.normalMap || H.anisotropy > 0)
              , Ee = !!z.morphAttributes.position
              , $e = !!z.morphAttributes.normal
              , at = !!z.morphAttributes.color;
            let lt = Rn;
            H.toneMapped && (A === null || A.isXRRenderTarget === !0) && (lt = _.toneMapping);
            const Ut = z.morphAttributes.position || z.morphAttributes.normal || z.morphAttributes.color
              , Ze = Ut !== void 0 ? Ut.length : 0
              , Te = ue.get(H)
              , St = m.state.lights;
            if (X === !0 && (te === !0 || b !== S)) {
                const zt = b === S && H.id === w;
                Be.setState(H, b, zt)
            }
            let Je = !1;
            H.version === Te.__version ? (Te.needsLights && Te.lightsStateVersion !== St.state.version || Te.outputColorSpace !== ye || N.isBatchedMesh && Te.batching === !1 || !N.isBatchedMesh && Te.batching === !0 || N.isBatchedMesh && Te.batchingColor === !0 && N.colorTexture === null || N.isBatchedMesh && Te.batchingColor === !1 && N.colorTexture !== null || N.isInstancedMesh && Te.instancing === !1 || !N.isInstancedMesh && Te.instancing === !0 || N.isSkinnedMesh && Te.skinning === !1 || !N.isSkinnedMesh && Te.skinning === !0 || N.isInstancedMesh && Te.instancingColor === !0 && N.instanceColor === null || N.isInstancedMesh && Te.instancingColor === !1 && N.instanceColor !== null || N.isInstancedMesh && Te.instancingMorph === !0 && N.morphTexture === null || N.isInstancedMesh && Te.instancingMorph === !1 && N.morphTexture !== null || Te.envMap !== Se || H.fog === !0 && Te.fog !== re || Te.numClippingPlanes !== void 0 && (Te.numClippingPlanes !== Be.numPlanes || Te.numIntersection !== Be.numIntersection) || Te.vertexAlphas !== De || Te.vertexTangents !== Ie || Te.morphTargets !== Ee || Te.morphNormals !== $e || Te.morphColors !== at || Te.toneMapping !== lt || Te.morphTargetsCount !== Ze) && (Je = !0) : (Je = !0,
            Te.__version = H.version);
            let Xt = Te.currentProgram;
            Je === !0 && (Xt = bs(H, U, N));
            let oi = !1
              , Nt = !1
              , Rr = !1;
            const dt = Xt.getUniforms()
              , Ln = Te.uniforms;
            if (Y.useProgram(Xt.program) && (oi = !0,
            Nt = !0,
            Rr = !0),
            H.id !== w && (w = H.id,
            Nt = !0),
            oi || S !== b) {
                dt.setValue(T, "projectionMatrix", b.projectionMatrix),
                dt.setValue(T, "viewMatrix", b.matrixWorldInverse);
                const zt = dt.map.cameraPosition;
                zt !== void 0 && zt.setValue(T, de.setFromMatrixPosition(b.matrixWorld)),
                fe.logarithmicDepthBuffer && dt.setValue(T, "logDepthBufFC", 2 / (Math.log(b.far + 1) / Math.LN2)),
                (H.isMeshPhongMaterial || H.isMeshToonMaterial || H.isMeshLambertMaterial || H.isMeshBasicMaterial || H.isMeshStandardMaterial || H.isShaderMaterial) && dt.setValue(T, "isOrthographic", b.isOrthographicCamera === !0),
                S !== b && (S = b,
                Nt = !0,
                Rr = !0)
            }
            if (N.isSkinnedMesh) {
                dt.setOptional(T, N, "bindMatrix"),
                dt.setOptional(T, N, "bindMatrixInverse");
                const zt = N.skeleton;
                zt && (zt.boneTexture === null && zt.computeBoneTexture(),
                dt.setValue(T, "boneTexture", zt.boneTexture, _e))
            }
            N.isBatchedMesh && (dt.setOptional(T, N, "batchingTexture"),
            dt.setValue(T, "batchingTexture", N._matricesTexture, _e),
            dt.setOptional(T, N, "batchingIdTexture"),
            dt.setValue(T, "batchingIdTexture", N._indirectTexture, _e),
            dt.setOptional(T, N, "batchingColorTexture"),
            N._colorsTexture !== null && dt.setValue(T, "batchingColorTexture", N._colorsTexture, _e));
            const Cr = z.morphAttributes;
            if ((Cr.position !== void 0 || Cr.normal !== void 0 || Cr.color !== void 0) && Xe.update(N, z, Xt),
            (Nt || Te.receiveShadow !== N.receiveShadow) && (Te.receiveShadow = N.receiveShadow,
            dt.setValue(T, "receiveShadow", N.receiveShadow)),
            H.isMeshGouraudMaterial && H.envMap !== null && (Ln.envMap.value = Se,
            Ln.flipEnvMap.value = Se.isCubeTexture && Se.isRenderTargetTexture === !1 ? -1 : 1),
            H.isMeshStandardMaterial && H.envMap === null && U.environment !== null && (Ln.envMapIntensity.value = U.environmentIntensity),
            Nt && (dt.setValue(T, "toneMappingExposure", _.toneMappingExposure),
            Te.needsLights && _h(Ln, Rr),
            re && H.fog === !0 && we.refreshFogUniforms(Ln, re),
            we.refreshMaterialUniforms(Ln, H, q, B, m.state.transmissionRenderTarget[b.id]),
            cr.upload(T, Ua(Te), Ln, _e)),
            H.isShaderMaterial && H.uniformsNeedUpdate === !0 && (cr.upload(T, Ua(Te), Ln, _e),
            H.uniformsNeedUpdate = !1),
            H.isSpriteMaterial && dt.setValue(T, "center", N.center),
            dt.setValue(T, "modelViewMatrix", N.modelViewMatrix),
            dt.setValue(T, "normalMatrix", N.normalMatrix),
            dt.setValue(T, "modelMatrix", N.matrixWorld),
            H.isShaderMaterial || H.isRawShaderMaterial) {
                const zt = H.uniformsGroups;
                for (let Pr = 0, xh = zt.length; Pr < xh; Pr++) {
                    const Fa = zt[Pr];
                    rt.update(Fa, Xt),
                    rt.bind(Fa, Xt)
                }
            }
            return Xt
        }
        function _h(b, U) {
            b.ambientLightColor.needsUpdate = U,
            b.lightProbe.needsUpdate = U,
            b.directionalLights.needsUpdate = U,
            b.directionalLightShadows.needsUpdate = U,
            b.pointLights.needsUpdate = U,
            b.pointLightShadows.needsUpdate = U,
            b.spotLights.needsUpdate = U,
            b.spotLightShadows.needsUpdate = U,
            b.rectAreaLights.needsUpdate = U,
            b.hemisphereLights.needsUpdate = U
        }
        function vh(b) {
            return b.isMeshLambertMaterial || b.isMeshToonMaterial || b.isMeshPhongMaterial || b.isMeshStandardMaterial || b.isShadowMaterial || b.isShaderMaterial && b.lights === !0
        }
        this.getActiveCubeFace = function() {
            return L
        }
        ,
        this.getActiveMipmapLevel = function() {
            return P
        }
        ,
        this.getRenderTarget = function() {
            return A
        }
        ,
        this.setRenderTargetTextures = function(b, U, z) {
            ue.get(b.texture).__webglTexture = U,
            ue.get(b.depthTexture).__webglTexture = z;
            const H = ue.get(b);
            H.__hasExternalTextures = !0,
            H.__autoAllocateDepthBuffer = z === void 0,
            H.__autoAllocateDepthBuffer || Q.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"),
            H.__useRenderToTexture = !1)
        }
        ,
        this.setRenderTargetFramebuffer = function(b, U) {
            const z = ue.get(b);
            z.__webglFramebuffer = U,
            z.__useDefaultFramebuffer = U === void 0
        }
        ,
        this.setRenderTarget = function(b, U=0, z=0) {
            A = b,
            L = U,
            P = z;
            let H = !0
              , N = null
              , re = !1
              , pe = !1;
            if (b) {
                const Se = ue.get(b);
                if (Se.__useDefaultFramebuffer !== void 0)
                    Y.bindFramebuffer(T.FRAMEBUFFER, null),
                    H = !1;
                else if (Se.__webglFramebuffer === void 0)
                    _e.setupRenderTarget(b);
                else if (Se.__hasExternalTextures)
                    _e.rebindTextures(b, ue.get(b.texture).__webglTexture, ue.get(b.depthTexture).__webglTexture);
                else if (b.depthBuffer) {
                    const Ee = b.depthTexture;
                    if (Se.__boundDepthTexture !== Ee) {
                        if (Ee !== null && ue.has(Ee) && (b.width !== Ee.image.width || b.height !== Ee.image.height))
                            throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        _e.setupDepthRenderbuffer(b)
                    }
                }
                const De = b.texture;
                (De.isData3DTexture || De.isDataArrayTexture || De.isCompressedArrayTexture) && (pe = !0);
                const Ie = ue.get(b).__webglFramebuffer;
                b.isWebGLCubeRenderTarget ? (Array.isArray(Ie[U]) ? N = Ie[U][z] : N = Ie[U],
                re = !0) : b.samples > 0 && _e.useMultisampledRTT(b) === !1 ? N = ue.get(b).__webglMultisampledFramebuffer : Array.isArray(Ie) ? N = Ie[z] : N = Ie,
                y.copy(b.viewport),
                D.copy(b.scissor),
                G = b.scissorTest
            } else
                y.copy(le).multiplyScalar(q).floor(),
                D.copy(me).multiplyScalar(q).floor(),
                G = Ce;
            if (Y.bindFramebuffer(T.FRAMEBUFFER, N) && H && Y.drawBuffers(b, N),
            Y.viewport(y),
            Y.scissor(D),
            Y.setScissorTest(G),
            re) {
                const Se = ue.get(b.texture);
                T.framebufferTexture2D(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, T.TEXTURE_CUBE_MAP_POSITIVE_X + U, Se.__webglTexture, z)
            } else if (pe) {
                const Se = ue.get(b.texture)
                  , De = U || 0;
                T.framebufferTextureLayer(T.FRAMEBUFFER, T.COLOR_ATTACHMENT0, Se.__webglTexture, z || 0, De)
            }
            w = -1
        }
        ,
        this.readRenderTargetPixels = function(b, U, z, H, N, re, pe) {
            if (!(b && b.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let ye = ue.get(b).__webglFramebuffer;
            if (b.isWebGLCubeRenderTarget && pe !== void 0 && (ye = ye[pe]),
            ye) {
                Y.bindFramebuffer(T.FRAMEBUFFER, ye);
                try {
                    const Se = b.texture
                      , De = Se.format
                      , Ie = Se.type;
                    if (!fe.textureFormatReadable(De)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!fe.textureTypeReadable(Ie)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    U >= 0 && U <= b.width - H && z >= 0 && z <= b.height - N && T.readPixels(U, z, H, N, Fe.convert(De), Fe.convert(Ie), re)
                } finally {
                    const Se = A !== null ? ue.get(A).__webglFramebuffer : null;
                    Y.bindFramebuffer(T.FRAMEBUFFER, Se)
                }
            }
        }
        ,
        this.readRenderTargetPixelsAsync = async function(b, U, z, H, N, re, pe) {
            if (!(b && b.isWebGLRenderTarget))
                throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let ye = ue.get(b).__webglFramebuffer;
            if (b.isWebGLCubeRenderTarget && pe !== void 0 && (ye = ye[pe]),
            ye) {
                Y.bindFramebuffer(T.FRAMEBUFFER, ye);
                try {
                    const Se = b.texture
                      , De = Se.format
                      , Ie = Se.type;
                    if (!fe.textureFormatReadable(De))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                    if (!fe.textureTypeReadable(Ie))
                        throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                    if (U >= 0 && U <= b.width - H && z >= 0 && z <= b.height - N) {
                        const Ee = T.createBuffer();
                        T.bindBuffer(T.PIXEL_PACK_BUFFER, Ee),
                        T.bufferData(T.PIXEL_PACK_BUFFER, re.byteLength, T.STREAM_READ),
                        T.readPixels(U, z, H, N, Fe.convert(De), Fe.convert(Ie), 0),
                        T.flush();
                        const $e = T.fenceSync(T.SYNC_GPU_COMMANDS_COMPLETE, 0);
                        await wd(T, $e, 4);
                        try {
                            T.bindBuffer(T.PIXEL_PACK_BUFFER, Ee),
                            T.getBufferSubData(T.PIXEL_PACK_BUFFER, 0, re)
                        } finally {
                            T.deleteBuffer(Ee),
                            T.deleteSync($e)
                        }
                        return re
                    }
                } finally {
                    const Se = A !== null ? ue.get(A).__webglFramebuffer : null;
                    Y.bindFramebuffer(T.FRAMEBUFFER, Se)
                }
            }
        }
        ,
        this.copyFramebufferToTexture = function(b, U=null, z=0) {
            b.isTexture !== !0 && (Pi("WebGLRenderer: copyFramebufferToTexture function signature has changed."),
            U = arguments[0] || null,
            b = arguments[1]);
            const H = Math.pow(2, -z)
              , N = Math.floor(b.image.width * H)
              , re = Math.floor(b.image.height * H)
              , pe = U !== null ? U.x : 0
              , ye = U !== null ? U.y : 0;
            _e.setTexture2D(b, 0),
            T.copyTexSubImage2D(T.TEXTURE_2D, z, 0, 0, pe, ye, N, re),
            Y.unbindTexture()
        }
        ,
        this.copyTextureToTexture = function(b, U, z=null, H=null, N=0) {
            b.isTexture !== !0 && (Pi("WebGLRenderer: copyTextureToTexture function signature has changed."),
            H = arguments[0] || null,
            b = arguments[1],
            U = arguments[2],
            N = arguments[3] || 0,
            z = null);
            let re, pe, ye, Se, De, Ie;
            z !== null ? (re = z.max.x - z.min.x,
            pe = z.max.y - z.min.y,
            ye = z.min.x,
            Se = z.min.y) : (re = b.image.width,
            pe = b.image.height,
            ye = 0,
            Se = 0),
            H !== null ? (De = H.x,
            Ie = H.y) : (De = 0,
            Ie = 0);
            const Ee = Fe.convert(U.format)
              , $e = Fe.convert(U.type);
            _e.setTexture2D(U, 0),
            T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL, U.flipY),
            T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
            T.pixelStorei(T.UNPACK_ALIGNMENT, U.unpackAlignment);
            const at = T.getParameter(T.UNPACK_ROW_LENGTH)
              , lt = T.getParameter(T.UNPACK_IMAGE_HEIGHT)
              , Ut = T.getParameter(T.UNPACK_SKIP_PIXELS)
              , Ze = T.getParameter(T.UNPACK_SKIP_ROWS)
              , Te = T.getParameter(T.UNPACK_SKIP_IMAGES)
              , St = b.isCompressedTexture ? b.mipmaps[N] : b.image;
            T.pixelStorei(T.UNPACK_ROW_LENGTH, St.width),
            T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, St.height),
            T.pixelStorei(T.UNPACK_SKIP_PIXELS, ye),
            T.pixelStorei(T.UNPACK_SKIP_ROWS, Se),
            b.isDataTexture ? T.texSubImage2D(T.TEXTURE_2D, N, De, Ie, re, pe, Ee, $e, St.data) : b.isCompressedTexture ? T.compressedTexSubImage2D(T.TEXTURE_2D, N, De, Ie, St.width, St.height, Ee, St.data) : T.texSubImage2D(T.TEXTURE_2D, N, De, Ie, re, pe, Ee, $e, St),
            T.pixelStorei(T.UNPACK_ROW_LENGTH, at),
            T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, lt),
            T.pixelStorei(T.UNPACK_SKIP_PIXELS, Ut),
            T.pixelStorei(T.UNPACK_SKIP_ROWS, Ze),
            T.pixelStorei(T.UNPACK_SKIP_IMAGES, Te),
            N === 0 && U.generateMipmaps && T.generateMipmap(T.TEXTURE_2D),
            Y.unbindTexture()
        }
        ,
        this.copyTextureToTexture3D = function(b, U, z=null, H=null, N=0) {
            b.isTexture !== !0 && (Pi("WebGLRenderer: copyTextureToTexture3D function signature has changed."),
            z = arguments[0] || null,
            H = arguments[1] || null,
            b = arguments[2],
            U = arguments[3],
            N = arguments[4] || 0);
            let re, pe, ye, Se, De, Ie, Ee, $e, at;
            const lt = b.isCompressedTexture ? b.mipmaps[N] : b.image;
            z !== null ? (re = z.max.x - z.min.x,
            pe = z.max.y - z.min.y,
            ye = z.max.z - z.min.z,
            Se = z.min.x,
            De = z.min.y,
            Ie = z.min.z) : (re = lt.width,
            pe = lt.height,
            ye = lt.depth,
            Se = 0,
            De = 0,
            Ie = 0),
            H !== null ? (Ee = H.x,
            $e = H.y,
            at = H.z) : (Ee = 0,
            $e = 0,
            at = 0);
            const Ut = Fe.convert(U.format)
              , Ze = Fe.convert(U.type);
            let Te;
            if (U.isData3DTexture)
                _e.setTexture3D(U, 0),
                Te = T.TEXTURE_3D;
            else if (U.isDataArrayTexture || U.isCompressedArrayTexture)
                _e.setTexture2DArray(U, 0),
                Te = T.TEXTURE_2D_ARRAY;
            else {
                console.warn("THREE.WebGLRenderer.copyTextureToTexture3D: only supports THREE.DataTexture3D and THREE.DataTexture2DArray.");
                return
            }
            T.pixelStorei(T.UNPACK_FLIP_Y_WEBGL, U.flipY),
            T.pixelStorei(T.UNPACK_PREMULTIPLY_ALPHA_WEBGL, U.premultiplyAlpha),
            T.pixelStorei(T.UNPACK_ALIGNMENT, U.unpackAlignment);
            const St = T.getParameter(T.UNPACK_ROW_LENGTH)
              , Je = T.getParameter(T.UNPACK_IMAGE_HEIGHT)
              , Xt = T.getParameter(T.UNPACK_SKIP_PIXELS)
              , oi = T.getParameter(T.UNPACK_SKIP_ROWS)
              , Nt = T.getParameter(T.UNPACK_SKIP_IMAGES);
            T.pixelStorei(T.UNPACK_ROW_LENGTH, lt.width),
            T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, lt.height),
            T.pixelStorei(T.UNPACK_SKIP_PIXELS, Se),
            T.pixelStorei(T.UNPACK_SKIP_ROWS, De),
            T.pixelStorei(T.UNPACK_SKIP_IMAGES, Ie),
            b.isDataTexture || b.isData3DTexture ? T.texSubImage3D(Te, N, Ee, $e, at, re, pe, ye, Ut, Ze, lt.data) : U.isCompressedArrayTexture ? T.compressedTexSubImage3D(Te, N, Ee, $e, at, re, pe, ye, Ut, lt.data) : T.texSubImage3D(Te, N, Ee, $e, at, re, pe, ye, Ut, Ze, lt),
            T.pixelStorei(T.UNPACK_ROW_LENGTH, St),
            T.pixelStorei(T.UNPACK_IMAGE_HEIGHT, Je),
            T.pixelStorei(T.UNPACK_SKIP_PIXELS, Xt),
            T.pixelStorei(T.UNPACK_SKIP_ROWS, oi),
            T.pixelStorei(T.UNPACK_SKIP_IMAGES, Nt),
            N === 0 && U.generateMipmaps && T.generateMipmap(Te),
            Y.unbindTexture()
        }
        ,
        this.initRenderTarget = function(b) {
            ue.get(b).__webglFramebuffer === void 0 && _e.setupRenderTarget(b)
        }
        ,
        this.initTexture = function(b) {
            b.isCubeTexture ? _e.setTextureCube(b, 0) : b.isData3DTexture ? _e.setTexture3D(b, 0) : b.isDataArrayTexture || b.isCompressedArrayTexture ? _e.setTexture2DArray(b, 0) : _e.setTexture2D(b, 0),
            Y.unbindTexture()
        }
        ,
        this.resetState = function() {
            L = 0,
            P = 0,
            A = null,
            Y.reset(),
            Ge.reset()
        }
        ,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    get coordinateSystem() {
        return Tn
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorSpace = e === da ? "display-p3" : "srgb",
        t.unpackColorSpace = je.workingColorSpace === xr ? "display-p3" : "srgb"
    }
}
class zg extends it {
    constructor() {
        super(),
        this.isScene = !0,
        this.type = "Scene",
        this.background = null,
        this.environment = null,
        this.fog = null,
        this.backgroundBlurriness = 0,
        this.backgroundIntensity = 1,
        this.backgroundRotation = new cn,
        this.environmentIntensity = 1,
        this.environmentRotation = new cn,
        this.overrideMaterial = null,
        typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe",{
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t),
        e.background !== null && (this.background = e.background.clone()),
        e.environment !== null && (this.environment = e.environment.clone()),
        e.fog !== null && (this.fog = e.fog.clone()),
        this.backgroundBlurriness = e.backgroundBlurriness,
        this.backgroundIntensity = e.backgroundIntensity,
        this.backgroundRotation.copy(e.backgroundRotation),
        this.environmentIntensity = e.environmentIntensity,
        this.environmentRotation.copy(e.environmentRotation),
        e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()),
        this.matrixAutoUpdate = e.matrixAutoUpdate,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()),
        this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness),
        this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity),
        t.object.backgroundRotation = this.backgroundRotation.toArray(),
        this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity),
        t.object.environmentRotation = this.environmentRotation.toArray(),
        t
    }
}
class kg {
    constructor(e, t) {
        this.isInterleavedBuffer = !0,
        this.array = e,
        this.stride = t,
        this.count = e !== void 0 ? e.length / t : 0,
        this.usage = Yo,
        this._updateRange = {
            offset: 0,
            count: -1
        },
        this.updateRanges = [],
        this.version = 0,
        this.uuid = Vt()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    get updateRange() {
        return Pi("THREE.InterleavedBuffer: updateRange() is deprecated and will be removed in r169. Use addUpdateRange() instead."),
        this._updateRange
    }
    setUsage(e) {
        return this.usage = e,
        this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array),
        this.count = e.count,
        this.stride = e.stride,
        this.usage = e.usage,
        this
    }
    copyAt(e, t, n) {
        e *= this.stride,
        n *= t.stride;
        for (let i = 0, r = this.stride; i < r; i++)
            this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t=0) {
        return this.array.set(e, t),
        this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vt()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid])
          , n = new this.constructor(t,this.stride);
        return n.setUsage(this.usage),
        n
    }
    onUpload(e) {
        return this.onUploadCallback = e,
        this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}),
        this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = Vt()),
        e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))),
        {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const At = new C;
class Ma {
    constructor(e, t, n, i=!1) {
        this.isInterleavedBufferAttribute = !0,
        this.name = "",
        this.data = e,
        this.itemSize = t,
        this.offset = n,
        this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++)
            At.fromBufferAttribute(this, t),
            At.applyMatrix4(e),
            this.setXYZ(t, At.x, At.y, At.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++)
            At.fromBufferAttribute(this, t),
            At.applyNormalMatrix(e),
            this.setXYZ(t, At.x, At.y, At.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++)
            At.fromBufferAttribute(this, t),
            At.transformDirection(e),
            this.setXYZ(t, At.x, At.y, At.z);
        return this
    }
    getComponent(e, t) {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = Kt(n, this.array)),
        n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = et(n, this.array)),
        this.data.array[e * this.data.stride + this.offset + t] = n,
        this
    }
    setX(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset] = t,
        this
    }
    setY(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 1] = t,
        this
    }
    setZ(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 2] = t,
        this
    }
    setW(e, t) {
        return this.normalized && (t = et(t, this.array)),
        this.data.array[e * this.data.stride + this.offset + 3] = t,
        this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Kt(t, this.array)),
        t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array),
        i = et(i, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this
    }
    setXYZW(e, t, n, i, r) {
        return e = e * this.data.stride + this.offset,
        this.normalized && (t = et(t, this.array),
        n = et(n, this.array),
        i = et(i, this.array),
        r = et(r, this.array)),
        this.data.array[e + 0] = t,
        this.data.array[e + 1] = n,
        this.data.array[e + 2] = i,
        this.data.array[e + 3] = r,
        this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[i + r])
            }
            return new Dt(new this.array.constructor(t),this.itemSize,this.normalized)
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)),
            new Ma(e.interleavedBuffers[this.data.uuid],this.itemSize,this.offset,this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let r = 0; r < this.itemSize; r++)
                    t.push(this.data.array[i + r])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else
            return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}),
            e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)),
            {
                isInterleavedBufferAttribute: !0,
                itemSize: this.itemSize,
                data: this.data.uuid,
                offset: this.offset,
                normalized: this.normalized
            }
    }
}
const Fl = new C
  , Ol = new Qe
  , Bl = new Qe
  , Hg = new C
  , zl = new Oe
  , qs = new C
  , io = new dn
  , kl = new Oe
  , so = new vs;
class Gg extends ct {
    constructor(e, t) {
        super(e, t),
        this.isSkinnedMesh = !0,
        this.type = "SkinnedMesh",
        this.bindMode = Ha,
        this.bindMatrix = new Oe,
        this.bindMatrixInverse = new Oe,
        this.boundingBox = null,
        this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Pn),
        this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, qs),
            this.boundingBox.expandByPoint(qs)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new dn),
        this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++)
            this.getVertexPosition(n, qs),
            this.boundingSphere.expandByPoint(qs)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.bindMode = e.bindMode,
        this.bindMatrix.copy(e.bindMatrix),
        this.bindMatrixInverse.copy(e.bindMatrixInverse),
        this.skeleton = e.skeleton,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    raycast(e, t) {
        const n = this.material
          , i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        io.copy(this.boundingSphere),
        io.applyMatrix4(i),
        e.ray.intersectsSphere(io) !== !1 && (kl.copy(i).invert(),
        so.copy(e.ray).applyMatrix4(kl),
        !(this.boundingBox !== null && so.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, so)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t),
        this.applyBoneTransform(e, t),
        t
    }
    bind(e, t) {
        this.skeleton = e,
        t === void 0 && (this.updateMatrixWorld(!0),
        this.skeleton.calculateInverses(),
        t = this.matrixWorld),
        this.bindMatrix.copy(t),
        this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new Qe
          , t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const r = 1 / e.manhattanLength();
            r !== 1 / 0 ? e.multiplyScalar(r) : e.set(1, 0, 0, 0),
            t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e),
        this.bindMode === Ha ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === $h ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton
          , i = this.geometry;
        Ol.fromBufferAttribute(i.attributes.skinIndex, e),
        Bl.fromBufferAttribute(i.attributes.skinWeight, e),
        Fl.copy(t).applyMatrix4(this.bindMatrix),
        t.set(0, 0, 0);
        for (let r = 0; r < 4; r++) {
            const o = Bl.getComponent(r);
            if (o !== 0) {
                const a = Ol.getComponent(r);
                zl.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]),
                t.addScaledVector(Hg.copy(Fl).applyMatrix4(zl), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class eh extends it {
    constructor() {
        super(),
        this.isBone = !0,
        this.type = "Bone"
    }
}
class _a extends vt {
    constructor(e=null, t=1, n=1, i, r, o, a, l, c=Ct, h=Ct, d, u) {
        super(null, o, a, l, c, h, i, r, d, u),
        this.isDataTexture = !0,
        this.image = {
            data: e,
            width: t,
            height: n
        },
        this.generateMipmaps = !1,
        this.flipY = !1,
        this.unpackAlignment = 1
    }
}
const Hl = new Oe
  , Vg = new Oe;
class va {
    constructor(e=[], t=[]) {
        this.uuid = Vt(),
        this.bones = e.slice(0),
        this.boneInverses = t,
        this.boneMatrices = null,
        this.boneTexture = null,
        this.init()
    }
    init() {
        const e = this.bones
          , t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16),
        t.length === 0)
            this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."),
            this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++)
                this.boneInverses.push(new Oe)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new Oe;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(),
            this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(),
            n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld),
            n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones
          , t = this.boneInverses
          , n = this.boneMatrices
          , i = this.boneTexture;
        for (let r = 0, o = e.length; r < o; r++) {
            const a = e[r] ? e[r].matrixWorld : Vg;
            Hl.multiplyMatrices(a, t[r]),
            Hl.toArray(n, r * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new va(this.bones,this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4,
        e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new _a(t,e,e,Gt,Pt);
        return n.needsUpdate = !0,
        this.boneMatrices = t,
        this.boneTexture = n,
        this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e)
                return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(),
        this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const r = e.bones[n];
            let o = t[r];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", r),
            o = new eh),
            this.bones.push(o),
            this.boneInverses.push(new Oe().fromArray(e.boneInverses[n]))
        }
        return this.init(),
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones
          , n = this.boneInverses;
        for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class Ko extends Dt {
    constructor(e, t, n, i=1) {
        super(e, t, n),
        this.isInstancedBufferAttribute = !0,
        this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e),
        this.meshPerAttribute = e.meshPerAttribute,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute,
        e.isInstancedBufferAttribute = !0,
        e
    }
}
const bi = new Oe
  , Gl = new Oe
  , Ys = []
  , Vl = new Pn
  , Wg = new Oe
  , Ji = new ct
  , Qi = new dn;
class Xg extends ct {
    constructor(e, t, n) {
        super(e, t),
        this.isInstancedMesh = !0,
        this.instanceMatrix = new Ko(new Float32Array(n * 16),16),
        this.instanceColor = null,
        this.morphTexture = null,
        this.count = n,
        this.boundingBox = null,
        this.boundingSphere = null;
        for (let i = 0; i < n; i++)
            this.setMatrixAt(i, Wg)
    }
    computeBoundingBox() {
        const e = this.geometry
          , t = this.count;
        this.boundingBox === null && (this.boundingBox = new Pn),
        e.boundingBox === null && e.computeBoundingBox(),
        this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, bi),
            Vl.copy(e.boundingBox).applyMatrix4(bi),
            this.boundingBox.union(Vl)
    }
    computeBoundingSphere() {
        const e = this.geometry
          , t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new dn),
        e.boundingSphere === null && e.computeBoundingSphere(),
        this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++)
            this.getMatrixAt(n, bi),
            Qi.copy(e.boundingSphere).applyMatrix4(bi),
            this.boundingSphere.union(Qi)
    }
    copy(e, t) {
        return super.copy(e, t),
        this.instanceMatrix.copy(e.instanceMatrix),
        e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()),
        e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()),
        this.count = e.count,
        e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()),
        e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()),
        this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = this.morphTexture.source.data.data
          , r = n.length + 1
          , o = e * r + 1;
        for (let a = 0; a < n.length; a++)
            n[a] = i[o + a]
    }
    raycast(e, t) {
        const n = this.matrixWorld
          , i = this.count;
        if (Ji.geometry = this.geometry,
        Ji.material = this.material,
        Ji.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(),
        Qi.copy(this.boundingSphere),
        Qi.applyMatrix4(n),
        e.ray.intersectsSphere(Qi) !== !1))
            for (let r = 0; r < i; r++) {
                this.getMatrixAt(r, bi),
                Gl.multiplyMatrices(n, bi),
                Ji.matrixWorld = Gl,
                Ji.raycast(e, Ys);
                for (let o = 0, a = Ys.length; o < a; o++) {
                    const l = Ys[o];
                    l.instanceId = r,
                    l.object = this,
                    t.push(l)
                }
                Ys.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new Ko(new Float32Array(this.instanceMatrix.count * 3).fill(1),3)),
        t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const n = t.morphTargetInfluences
          , i = n.length + 1;
        this.morphTexture === null && (this.morphTexture = new _a(new Float32Array(i * this.count),i,this.count,aa,Pt));
        const r = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < n.length; c++)
            o += n[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o
          , l = i * e;
        r[l] = a,
        r.set(n, l + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }),
        this.morphTexture !== null && (this.morphTexture.dispose(),
        this.morphTexture = null),
        this
    }
}
class th extends $t {
    constructor(e) {
        super(),
        this.isLineBasicMaterial = !0,
        this.type = "LineBasicMaterial",
        this.color = new be(16777215),
        this.map = null,
        this.linewidth = 1,
        this.linecap = "round",
        this.linejoin = "round",
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.linewidth = e.linewidth,
        this.linecap = e.linecap,
        this.linejoin = e.linejoin,
        this.fog = e.fog,
        this
    }
}
const Mr = new C
  , _r = new C
  , Wl = new Oe
  , es = new vs
  , js = new dn
  , ro = new C
  , Xl = new C;
class xa extends it {
    constructor(e=new Qt, t=new th) {
        super(),
        this.isLine = !0,
        this.type = "Line",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [0];
            for (let i = 1, r = t.count; i < r; i++)
                Mr.fromBufferAttribute(t, i - 1),
                _r.fromBufferAttribute(t, i),
                n[i] = n[i - 1],
                n[i] += Mr.distanceTo(_r);
            e.setAttribute("lineDistance", new Zt(n,1))
        } else
            console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Line.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        js.copy(n.boundingSphere),
        js.applyMatrix4(i),
        js.radius += r,
        e.ray.intersectsSphere(js) === !1)
            return;
        Wl.copy(i).invert(),
        es.copy(e.ray).applyMatrix4(Wl);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = this.isLineSegments ? 2 : 1
          , h = n.index
          , u = n.attributes.position;
        if (h !== null) {
            const f = Math.max(0, o.start)
              , g = Math.min(h.count, o.start + o.count);
            for (let M = f, m = g - 1; M < m; M += c) {
                const p = h.getX(M)
                  , E = h.getX(M + 1)
                  , _ = Ks(this, e, es, l, p, E);
                _ && t.push(_)
            }
            if (this.isLineLoop) {
                const M = h.getX(g - 1)
                  , m = h.getX(f)
                  , p = Ks(this, e, es, l, M, m);
                p && t.push(p)
            }
        } else {
            const f = Math.max(0, o.start)
              , g = Math.min(u.count, o.start + o.count);
            for (let M = f, m = g - 1; M < m; M += c) {
                const p = Ks(this, e, es, l, M, M + 1);
                p && t.push(p)
            }
            if (this.isLineLoop) {
                const M = Ks(this, e, es, l, g - 1, f);
                M && t.push(M)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = i.length; r < o; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
function Ks(s, e, t, n, i, r) {
    const o = s.geometry.attributes.position;
    if (Mr.fromBufferAttribute(o, i),
    _r.fromBufferAttribute(o, r),
    t.distanceSqToSegment(Mr, _r, ro, Xl) > n)
        return;
    ro.applyMatrix4(s.matrixWorld);
    const l = e.ray.origin.distanceTo(ro);
    if (!(l < e.near || l > e.far))
        return {
            distance: l,
            point: Xl.clone().applyMatrix4(s.matrixWorld),
            index: i,
            face: null,
            faceIndex: null,
            object: s
        }
}
const ql = new C
  , Yl = new C;
class qg extends xa {
    constructor(e, t) {
        super(e, t),
        this.isLineSegments = !0,
        this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position
              , n = [];
            for (let i = 0, r = t.count; i < r; i += 2)
                ql.fromBufferAttribute(t, i),
                Yl.fromBufferAttribute(t, i + 1),
                n[i] = i === 0 ? 0 : n[i - 1],
                n[i + 1] = n[i] + ql.distanceTo(Yl);
            e.setAttribute("lineDistance", new Zt(n,1))
        } else
            console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class Yg extends xa {
    constructor(e, t) {
        super(e, t),
        this.isLineLoop = !0,
        this.type = "LineLoop"
    }
}
class nh extends $t {
    constructor(e) {
        super(),
        this.isPointsMaterial = !0,
        this.type = "PointsMaterial",
        this.color = new be(16777215),
        this.map = null,
        this.alphaMap = null,
        this.size = 1,
        this.sizeAttenuation = !0,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.color.copy(e.color),
        this.map = e.map,
        this.alphaMap = e.alphaMap,
        this.size = e.size,
        this.sizeAttenuation = e.sizeAttenuation,
        this.fog = e.fog,
        this
    }
}
const jl = new Oe
  , $o = new vs
  , $s = new dn
  , Zs = new C;
class jg extends it {
    constructor(e=new Qt, t=new nh) {
        super(),
        this.isPoints = !0,
        this.type = "Points",
        this.geometry = e,
        this.material = t,
        this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.material = Array.isArray(e.material) ? e.material.slice() : e.material,
        this.geometry = e.geometry,
        this
    }
    raycast(e, t) {
        const n = this.geometry
          , i = this.matrixWorld
          , r = e.params.Points.threshold
          , o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(),
        $s.copy(n.boundingSphere),
        $s.applyMatrix4(i),
        $s.radius += r,
        e.ray.intersectsSphere($s) === !1)
            return;
        jl.copy(i).invert(),
        $o.copy(e.ray).applyMatrix4(jl);
        const a = r / ((this.scale.x + this.scale.y + this.scale.z) / 3)
          , l = a * a
          , c = n.index
          , d = n.attributes.position;
        if (c !== null) {
            const u = Math.max(0, o.start)
              , f = Math.min(c.count, o.start + o.count);
            for (let g = u, M = f; g < M; g++) {
                const m = c.getX(g);
                Zs.fromBufferAttribute(d, m),
                Kl(Zs, m, l, i, e, t, this)
            }
        } else {
            const u = Math.max(0, o.start)
              , f = Math.min(d.count, o.start + o.count);
            for (let g = u, M = f; g < M; g++)
                Zs.fromBufferAttribute(d, g),
                Kl(Zs, g, l, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes
          , n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [],
                this.morphTargetDictionary = {};
                for (let r = 0, o = i.length; r < o; r++) {
                    const a = i[r].name || String(r);
                    this.morphTargetInfluences.push(0),
                    this.morphTargetDictionary[a] = r
                }
            }
        }
    }
}
function Kl(s, e, t, n, i, r, o) {
    const a = $o.distanceSqToPoint(s);
    if (a < t) {
        const l = new C;
        $o.closestPointToPoint(s, l),
        l.applyMatrix4(n);
        const c = i.ray.origin.distanceTo(l);
        if (c < i.near || c > i.far)
            return;
        r.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            object: o
        })
    }
}
class un {
    constructor() {
        this.type = "Curve",
        this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."),
        null
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t)
    }
    getPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return t
    }
    getSpacedPoints(e=5) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPointAt(n / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e=this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate)
            return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n, i = this.getPoint(0), r = 0;
        t.push(0);
        for (let o = 1; o <= e; o++)
            n = this.getPoint(o / e),
            r += n.distanceTo(i),
            t.push(r),
            i = n;
        return this.cacheArcLengths = t,
        t
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.getLengths()
    }
    getUtoTmapping(e, t) {
        const n = this.getLengths();
        let i = 0;
        const r = n.length;
        let o;
        t ? o = t : o = e * n[r - 1];
        let a = 0, l = r - 1, c;
        for (; a <= l; )
            if (i = Math.floor(a + (l - a) / 2),
            c = n[i] - o,
            c < 0)
                a = i + 1;
            else if (c > 0)
                l = i - 1;
            else {
                l = i;
                break
            }
        if (i = l,
        n[i] === o)
            return i / (r - 1);
        const h = n[i]
          , u = n[i + 1] - h
          , f = (o - h) / u;
        return (i + f) / (r - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4
          , r = e + 1e-4;
        i < 0 && (i = 0),
        r > 1 && (r = 1);
        const o = this.getPoint(i)
          , a = this.getPoint(r)
          , l = t || (o.isVector2 ? new ee : new C);
        return l.copy(a).sub(o).normalize(),
        l
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t)
    }
    computeFrenetFrames(e, t) {
        const n = new C
          , i = []
          , r = []
          , o = []
          , a = new C
          , l = new Oe;
        for (let f = 0; f <= e; f++) {
            const g = f / e;
            i[f] = this.getTangentAt(g, new C)
        }
        r[0] = new C,
        o[0] = new C;
        let c = Number.MAX_VALUE;
        const h = Math.abs(i[0].x)
          , d = Math.abs(i[0].y)
          , u = Math.abs(i[0].z);
        h <= c && (c = h,
        n.set(1, 0, 0)),
        d <= c && (c = d,
        n.set(0, 1, 0)),
        u <= c && n.set(0, 0, 1),
        a.crossVectors(i[0], n).normalize(),
        r[0].crossVectors(i[0], a),
        o[0].crossVectors(i[0], r[0]);
        for (let f = 1; f <= e; f++) {
            if (r[f] = r[f - 1].clone(),
            o[f] = o[f - 1].clone(),
            a.crossVectors(i[f - 1], i[f]),
            a.length() > Number.EPSILON) {
                a.normalize();
                const g = Math.acos(ft(i[f - 1].dot(i[f]), -1, 1));
                r[f].applyMatrix4(l.makeRotationAxis(a, g))
            }
            o[f].crossVectors(i[f], r[f])
        }
        if (t === !0) {
            let f = Math.acos(ft(r[0].dot(r[e]), -1, 1));
            f /= e,
            i[0].dot(a.crossVectors(r[0], r[e])) > 0 && (f = -f);
            for (let g = 1; g <= e; g++)
                r[g].applyMatrix4(l.makeRotationAxis(i[g], f * g)),
                o[g].crossVectors(i[g], r[g])
        }
        return {
            tangents: i,
            normals: r,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions,
        e.type = this.type,
        e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions,
        this
    }
}
class ya extends un {
    constructor(e=0, t=0, n=1, i=1, r=0, o=Math.PI * 2, a=!1, l=0) {
        super(),
        this.isEllipseCurve = !0,
        this.type = "EllipseCurve",
        this.aX = e,
        this.aY = t,
        this.xRadius = n,
        this.yRadius = i,
        this.aStartAngle = r,
        this.aEndAngle = o,
        this.aClockwise = a,
        this.aRotation = l
    }
    getPoint(e, t=new ee) {
        const n = t
          , i = Math.PI * 2;
        let r = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(r) < Number.EPSILON;
        for (; r < 0; )
            r += i;
        for (; r > i; )
            r -= i;
        r < Number.EPSILON && (o ? r = 0 : r = i),
        this.aClockwise === !0 && !o && (r === i ? r = -i : r = r - i);
        const a = this.aStartAngle + e * r;
        let l = this.aX + this.xRadius * Math.cos(a)
          , c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const h = Math.cos(this.aRotation)
              , d = Math.sin(this.aRotation)
              , u = l - this.aX
              , f = c - this.aY;
            l = u * h - f * d + this.aX,
            c = u * d + f * h + this.aY
        }
        return n.set(l, c)
    }
    copy(e) {
        return super.copy(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX,
        e.aY = this.aY,
        e.xRadius = this.xRadius,
        e.yRadius = this.yRadius,
        e.aStartAngle = this.aStartAngle,
        e.aEndAngle = this.aEndAngle,
        e.aClockwise = this.aClockwise,
        e.aRotation = this.aRotation,
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.aX = e.aX,
        this.aY = e.aY,
        this.xRadius = e.xRadius,
        this.yRadius = e.yRadius,
        this.aStartAngle = e.aStartAngle,
        this.aEndAngle = e.aEndAngle,
        this.aClockwise = e.aClockwise,
        this.aRotation = e.aRotation,
        this
    }
}
class Kg extends ya {
    constructor(e, t, n, i, r, o) {
        super(e, t, n, n, i, r, o),
        this.isArcCurve = !0,
        this.type = "ArcCurve"
    }
}
function Sa() {
    let s = 0
      , e = 0
      , t = 0
      , n = 0;
    function i(r, o, a, l) {
        s = r,
        e = a,
        t = -3 * r + 3 * o - 2 * a - l,
        n = 2 * r - 2 * o + a + l
    }
    return {
        initCatmullRom: function(r, o, a, l, c) {
            i(o, a, c * (a - r), c * (l - o))
        },
        initNonuniformCatmullRom: function(r, o, a, l, c, h, d) {
            let u = (o - r) / c - (a - r) / (c + h) + (a - o) / h
              , f = (a - o) / h - (l - o) / (h + d) + (l - a) / d;
            u *= h,
            f *= h,
            i(o, a, u, f)
        },
        calc: function(r) {
            const o = r * r
              , a = o * r;
            return s + e * r + t * o + n * a
        }
    }
}
const Js = new C
  , oo = new Sa
  , ao = new Sa
  , lo = new Sa;
class $g extends un {
    constructor(e=[], t=!1, n="centripetal", i=.5) {
        super(),
        this.isCatmullRomCurve3 = !0,
        this.type = "CatmullRomCurve3",
        this.points = e,
        this.closed = t,
        this.curveType = n,
        this.tension = i
    }
    getPoint(e, t=new C) {
        const n = t
          , i = this.points
          , r = i.length
          , o = (r - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o)
          , l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / r) + 1) * r : l === 0 && a === r - 1 && (a = r - 2,
        l = 1);
        let c, h;
        this.closed || a > 0 ? c = i[(a - 1) % r] : (Js.subVectors(i[0], i[1]).add(i[0]),
        c = Js);
        const d = i[a % r]
          , u = i[(a + 1) % r];
        if (this.closed || a + 2 < r ? h = i[(a + 2) % r] : (Js.subVectors(i[r - 1], i[r - 2]).add(i[r - 1]),
        h = Js),
        this.curveType === "centripetal" || this.curveType === "chordal") {
            const f = this.curveType === "chordal" ? .5 : .25;
            let g = Math.pow(c.distanceToSquared(d), f)
              , M = Math.pow(d.distanceToSquared(u), f)
              , m = Math.pow(u.distanceToSquared(h), f);
            M < 1e-4 && (M = 1),
            g < 1e-4 && (g = M),
            m < 1e-4 && (m = M),
            oo.initNonuniformCatmullRom(c.x, d.x, u.x, h.x, g, M, m),
            ao.initNonuniformCatmullRom(c.y, d.y, u.y, h.y, g, M, m),
            lo.initNonuniformCatmullRom(c.z, d.z, u.z, h.z, g, M, m)
        } else
            this.curveType === "catmullrom" && (oo.initCatmullRom(c.x, d.x, u.x, h.x, this.tension),
            ao.initCatmullRom(c.y, d.y, u.y, h.y, this.tension),
            lo.initCatmullRom(c.z, d.z, u.z, h.z, this.tension));
        return n.set(oo.calc(l), ao.calc(l), lo.calc(l)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed,
        e.curveType = this.curveType,
        e.tension = this.tension,
        e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new C().fromArray(i))
        }
        return this.closed = e.closed,
        this.curveType = e.curveType,
        this.tension = e.tension,
        this
    }
}
function $l(s, e, t, n, i) {
    const r = (n - e) * .5
      , o = (i - t) * .5
      , a = s * s
      , l = s * a;
    return (2 * t - 2 * n + r + o) * l + (-3 * t + 3 * n - 2 * r - o) * a + r * s + t
}
function Zg(s, e) {
    const t = 1 - s;
    return t * t * e
}
function Jg(s, e) {
    return 2 * (1 - s) * s * e
}
function Qg(s, e) {
    return s * s * e
}
function as(s, e, t, n) {
    return Zg(s, e) + Jg(s, t) + Qg(s, n)
}
function eM(s, e) {
    const t = 1 - s;
    return t * t * t * e
}
function tM(s, e) {
    const t = 1 - s;
    return 3 * t * t * s * e
}
function nM(s, e) {
    return 3 * (1 - s) * s * s * e
}
function iM(s, e) {
    return s * s * s * e
}
function ls(s, e, t, n, i) {
    return eM(s, e) + tM(s, t) + nM(s, n) + iM(s, i)
}
class ih extends un {
    constructor(e=new ee, t=new ee, n=new ee, i=new ee) {
        super(),
        this.isCubicBezierCurve = !0,
        this.type = "CubicBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new ee) {
        const n = t
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ls(e, i.x, r.x, o.x, a.x), ls(e, i.y, r.y, o.y, a.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class sM extends un {
    constructor(e=new C, t=new C, n=new C, i=new C) {
        super(),
        this.isCubicBezierCurve3 = !0,
        this.type = "CubicBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n,
        this.v3 = i
    }
    getPoint(e, t=new C) {
        const n = t
          , i = this.v0
          , r = this.v1
          , o = this.v2
          , a = this.v3;
        return n.set(ls(e, i.x, r.x, o.x, a.x), ls(e, i.y, r.y, o.y, a.y), ls(e, i.z, r.z, o.z, a.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this.v3.copy(e.v3),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e.v3 = this.v3.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this.v3.fromArray(e.v3),
        this
    }
}
class sh extends un {
    constructor(e=new ee, t=new ee) {
        super(),
        this.isLineCurve = !0,
        this.type = "LineCurve",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new ee) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new ee) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class rM extends un {
    constructor(e=new C, t=new C) {
        super(),
        this.isLineCurve3 = !0,
        this.type = "LineCurve3",
        this.v1 = e,
        this.v2 = t
    }
    getPoint(e, t=new C) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1),
        n.multiplyScalar(e).add(this.v1)),
        n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t=new C) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class rh extends un {
    constructor(e=new ee, t=new ee, n=new ee) {
        super(),
        this.isQuadraticBezierCurve = !0,
        this.type = "QuadraticBezierCurve",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new ee) {
        const n = t
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(as(e, i.x, r.x, o.x), as(e, i.y, r.y, o.y)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class oM extends un {
    constructor(e=new C, t=new C, n=new C) {
        super(),
        this.isQuadraticBezierCurve3 = !0,
        this.type = "QuadraticBezierCurve3",
        this.v0 = e,
        this.v1 = t,
        this.v2 = n
    }
    getPoint(e, t=new C) {
        const n = t
          , i = this.v0
          , r = this.v1
          , o = this.v2;
        return n.set(as(e, i.x, r.x, o.x), as(e, i.y, r.y, o.y), as(e, i.z, r.z, o.z)),
        n
    }
    copy(e) {
        return super.copy(e),
        this.v0.copy(e.v0),
        this.v1.copy(e.v1),
        this.v2.copy(e.v2),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(),
        e.v1 = this.v1.toArray(),
        e.v2 = this.v2.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.v0.fromArray(e.v0),
        this.v1.fromArray(e.v1),
        this.v2.fromArray(e.v2),
        this
    }
}
class oh extends un {
    constructor(e=[]) {
        super(),
        this.isSplineCurve = !0,
        this.type = "SplineCurve",
        this.points = e
    }
    getPoint(e, t=new ee) {
        const n = t
          , i = this.points
          , r = (i.length - 1) * e
          , o = Math.floor(r)
          , a = r - o
          , l = i[o === 0 ? o : o - 1]
          , c = i[o]
          , h = i[o > i.length - 2 ? i.length - 1 : o + 1]
          , d = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set($l(a, l.x, c.x, h.x, d.x), $l(a, l.y, c.y, h.y, d.y)),
        n
    }
    copy(e) {
        super.copy(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new ee().fromArray(i))
        }
        return this
    }
}
var Zo = Object.freeze({
    __proto__: null,
    ArcCurve: Kg,
    CatmullRomCurve3: $g,
    CubicBezierCurve: ih,
    CubicBezierCurve3: sM,
    EllipseCurve: ya,
    LineCurve: sh,
    LineCurve3: rM,
    QuadraticBezierCurve: rh,
    QuadraticBezierCurve3: oM,
    SplineCurve: oh
});
class aM extends un {
    constructor() {
        super(),
        this.type = "CurvePath",
        this.curves = [],
        this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0)
          , t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Zo[n](t,e))
        }
        return this
    }
    getPoint(e, t) {
        const n = e * this.getLength()
          , i = this.getCurveLengths();
        let r = 0;
        for (; r < i.length; ) {
            if (i[r] >= n) {
                const o = i[r] - n
                  , a = this.curves[r]
                  , l = a.getLength()
                  , c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            r++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0,
        this.cacheLengths = null,
        this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length)
            return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++)
            t += this.curves[n].getLength(),
            e.push(t);
        return this.cacheLengths = e,
        e
    }
    getSpacedPoints(e=40) {
        const t = [];
        for (let n = 0; n <= e; n++)
            t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]),
        t
    }
    getPoints(e=12) {
        const t = [];
        let n;
        for (let i = 0, r = this.curves; i < r.length; i++) {
            const o = r[i]
              , a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e
              , l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const h = l[c];
                n && n.equals(h) || (t.push(h),
                n = h)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]),
        t
    }
    copy(e) {
        super.copy(e),
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose,
        this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose,
        e.curves = [];
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.autoClose = e.autoClose,
        this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Zo[i.type]().fromJSON(i))
        }
        return this
    }
}
class Jo extends aM {
    constructor(e) {
        super(),
        this.type = "Path",
        this.currentPoint = new ee,
        e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++)
            this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t),
        this
    }
    lineTo(e, t) {
        const n = new sh(this.currentPoint.clone(),new ee(e,t));
        return this.curves.push(n),
        this.currentPoint.set(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        const r = new rh(this.currentPoint.clone(),new ee(e,t),new ee(n,i));
        return this.curves.push(r),
        this.currentPoint.set(n, i),
        this
    }
    bezierCurveTo(e, t, n, i, r, o) {
        const a = new ih(this.currentPoint.clone(),new ee(e,t),new ee(n,i),new ee(r,o));
        return this.curves.push(a),
        this.currentPoint.set(r, o),
        this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e)
          , n = new oh(t);
        return this.curves.push(n),
        this.currentPoint.copy(e[e.length - 1]),
        this
    }
    arc(e, t, n, i, r, o) {
        const a = this.currentPoint.x
          , l = this.currentPoint.y;
        return this.absarc(e + a, t + l, n, i, r, o),
        this
    }
    absarc(e, t, n, i, r, o) {
        return this.absellipse(e, t, n, n, i, r, o),
        this
    }
    ellipse(e, t, n, i, r, o, a, l) {
        const c = this.currentPoint.x
          , h = this.currentPoint.y;
        return this.absellipse(e + c, t + h, n, i, r, o, a, l),
        this
    }
    absellipse(e, t, n, i, r, o, a, l) {
        const c = new ya(e,t,n,i,r,o,a,l);
        if (this.curves.length > 0) {
            const d = c.getPoint(0);
            d.equals(this.currentPoint) || this.lineTo(d.x, d.y)
        }
        this.curves.push(c);
        const h = c.getPoint(1);
        return this.currentPoint.copy(h),
        this
    }
    copy(e) {
        return super.copy(e),
        this.currentPoint.copy(e.currentPoint),
        this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(),
        e
    }
    fromJSON(e) {
        return super.fromJSON(e),
        this.currentPoint.fromArray(e.currentPoint),
        this
    }
}
class hr extends Jo {
    constructor(e) {
        super(e),
        this.uuid = Vt(),
        this.type = "Shape",
        this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++)
            t[n] = this.holes[n].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e),
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid,
        e.holes = [];
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e),
        this.uuid = e.uuid,
        this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new Jo().fromJSON(i))
        }
        return this
    }
}
const lM = {
    triangulate: function(s, e, t=2) {
        const n = e && e.length
          , i = n ? e[0] * t : s.length;
        let r = ah(s, 0, i, t, !0);
        const o = [];
        if (!r || r.next === r.prev)
            return o;
        let a, l, c, h, d, u, f;
        if (n && (r = fM(s, e, r, t)),
        s.length > 80 * t) {
            a = c = s[0],
            l = h = s[1];
            for (let g = t; g < i; g += t)
                d = s[g],
                u = s[g + 1],
                d < a && (a = d),
                u < l && (l = u),
                d > c && (c = d),
                u > h && (h = u);
            f = Math.max(c - a, h - l),
            f = f !== 0 ? 32767 / f : 0
        }
        return gs(r, o, t, a, l, f, 0),
        o
    }
};
function ah(s, e, t, n, i) {
    let r, o;
    if (i === EM(s, e, t, n) > 0)
        for (r = e; r < t; r += n)
            o = Zl(r, s[r], s[r + 1], o);
    else
        for (r = t - n; r >= e; r -= n)
            o = Zl(r, s[r], s[r + 1], o);
    return o && Sr(o, o.next) && (_s(o),
    o = o.next),
    o
}
function si(s, e) {
    if (!s)
        return s;
    e || (e = s);
    let t = s, n;
    do
        if (n = !1,
        !t.steiner && (Sr(t, t.next) || ot(t.prev, t, t.next) === 0)) {
            if (_s(t),
            t = e = t.prev,
            t === t.next)
                break;
            n = !0
        } else
            t = t.next;
    while (n || t !== e);
    return e
}
function gs(s, e, t, n, i, r, o) {
    if (!s)
        return;
    !o && r && _M(s, n, i, r);
    let a = s, l, c;
    for (; s.prev !== s.next; ) {
        if (l = s.prev,
        c = s.next,
        r ? hM(s, n, i, r) : cM(s)) {
            e.push(l.i / t | 0),
            e.push(s.i / t | 0),
            e.push(c.i / t | 0),
            _s(s),
            s = c.next,
            a = c.next;
            continue
        }
        if (s = c,
        s === a) {
            o ? o === 1 ? (s = dM(si(s), e, t),
            gs(s, e, t, n, i, r, 2)) : o === 2 && uM(s, e, t, n, i, r) : gs(si(s), e, t, n, i, r, 1);
            break
        }
    }
}
function cM(s) {
    const e = s.prev
      , t = s
      , n = s.next;
    if (ot(e, t, n) >= 0)
        return !1;
    const i = e.x
      , r = t.x
      , o = n.x
      , a = e.y
      , l = t.y
      , c = n.y
      , h = i < r ? i < o ? i : o : r < o ? r : o
      , d = a < l ? a < c ? a : c : l < c ? l : c
      , u = i > r ? i > o ? i : o : r > o ? r : o
      , f = a > l ? a > c ? a : c : l > c ? l : c;
    let g = n.next;
    for (; g !== e; ) {
        if (g.x >= h && g.x <= u && g.y >= d && g.y <= f && wi(i, a, r, l, o, c, g.x, g.y) && ot(g.prev, g, g.next) >= 0)
            return !1;
        g = g.next
    }
    return !0
}
function hM(s, e, t, n) {
    const i = s.prev
      , r = s
      , o = s.next;
    if (ot(i, r, o) >= 0)
        return !1;
    const a = i.x
      , l = r.x
      , c = o.x
      , h = i.y
      , d = r.y
      , u = o.y
      , f = a < l ? a < c ? a : c : l < c ? l : c
      , g = h < d ? h < u ? h : u : d < u ? d : u
      , M = a > l ? a > c ? a : c : l > c ? l : c
      , m = h > d ? h > u ? h : u : d > u ? d : u
      , p = Qo(f, g, e, t, n)
      , E = Qo(M, m, e, t, n);
    let _ = s.prevZ
      , v = s.nextZ;
    for (; _ && _.z >= p && v && v.z <= E; ) {
        if (_.x >= f && _.x <= M && _.y >= g && _.y <= m && _ !== i && _ !== o && wi(a, h, l, d, c, u, _.x, _.y) && ot(_.prev, _, _.next) >= 0 || (_ = _.prevZ,
        v.x >= f && v.x <= M && v.y >= g && v.y <= m && v !== i && v !== o && wi(a, h, l, d, c, u, v.x, v.y) && ot(v.prev, v, v.next) >= 0))
            return !1;
        v = v.nextZ
    }
    for (; _ && _.z >= p; ) {
        if (_.x >= f && _.x <= M && _.y >= g && _.y <= m && _ !== i && _ !== o && wi(a, h, l, d, c, u, _.x, _.y) && ot(_.prev, _, _.next) >= 0)
            return !1;
        _ = _.prevZ
    }
    for (; v && v.z <= E; ) {
        if (v.x >= f && v.x <= M && v.y >= g && v.y <= m && v !== i && v !== o && wi(a, h, l, d, c, u, v.x, v.y) && ot(v.prev, v, v.next) >= 0)
            return !1;
        v = v.nextZ
    }
    return !0
}
function dM(s, e, t) {
    let n = s;
    do {
        const i = n.prev
          , r = n.next.next;
        !Sr(i, r) && lh(i, n, n.next, r) && Ms(i, r) && Ms(r, i) && (e.push(i.i / t | 0),
        e.push(n.i / t | 0),
        e.push(r.i / t | 0),
        _s(n),
        _s(n.next),
        n = s = r),
        n = n.next
    } while (n !== s);
    return si(n)
}
function uM(s, e, t, n, i, r) {
    let o = s;
    do {
        let a = o.next.next;
        for (; a !== o.prev; ) {
            if (o.i !== a.i && yM(o, a)) {
                let l = ch(o, a);
                o = si(o, o.next),
                l = si(l, l.next),
                gs(o, e, t, n, i, r, 0),
                gs(l, e, t, n, i, r, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== s)
}
function fM(s, e, t, n) {
    const i = [];
    let r, o, a, l, c;
    for (r = 0,
    o = e.length; r < o; r++)
        a = e[r] * n,
        l = r < o - 1 ? e[r + 1] * n : s.length,
        c = ah(s, a, l, n, !1),
        c === c.next && (c.steiner = !0),
        i.push(xM(c));
    for (i.sort(pM),
    r = 0; r < i.length; r++)
        t = mM(i[r], t);
    return t
}
function pM(s, e) {
    return s.x - e.x
}
function mM(s, e) {
    const t = gM(s, e);
    if (!t)
        return e;
    const n = ch(t, s);
    return si(n, n.next),
    si(t, t.next)
}
function gM(s, e) {
    let t = e, n = -1 / 0, i;
    const r = s.x
      , o = s.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const u = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (u <= r && u > n && (n = u,
            i = t.x < t.next.x ? t : t.next,
            u === r))
                return i
        }
        t = t.next
    } while (t !== e);
    if (!i)
        return null;
    const a = i
      , l = i.x
      , c = i.y;
    let h = 1 / 0, d;
    t = i;
    do
        r >= t.x && t.x >= l && r !== t.x && wi(o < c ? r : n, o, l, c, o < c ? n : r, o, t.x, t.y) && (d = Math.abs(o - t.y) / (r - t.x),
        Ms(t, s) && (d < h || d === h && (t.x > i.x || t.x === i.x && MM(i, t))) && (i = t,
        h = d)),
        t = t.next;
    while (t !== a);
    return i
}
function MM(s, e) {
    return ot(s.prev, s, e.prev) < 0 && ot(e.next, s, s.next) < 0
}
function _M(s, e, t, n) {
    let i = s;
    do
        i.z === 0 && (i.z = Qo(i.x, i.y, e, t, n)),
        i.prevZ = i.prev,
        i.nextZ = i.next,
        i = i.next;
    while (i !== s);
    i.prevZ.nextZ = null,
    i.prevZ = null,
    vM(i)
}
function vM(s) {
    let e, t, n, i, r, o, a, l, c = 1;
    do {
        for (t = s,
        s = null,
        r = null,
        o = 0; t; ) {
            for (o++,
            n = t,
            a = 0,
            e = 0; e < c && (a++,
            n = n.nextZ,
            !!n); e++)
                ;
            for (l = c; a > 0 || l > 0 && n; )
                a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t,
                t = t.nextZ,
                a--) : (i = n,
                n = n.nextZ,
                l--),
                r ? r.nextZ = i : s = i,
                i.prevZ = r,
                r = i;
            t = n
        }
        r.nextZ = null,
        c *= 2
    } while (o > 1);
    return s
}
function Qo(s, e, t, n, i) {
    return s = (s - t) * i | 0,
    e = (e - n) * i | 0,
    s = (s | s << 8) & 16711935,
    s = (s | s << 4) & 252645135,
    s = (s | s << 2) & 858993459,
    s = (s | s << 1) & 1431655765,
    e = (e | e << 8) & 16711935,
    e = (e | e << 4) & 252645135,
    e = (e | e << 2) & 858993459,
    e = (e | e << 1) & 1431655765,
    s | e << 1
}
function xM(s) {
    let e = s
      , t = s;
    do
        (e.x < t.x || e.x === t.x && e.y < t.y) && (t = e),
        e = e.next;
    while (e !== s);
    return t
}
function wi(s, e, t, n, i, r, o, a) {
    return (i - o) * (e - a) >= (s - o) * (r - a) && (s - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (r - a) >= (i - o) * (n - a)
}
function yM(s, e) {
    return s.next.i !== e.i && s.prev.i !== e.i && !SM(s, e) && (Ms(s, e) && Ms(e, s) && bM(s, e) && (ot(s.prev, s, e.prev) || ot(s, e.prev, e)) || Sr(s, e) && ot(s.prev, s, s.next) > 0 && ot(e.prev, e, e.next) > 0)
}
function ot(s, e, t) {
    return (e.y - s.y) * (t.x - e.x) - (e.x - s.x) * (t.y - e.y)
}
function Sr(s, e) {
    return s.x === e.x && s.y === e.y
}
function lh(s, e, t, n) {
    const i = er(ot(s, e, t))
      , r = er(ot(s, e, n))
      , o = er(ot(t, n, s))
      , a = er(ot(t, n, e));
    return !!(i !== r && o !== a || i === 0 && Qs(s, t, e) || r === 0 && Qs(s, n, e) || o === 0 && Qs(t, s, n) || a === 0 && Qs(t, e, n))
}
function Qs(s, e, t) {
    return e.x <= Math.max(s.x, t.x) && e.x >= Math.min(s.x, t.x) && e.y <= Math.max(s.y, t.y) && e.y >= Math.min(s.y, t.y)
}
function er(s) {
    return s > 0 ? 1 : s < 0 ? -1 : 0
}
function SM(s, e) {
    let t = s;
    do {
        if (t.i !== s.i && t.next.i !== s.i && t.i !== e.i && t.next.i !== e.i && lh(t, t.next, s, e))
            return !0;
        t = t.next
    } while (t !== s);
    return !1
}
function Ms(s, e) {
    return ot(s.prev, s, s.next) < 0 ? ot(s, e, s.next) >= 0 && ot(s, s.prev, e) >= 0 : ot(s, e, s.prev) < 0 || ot(s, s.next, e) < 0
}
function bM(s, e) {
    let t = s
      , n = !1;
    const i = (s.x + e.x) / 2
      , r = (s.y + e.y) / 2;
    do
        t.y > r != t.next.y > r && t.next.y !== t.y && i < (t.next.x - t.x) * (r - t.y) / (t.next.y - t.y) + t.x && (n = !n),
        t = t.next;
    while (t !== s);
    return n
}
function ch(s, e) {
    const t = new ea(s.i,s.x,s.y)
      , n = new ea(e.i,e.x,e.y)
      , i = s.next
      , r = e.prev;
    return s.next = e,
    e.prev = s,
    t.next = i,
    i.prev = t,
    n.next = t,
    t.prev = n,
    r.next = n,
    n.prev = r,
    n
}
function Zl(s, e, t, n) {
    const i = new ea(s,e,t);
    return n ? (i.next = n.next,
    i.prev = n,
    n.next.prev = i,
    n.next = i) : (i.prev = i,
    i.next = i),
    i
}
function _s(s) {
    s.next.prev = s.prev,
    s.prev.next = s.next,
    s.prevZ && (s.prevZ.nextZ = s.nextZ),
    s.nextZ && (s.nextZ.prevZ = s.prevZ)
}
function ea(s, e, t) {
    this.i = s,
    this.x = e,
    this.y = t,
    this.prev = null,
    this.next = null,
    this.z = 0,
    this.prevZ = null,
    this.nextZ = null,
    this.steiner = !1
}
function EM(s, e, t, n) {
    let i = 0;
    for (let r = e, o = t - n; r < t; r += n)
        i += (s[o] - s[r]) * (s[r + 1] + s[o + 1]),
        o = r;
    return i
}
class Li {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, r = 0; r < t; i = r++)
            n += e[i].x * e[r].y - e[r].x * e[i].y;
        return n * .5
    }
    static isClockWise(e) {
        return Li.area(e) < 0
    }
    static triangulateShape(e, t) {
        const n = []
          , i = []
          , r = [];
        Jl(e),
        Ql(n, e);
        let o = e.length;
        t.forEach(Jl);
        for (let l = 0; l < t.length; l++)
            i.push(o),
            o += t[l].length,
            Ql(n, t[l]);
        const a = lM.triangulate(n, i);
        for (let l = 0; l < a.length; l += 3)
            r.push(a.slice(l, l + 3));
        return r
    }
}
function Jl(s) {
    const e = s.length;
    e > 2 && s[e - 1].equals(s[0]) && s.pop()
}
function Ql(s, e) {
    for (let t = 0; t < e.length; t++)
        s.push(e[t].x),
        s.push(e[t].y)
}
class ba extends Qt {
    constructor(e=new hr([new ee(.5,.5), new ee(-.5,.5), new ee(-.5,-.5), new ee(.5,-.5)]), t={}) {
        super(),
        this.type = "ExtrudeGeometry",
        this.parameters = {
            shapes: e,
            options: t
        },
        e = Array.isArray(e) ? e : [e];
        const n = this
          , i = []
          , r = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new Zt(i,3)),
        this.setAttribute("uv", new Zt(r,2)),
        this.computeVertexNormals();
        function o(a) {
            const l = []
              , c = t.curveSegments !== void 0 ? t.curveSegments : 12
              , h = t.steps !== void 0 ? t.steps : 1
              , d = t.depth !== void 0 ? t.depth : 1;
            let u = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0
              , f = t.bevelThickness !== void 0 ? t.bevelThickness : .2
              , g = t.bevelSize !== void 0 ? t.bevelSize : f - .1
              , M = t.bevelOffset !== void 0 ? t.bevelOffset : 0
              , m = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const p = t.extrudePath
              , E = t.UVGenerator !== void 0 ? t.UVGenerator : TM;
            let _, v = !1, L, P, A, w;
            p && (_ = p.getSpacedPoints(h),
            v = !0,
            u = !1,
            L = p.computeFrenetFrames(h, !1),
            P = new C,
            A = new C,
            w = new C),
            u || (m = 0,
            f = 0,
            g = 0,
            M = 0);
            const S = a.extractPoints(c);
            let y = S.shape;
            const D = S.holes;
            if (!Li.isClockWise(y)) {
                y = y.reverse();
                for (let T = 0, ie = D.length; T < ie; T++) {
                    const Q = D[T];
                    Li.isClockWise(Q) && (D[T] = Q.reverse())
                }
            }
            const F = Li.triangulateShape(y, D)
              , O = y;
            for (let T = 0, ie = D.length; T < ie; T++) {
                const Q = D[T];
                y = y.concat(Q)
            }
            function V(T, ie, Q) {
                return ie || console.error("THREE.ExtrudeGeometry: vec does not exist"),
                T.clone().addScaledVector(ie, Q)
            }
            const B = y.length
              , q = F.length;
            function W(T, ie, Q) {
                let fe, Y, Re;
                const ue = T.x - ie.x
                  , _e = T.y - ie.y
                  , R = Q.x - T.x
                  , x = Q.y - T.y
                  , k = ue * ue + _e * _e
                  , $ = ue * x - _e * R;
                if (Math.abs($) > Number.EPSILON) {
                    const K = Math.sqrt(k)
                      , J = Math.sqrt(R * R + x * x)
                      , we = ie.x - _e / K
                      , ce = ie.y + ue / K
                      , Me = Q.x - x / J
                      , Be = Q.y + R / J
                      , ne = ((Me - we) * x - (Be - ce) * R) / (ue * x - _e * R);
                    fe = we + ue * ne - T.x,
                    Y = ce + _e * ne - T.y;
                    const ge = fe * fe + Y * Y;
                    if (ge <= 2)
                        return new ee(fe,Y);
                    Re = Math.sqrt(ge / 2)
                } else {
                    let K = !1;
                    ue > Number.EPSILON ? R > Number.EPSILON && (K = !0) : ue < -Number.EPSILON ? R < -Number.EPSILON && (K = !0) : Math.sign(_e) === Math.sign(x) && (K = !0),
                    K ? (fe = -_e,
                    Y = ue,
                    Re = Math.sqrt(k)) : (fe = ue,
                    Y = _e,
                    Re = Math.sqrt(k / 2))
                }
                return new ee(fe / Re,Y / Re)
            }
            const ae = [];
            for (let T = 0, ie = O.length, Q = ie - 1, fe = T + 1; T < ie; T++,
            Q++,
            fe++)
                Q === ie && (Q = 0),
                fe === ie && (fe = 0),
                ae[T] = W(O[T], O[Q], O[fe]);
            const le = [];
            let me, Ce = ae.concat();
            for (let T = 0, ie = D.length; T < ie; T++) {
                const Q = D[T];
                me = [];
                for (let fe = 0, Y = Q.length, Re = Y - 1, ue = fe + 1; fe < Y; fe++,
                Re++,
                ue++)
                    Re === Y && (Re = 0),
                    ue === Y && (ue = 0),
                    me[fe] = W(Q[fe], Q[Re], Q[ue]);
                le.push(me),
                Ce = Ce.concat(me)
            }
            for (let T = 0; T < m; T++) {
                const ie = T / m
                  , Q = f * Math.cos(ie * Math.PI / 2)
                  , fe = g * Math.sin(ie * Math.PI / 2) + M;
                for (let Y = 0, Re = O.length; Y < Re; Y++) {
                    const ue = V(O[Y], ae[Y], fe);
                    de(ue.x, ue.y, -Q)
                }
                for (let Y = 0, Re = D.length; Y < Re; Y++) {
                    const ue = D[Y];
                    me = le[Y];
                    for (let _e = 0, R = ue.length; _e < R; _e++) {
                        const x = V(ue[_e], me[_e], fe);
                        de(x.x, x.y, -Q)
                    }
                }
            }
            const ze = g + M;
            for (let T = 0; T < B; T++) {
                const ie = u ? V(y[T], Ce[T], ze) : y[T];
                v ? (A.copy(L.normals[0]).multiplyScalar(ie.x),
                P.copy(L.binormals[0]).multiplyScalar(ie.y),
                w.copy(_[0]).add(A).add(P),
                de(w.x, w.y, w.z)) : de(ie.x, ie.y, 0)
            }
            for (let T = 1; T <= h; T++)
                for (let ie = 0; ie < B; ie++) {
                    const Q = u ? V(y[ie], Ce[ie], ze) : y[ie];
                    v ? (A.copy(L.normals[T]).multiplyScalar(Q.x),
                    P.copy(L.binormals[T]).multiplyScalar(Q.y),
                    w.copy(_[T]).add(A).add(P),
                    de(w.x, w.y, w.z)) : de(Q.x, Q.y, d / h * T)
                }
            for (let T = m - 1; T >= 0; T--) {
                const ie = T / m
                  , Q = f * Math.cos(ie * Math.PI / 2)
                  , fe = g * Math.sin(ie * Math.PI / 2) + M;
                for (let Y = 0, Re = O.length; Y < Re; Y++) {
                    const ue = V(O[Y], ae[Y], fe);
                    de(ue.x, ue.y, d + Q)
                }
                for (let Y = 0, Re = D.length; Y < Re; Y++) {
                    const ue = D[Y];
                    me = le[Y];
                    for (let _e = 0, R = ue.length; _e < R; _e++) {
                        const x = V(ue[_e], me[_e], fe);
                        v ? de(x.x, x.y + _[h - 1].y, _[h - 1].x + Q) : de(x.x, x.y, d + Q)
                    }
                }
            }
            X(),
            te();
            function X() {
                const T = i.length / 3;
                if (u) {
                    let ie = 0
                      , Q = B * ie;
                    for (let fe = 0; fe < q; fe++) {
                        const Y = F[fe];
                        Ae(Y[2] + Q, Y[1] + Q, Y[0] + Q)
                    }
                    ie = h + m * 2,
                    Q = B * ie;
                    for (let fe = 0; fe < q; fe++) {
                        const Y = F[fe];
                        Ae(Y[0] + Q, Y[1] + Q, Y[2] + Q)
                    }
                } else {
                    for (let ie = 0; ie < q; ie++) {
                        const Q = F[ie];
                        Ae(Q[2], Q[1], Q[0])
                    }
                    for (let ie = 0; ie < q; ie++) {
                        const Q = F[ie];
                        Ae(Q[0] + B * h, Q[1] + B * h, Q[2] + B * h)
                    }
                }
                n.addGroup(T, i.length / 3 - T, 0)
            }
            function te() {
                const T = i.length / 3;
                let ie = 0;
                ve(O, ie),
                ie += O.length;
                for (let Q = 0, fe = D.length; Q < fe; Q++) {
                    const Y = D[Q];
                    ve(Y, ie),
                    ie += Y.length
                }
                n.addGroup(T, i.length / 3 - T, 1)
            }
            function ve(T, ie) {
                let Q = T.length;
                for (; --Q >= 0; ) {
                    const fe = Q;
                    let Y = Q - 1;
                    Y < 0 && (Y = T.length - 1);
                    for (let Re = 0, ue = h + m * 2; Re < ue; Re++) {
                        const _e = B * Re
                          , R = B * (Re + 1)
                          , x = ie + fe + _e
                          , k = ie + Y + _e
                          , $ = ie + Y + R
                          , K = ie + fe + R;
                        Ne(x, k, $, K)
                    }
                }
            }
            function de(T, ie, Q) {
                l.push(T),
                l.push(ie),
                l.push(Q)
            }
            function Ae(T, ie, Q) {
                Le(T),
                Le(ie),
                Le(Q);
                const fe = i.length / 3
                  , Y = E.generateTopUV(n, i, fe - 3, fe - 2, fe - 1);
                Ye(Y[0]),
                Ye(Y[1]),
                Ye(Y[2])
            }
            function Ne(T, ie, Q, fe) {
                Le(T),
                Le(ie),
                Le(fe),
                Le(ie),
                Le(Q),
                Le(fe);
                const Y = i.length / 3
                  , Re = E.generateSideWallUV(n, i, Y - 6, Y - 3, Y - 2, Y - 1);
                Ye(Re[0]),
                Ye(Re[1]),
                Ye(Re[3]),
                Ye(Re[1]),
                Ye(Re[2]),
                Ye(Re[3])
            }
            function Le(T) {
                i.push(l[T * 3 + 0]),
                i.push(l[T * 3 + 1]),
                i.push(l[T * 3 + 2])
            }
            function Ye(T) {
                r.push(T.x),
                r.push(T.y)
            }
        }
    }
    copy(e) {
        return super.copy(e),
        this.parameters = Object.assign({}, e.parameters),
        this
    }
    toJSON() {
        const e = super.toJSON()
          , t = this.parameters.shapes
          , n = this.parameters.options;
        return wM(t, n, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let r = 0, o = e.shapes.length; r < o; r++) {
            const a = t[e.shapes[r]];
            n.push(a)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new Zo[i.type]().fromJSON(i)),
        new ba(n,e.options)
    }
}
const TM = {
    generateTopUV: function(s, e, t, n, i) {
        const r = e[t * 3]
          , o = e[t * 3 + 1]
          , a = e[n * 3]
          , l = e[n * 3 + 1]
          , c = e[i * 3]
          , h = e[i * 3 + 1];
        return [new ee(r,o), new ee(a,l), new ee(c,h)]
    },
    generateSideWallUV: function(s, e, t, n, i, r) {
        const o = e[t * 3]
          , a = e[t * 3 + 1]
          , l = e[t * 3 + 2]
          , c = e[n * 3]
          , h = e[n * 3 + 1]
          , d = e[n * 3 + 2]
          , u = e[i * 3]
          , f = e[i * 3 + 1]
          , g = e[i * 3 + 2]
          , M = e[r * 3]
          , m = e[r * 3 + 1]
          , p = e[r * 3 + 2];
        return Math.abs(a - h) < Math.abs(o - c) ? [new ee(o,1 - l), new ee(c,1 - d), new ee(u,1 - g), new ee(M,1 - p)] : [new ee(a,1 - l), new ee(h,1 - d), new ee(f,1 - g), new ee(m,1 - p)]
    }
};
function wM(s, e, t) {
    if (t.shapes = [],
    Array.isArray(s))
        for (let n = 0, i = s.length; n < i; n++) {
            const r = s[n];
            t.shapes.push(r.uuid)
        }
    else
        t.shapes.push(s.uuid);
    return t.options = Object.assign({}, e),
    e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()),
    t
}
class En extends $t {
    constructor(e) {
        super(),
        this.isMeshStandardMaterial = !0,
        this.defines = {
            STANDARD: ""
        },
        this.type = "MeshStandardMaterial",
        this.color = new be(16777215),
        this.roughness = 1,
        this.metalness = 0,
        this.map = null,
        this.lightMap = null,
        this.lightMapIntensity = 1,
        this.aoMap = null,
        this.aoMapIntensity = 1,
        this.emissive = new be(0),
        this.emissiveIntensity = 1,
        this.emissiveMap = null,
        this.bumpMap = null,
        this.bumpScale = 1,
        this.normalMap = null,
        this.normalMapType = Nc,
        this.normalScale = new ee(1,1),
        this.displacementMap = null,
        this.displacementScale = 1,
        this.displacementBias = 0,
        this.roughnessMap = null,
        this.metalnessMap = null,
        this.alphaMap = null,
        this.envMap = null,
        this.envMapRotation = new cn,
        this.envMapIntensity = 1,
        this.wireframe = !1,
        this.wireframeLinewidth = 1,
        this.wireframeLinecap = "round",
        this.wireframeLinejoin = "round",
        this.flatShading = !1,
        this.fog = !0,
        this.setValues(e)
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: ""
        },
        this.color.copy(e.color),
        this.roughness = e.roughness,
        this.metalness = e.metalness,
        this.map = e.map,
        this.lightMap = e.lightMap,
        this.lightMapIntensity = e.lightMapIntensity,
        this.aoMap = e.aoMap,
        this.aoMapIntensity = e.aoMapIntensity,
        this.emissive.copy(e.emissive),
        this.emissiveMap = e.emissiveMap,
        this.emissiveIntensity = e.emissiveIntensity,
        this.bumpMap = e.bumpMap,
        this.bumpScale = e.bumpScale,
        this.normalMap = e.normalMap,
        this.normalMapType = e.normalMapType,
        this.normalScale.copy(e.normalScale),
        this.displacementMap = e.displacementMap,
        this.displacementScale = e.displacementScale,
        this.displacementBias = e.displacementBias,
        this.roughnessMap = e.roughnessMap,
        this.metalnessMap = e.metalnessMap,
        this.alphaMap = e.alphaMap,
        this.envMap = e.envMap,
        this.envMapRotation.copy(e.envMapRotation),
        this.envMapIntensity = e.envMapIntensity,
        this.wireframe = e.wireframe,
        this.wireframeLinewidth = e.wireframeLinewidth,
        this.wireframeLinecap = e.wireframeLinecap,
        this.wireframeLinejoin = e.wireframeLinejoin,
        this.flatShading = e.flatShading,
        this.fog = e.fog,
        this
    }
}
class Wt extends En {
    constructor(e) {
        super(),
        this.isMeshPhysicalMaterial = !0,
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.type = "MeshPhysicalMaterial",
        this.anisotropyRotation = 0,
        this.anisotropyMap = null,
        this.clearcoatMap = null,
        this.clearcoatRoughness = 0,
        this.clearcoatRoughnessMap = null,
        this.clearcoatNormalScale = new ee(1,1),
        this.clearcoatNormalMap = null,
        this.ior = 1.5,
        Object.defineProperty(this, "reflectivity", {
            get: function() {
                return ft(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }),
        this.iridescenceMap = null,
        this.iridescenceIOR = 1.3,
        this.iridescenceThicknessRange = [100, 400],
        this.iridescenceThicknessMap = null,
        this.sheenColor = new be(0),
        this.sheenColorMap = null,
        this.sheenRoughness = 1,
        this.sheenRoughnessMap = null,
        this.transmissionMap = null,
        this.thickness = 0,
        this.thicknessMap = null,
        this.attenuationDistance = 1 / 0,
        this.attenuationColor = new be(1,1,1),
        this.specularIntensity = 1,
        this.specularIntensityMap = null,
        this.specularColor = new be(1,1,1),
        this.specularColorMap = null,
        this._anisotropy = 0,
        this._clearcoat = 0,
        this._dispersion = 0,
        this._iridescence = 0,
        this._sheen = 0,
        this._transmission = 0,
        this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++,
        this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++,
        this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++,
        this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++,
        this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++,
        this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++,
        this._transmission = e
    }
    copy(e) {
        return super.copy(e),
        this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        },
        this.anisotropy = e.anisotropy,
        this.anisotropyRotation = e.anisotropyRotation,
        this.anisotropyMap = e.anisotropyMap,
        this.clearcoat = e.clearcoat,
        this.clearcoatMap = e.clearcoatMap,
        this.clearcoatRoughness = e.clearcoatRoughness,
        this.clearcoatRoughnessMap = e.clearcoatRoughnessMap,
        this.clearcoatNormalMap = e.clearcoatNormalMap,
        this.clearcoatNormalScale.copy(e.clearcoatNormalScale),
        this.dispersion = e.dispersion,
        this.ior = e.ior,
        this.iridescence = e.iridescence,
        this.iridescenceMap = e.iridescenceMap,
        this.iridescenceIOR = e.iridescenceIOR,
        this.iridescenceThicknessRange = [...e.iridescenceThicknessRange],
        this.iridescenceThicknessMap = e.iridescenceThicknessMap,
        this.sheen = e.sheen,
        this.sheenColor.copy(e.sheenColor),
        this.sheenColorMap = e.sheenColorMap,
        this.sheenRoughness = e.sheenRoughness,
        this.sheenRoughnessMap = e.sheenRoughnessMap,
        this.transmission = e.transmission,
        this.transmissionMap = e.transmissionMap,
        this.thickness = e.thickness,
        this.thicknessMap = e.thicknessMap,
        this.attenuationDistance = e.attenuationDistance,
        this.attenuationColor.copy(e.attenuationColor),
        this.specularIntensity = e.specularIntensity,
        this.specularIntensityMap = e.specularIntensityMap,
        this.specularColor.copy(e.specularColor),
        this.specularColorMap = e.specularColorMap,
        this
    }
}
function tr(s, e, t) {
    return !s || !t && s.constructor === e ? s : typeof e.BYTES_PER_ELEMENT == "number" ? new e(s) : Array.prototype.slice.call(s)
}
function AM(s) {
    return ArrayBuffer.isView(s) && !(s instanceof DataView)
}
function RM(s) {
    function e(i, r) {
        return s[i] - s[r]
    }
    const t = s.length
      , n = new Array(t);
    for (let i = 0; i !== t; ++i)
        n[i] = i;
    return n.sort(e),
    n
}
function ec(s, e, t) {
    const n = s.length
      , i = new s.constructor(n);
    for (let r = 0, o = 0; o !== n; ++r) {
        const a = t[r] * e;
        for (let l = 0; l !== e; ++l)
            i[o++] = s[a + l]
    }
    return i
}
function hh(s, e, t, n) {
    let i = 1
      , r = s[0];
    for (; r !== void 0 && r[n] === void 0; )
        r = s[i++];
    if (r === void 0)
        return;
    let o = r[n];
    if (o !== void 0)
        if (Array.isArray(o))
            do
                o = r[n],
                o !== void 0 && (e.push(r.time),
                t.push.apply(t, o)),
                r = s[i++];
            while (r !== void 0);
        else if (o.toArray !== void 0)
            do
                o = r[n],
                o !== void 0 && (e.push(r.time),
                o.toArray(t, t.length)),
                r = s[i++];
            while (r !== void 0);
        else
            do
                o = r[n],
                o !== void 0 && (e.push(r.time),
                t.push(o)),
                r = s[i++];
            while (r !== void 0)
}
class ys {
    constructor(e, t, n, i) {
        this.parameterPositions = e,
        this._cachedIndex = 0,
        this.resultBuffer = i !== void 0 ? i : new t.constructor(n),
        this.sampleValues = t,
        this.valueSize = n,
        this.settings = null,
        this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex
          , i = t[n]
          , r = t[n - 1];
        n: {
            e: {
                let o;
                t: {
                    i: if (!(e < i)) {
                        for (let a = n + 2; ; ) {
                            if (i === void 0) {
                                if (e < r)
                                    break i;
                                return n = t.length,
                                this._cachedIndex = n,
                                this.copySampleValue_(n - 1)
                            }
                            if (n === a)
                                break;
                            if (r = i,
                            i = t[++n],
                            e < i)
                                break e
                        }
                        o = t.length;
                        break t
                    }
                    if (!(e >= r)) {
                        const a = t[1];
                        e < a && (n = 2,
                        r = a);
                        for (let l = n - 2; ; ) {
                            if (r === void 0)
                                return this._cachedIndex = 0,
                                this.copySampleValue_(0);
                            if (n === l)
                                break;
                            if (i = r,
                            r = t[--n - 1],
                            e >= r)
                                break e
                        }
                        o = n,
                        n = 0;
                        break t
                    }
                    break n
                }
                for (; n < o; ) {
                    const a = n + o >>> 1;
                    e < t[a] ? o = a : n = a + 1
                }
                if (i = t[n],
                r = t[n - 1],
                r === void 0)
                    return this._cachedIndex = 0,
                    this.copySampleValue_(0);
                if (i === void 0)
                    return n = t.length,
                    this._cachedIndex = n,
                    this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, r, i)
        }
        return this.interpolate_(n, r, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , r = e * i;
        for (let o = 0; o !== i; ++o)
            t[o] = n[r + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class CM extends ys {
    constructor(e, t, n, i) {
        super(e, t, n, i),
        this._weightPrev = -0,
        this._offsetPrev = -0,
        this._weightNext = -0,
        this._offsetNext = -0,
        this.DefaultSettings_ = {
            endingStart: Ga,
            endingEnd: Ga
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let r = e - 2
          , o = e + 1
          , a = i[r]
          , l = i[o];
        if (a === void 0)
            switch (this.getSettings_().endingStart) {
            case Va:
                r = e,
                a = 2 * t - n;
                break;
            case Wa:
                r = i.length - 2,
                a = t + i[r] - i[r + 1];
                break;
            default:
                r = e,
                a = n
            }
        if (l === void 0)
            switch (this.getSettings_().endingEnd) {
            case Va:
                o = e,
                l = 2 * n - t;
                break;
            case Wa:
                o = 1,
                l = n + i[1] - i[0];
                break;
            default:
                o = e - 1,
                l = t
            }
        const c = (n - t) * .5
          , h = this.valueSize;
        this._weightPrev = c / (t - a),
        this._weightNext = c / (l - n),
        this._offsetPrev = r * h,
        this._offsetNext = o * h
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , h = this._offsetPrev
          , d = this._offsetNext
          , u = this._weightPrev
          , f = this._weightNext
          , g = (n - t) / (i - t)
          , M = g * g
          , m = M * g
          , p = -u * m + 2 * u * M - u * g
          , E = (1 + u) * m + (-1.5 - 2 * u) * M + (-.5 + u) * g + 1
          , _ = (-1 - f) * m + (1.5 + f) * M + .5 * g
          , v = f * m - f * M;
        for (let L = 0; L !== a; ++L)
            r[L] = p * o[h + L] + E * o[c + L] + _ * o[l + L] + v * o[d + L];
        return r
    }
}
class PM extends ys {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = e * a
          , c = l - a
          , h = (n - t) / (i - t)
          , d = 1 - h;
        for (let u = 0; u !== a; ++u)
            r[u] = o[c + u] * d + o[l + u] * h;
        return r
    }
}
class DM extends ys {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class fn {
    constructor(e, t, n, i) {
        if (e === void 0)
            throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0)
            throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e,
        this.times = tr(t, this.TimeBufferType),
        this.values = tr(n, this.ValueBufferType),
        this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON)
            n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: tr(e.times, Array),
                values: tr(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName,
        n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new DM(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new PM(this.times,this.values,this.getValueSize(),e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new CM(this.times,this.values,this.getValueSize(),e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
        case ds:
            t = this.InterpolantFactoryMethodDiscrete;
            break;
        case us:
            t = this.InterpolantFactoryMethodLinear;
            break;
        case Dr:
            t = this.InterpolantFactoryMethodSmooth;
            break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation)
                    this.setInterpolation(this.DefaultInterpolation);
                else
                    throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n),
            this
        }
        return this.createInterpolant = t,
        this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
        case this.InterpolantFactoryMethodDiscrete:
            return ds;
        case this.InterpolantFactoryMethodLinear:
            return us;
        case this.InterpolantFactoryMethodSmooth:
            return Dr
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n)
                t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times
          , i = n.length;
        let r = 0
          , o = i - 1;
        for (; r !== i && n[r] < e; )
            ++r;
        for (; o !== -1 && n[o] > t; )
            --o;
        if (++o,
        r !== 0 || o !== i) {
            r >= o && (o = Math.max(o, 1),
            r = o - 1);
            const a = this.getValueSize();
            this.times = n.slice(r, o),
            this.values = this.values.slice(r * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this),
        e = !1);
        const n = this.times
          , i = this.values
          , r = n.length;
        r === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this),
        e = !1);
        let o = null;
        for (let a = 0; a !== r; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l),
                e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o),
                e = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && AM(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const c = i[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c),
                    e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.getValueSize()
          , i = this.getInterpolation() === Dr
          , r = e.length - 1;
        let o = 1;
        for (let a = 1; a < r; ++a) {
            let l = !1;
            const c = e[a]
              , h = e[a + 1];
            if (c !== h && (a !== 1 || c !== e[0]))
                if (i)
                    l = !0;
                else {
                    const d = a * n
                      , u = d - n
                      , f = d + n;
                    for (let g = 0; g !== n; ++g) {
                        const M = t[d + g];
                        if (M !== t[u + g] || M !== t[f + g]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const d = a * n
                      , u = o * n;
                    for (let f = 0; f !== n; ++f)
                        t[u + f] = t[d + f]
                }
                ++o
            }
        }
        if (r > 0) {
            e[o] = e[r];
            for (let a = r * n, l = o * n, c = 0; c !== n; ++c)
                t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o),
        this.values = t.slice(0, o * n)) : (this.times = e,
        this.values = t),
        this
    }
    clone() {
        const e = this.times.slice()
          , t = this.values.slice()
          , n = this.constructor
          , i = new n(this.name,e,t);
        return i.createInterpolant = this.createInterpolant,
        i
    }
}
fn.prototype.TimeBufferType = Float32Array;
fn.prototype.ValueBufferType = Float32Array;
fn.prototype.DefaultInterpolation = us;
class Xi extends fn {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
Xi.prototype.ValueTypeName = "bool";
Xi.prototype.ValueBufferType = Array;
Xi.prototype.DefaultInterpolation = ds;
Xi.prototype.InterpolantFactoryMethodLinear = void 0;
Xi.prototype.InterpolantFactoryMethodSmooth = void 0;
class dh extends fn {
}
dh.prototype.ValueTypeName = "color";
class Hi extends fn {
}
Hi.prototype.ValueTypeName = "number";
class LM extends ys {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = (n - t) / (i - t);
        let c = e * a;
        for (let h = c + a; c !== h; c += 4)
            ln.slerpFlat(r, 0, o, c - a, o, c, l);
        return r
    }
}
class Gi extends fn {
    InterpolantFactoryMethodLinear(e) {
        return new LM(this.times,this.values,this.getValueSize(),e)
    }
}
Gi.prototype.ValueTypeName = "quaternion";
Gi.prototype.InterpolantFactoryMethodSmooth = void 0;
class qi extends fn {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
qi.prototype.ValueTypeName = "string";
qi.prototype.ValueBufferType = Array;
qi.prototype.DefaultInterpolation = ds;
qi.prototype.InterpolantFactoryMethodLinear = void 0;
qi.prototype.InterpolantFactoryMethodSmooth = void 0;
class Vi extends fn {
}
Vi.prototype.ValueTypeName = "vector";
class IM {
    constructor(e="", t=-1, n=[], i=Zh) {
        this.name = e,
        this.tracks = n,
        this.duration = t,
        this.blendMode = i,
        this.uuid = Vt(),
        this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = []
          , n = e.tracks
          , i = 1 / (e.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o)
            t.push(NM(n[o]).scale(i));
        const r = new this(e.name,e.duration,t,e.blendMode);
        return r.uuid = e.uuid,
        r
    }
    static toJSON(e) {
        const t = []
          , n = e.tracks
          , i = {
            name: e.name,
            duration: e.duration,
            tracks: t,
            uuid: e.uuid,
            blendMode: e.blendMode
        };
        for (let r = 0, o = n.length; r !== o; ++r)
            t.push(fn.toJSON(n[r]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const r = t.length
          , o = [];
        for (let a = 0; a < r; a++) {
            let l = []
              , c = [];
            l.push((a + r - 1) % r, a, (a + 1) % r),
            c.push(0, 1, 0);
            const h = RM(l);
            l = ec(l, 1, h),
            c = ec(c, 1, h),
            !i && l[0] === 0 && (l.push(r),
            c.push(c[0])),
            o.push(new Hi(".morphTargetInfluences[" + t[a].name + "]",l,c).scale(1 / n))
        }
        return new this(e,-1,o)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t)
                return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {}
          , r = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , h = c.name.match(r);
            if (h && h.length > 1) {
                const d = h[1];
                let u = i[d];
                u || (i[d] = u = []),
                u.push(c)
            }
        }
        const o = [];
        for (const a in i)
            o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return o
    }
    static parseAnimation(e, t) {
        if (!e)
            return console.error("THREE.AnimationClip: No animation in JSONLoader data."),
            null;
        const n = function(d, u, f, g, M) {
            if (f.length !== 0) {
                const m = []
                  , p = [];
                hh(f, m, p, g),
                m.length !== 0 && M.push(new d(u,m,p))
            }
        }
          , i = []
          , r = e.name || "default"
          , o = e.fps || 30
          , a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let d = 0; d < c.length; d++) {
            const u = c[d].keys;
            if (!(!u || u.length === 0))
                if (u[0].morphTargets) {
                    const f = {};
                    let g;
                    for (g = 0; g < u.length; g++)
                        if (u[g].morphTargets)
                            for (let M = 0; M < u[g].morphTargets.length; M++)
                                f[u[g].morphTargets[M]] = -1;
                    for (const M in f) {
                        const m = []
                          , p = [];
                        for (let E = 0; E !== u[g].morphTargets.length; ++E) {
                            const _ = u[g];
                            m.push(_.time),
                            p.push(_.morphTarget === M ? 1 : 0)
                        }
                        i.push(new Hi(".morphTargetInfluence[" + M + "]",m,p))
                    }
                    l = f.length * o
                } else {
                    const f = ".bones[" + t[d].name + "]";
                    n(Vi, f + ".position", u, "pos", i),
                    n(Gi, f + ".quaternion", u, "rot", i),
                    n(Vi, f + ".scale", u, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(r,l,i,a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const r = this.tracks[n];
            t = Math.max(t, r.times[r.times.length - 1])
        }
        return this.duration = t,
        this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++)
            e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++)
            this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++)
            e.push(this.tracks[t].clone());
        return new this.constructor(this.name,this.duration,e,this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}
function UM(s) {
    switch (s.toLowerCase()) {
    case "scalar":
    case "double":
    case "float":
    case "number":
    case "integer":
        return Hi;
    case "vector":
    case "vector2":
    case "vector3":
    case "vector4":
        return Vi;
    case "color":
        return dh;
    case "quaternion":
        return Gi;
    case "bool":
    case "boolean":
        return Xi;
    case "string":
        return qi
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + s)
}
function NM(s) {
    if (s.type === void 0)
        throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = UM(s.type);
    if (s.times === void 0) {
        const t = []
          , n = [];
        hh(s.keys, t, n, "value"),
        s.times = t,
        s.values = n
    }
    return e.parse !== void 0 ? e.parse(s) : new e(s.name,s.times,s.values,s.interpolation)
}
const Gn = {
    enabled: !1,
    files: {},
    add: function(s, e) {
        this.enabled !== !1 && (this.files[s] = e)
    },
    get: function(s) {
        if (this.enabled !== !1)
            return this.files[s]
    },
    remove: function(s) {
        delete this.files[s]
    },
    clear: function() {
        this.files = {}
    }
};
class FM {
    constructor(e, t, n) {
        const i = this;
        let r = !1, o = 0, a = 0, l;
        const c = [];
        this.onStart = void 0,
        this.onLoad = e,
        this.onProgress = t,
        this.onError = n,
        this.itemStart = function(h) {
            a++,
            r === !1 && i.onStart !== void 0 && i.onStart(h, o, a),
            r = !0
        }
        ,
        this.itemEnd = function(h) {
            o++,
            i.onProgress !== void 0 && i.onProgress(h, o, a),
            o === a && (r = !1,
            i.onLoad !== void 0 && i.onLoad())
        }
        ,
        this.itemError = function(h) {
            i.onError !== void 0 && i.onError(h)
        }
        ,
        this.resolveURL = function(h) {
            return l ? l(h) : h
        }
        ,
        this.setURLModifier = function(h) {
            return l = h,
            this
        }
        ,
        this.addHandler = function(h, d) {
            return c.push(h, d),
            this
        }
        ,
        this.removeHandler = function(h) {
            const d = c.indexOf(h);
            return d !== -1 && c.splice(d, 2),
            this
        }
        ,
        this.getHandler = function(h) {
            for (let d = 0, u = c.length; d < u; d += 2) {
                const f = c[d]
                  , g = c[d + 1];
                if (f.global && (f.lastIndex = 0),
                f.test(h))
                    return g
            }
            return null
        }
    }
}
const OM = new FM;
class Dn {
    constructor(e) {
        this.manager = e !== void 0 ? e : OM,
        this.crossOrigin = "anonymous",
        this.withCredentials = !1,
        this.path = "",
        this.resourcePath = "",
        this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, r) {
            n.load(e, i, t, r)
        }
        )
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e,
        this
    }
    setWithCredentials(e) {
        return this.withCredentials = e,
        this
    }
    setPath(e) {
        return this.path = e,
        this
    }
    setResourcePath(e) {
        return this.resourcePath = e,
        this
    }
    setRequestHeader(e) {
        return this.requestHeader = e,
        this
    }
}
Dn.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const xn = {};
class BM extends Error {
    constructor(e, t) {
        super(e),
        this.response = t
    }
}
class br extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = Gn.get(e);
        if (r !== void 0)
            return this.manager.itemStart(e),
            setTimeout( () => {
                t && t(r),
                this.manager.itemEnd(e)
            }
            , 0),
            r;
        if (xn[e] !== void 0) {
            xn[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        xn[e] = [],
        xn[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const o = new Request(e,{
            headers: new Headers(this.requestHeader),
            credentials: this.withCredentials ? "include" : "same-origin"
        })
          , a = this.mimeType
          , l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."),
                typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0)
                    return c;
                const h = xn[e]
                  , d = c.body.getReader()
                  , u = c.headers.get("X-File-Size") || c.headers.get("Content-Length")
                  , f = u ? parseInt(u) : 0
                  , g = f !== 0;
                let M = 0;
                const m = new ReadableStream({
                    start(p) {
                        E();
                        function E() {
                            d.read().then( ({done: _, value: v}) => {
                                if (_)
                                    p.close();
                                else {
                                    M += v.byteLength;
                                    const L = new ProgressEvent("progress",{
                                        lengthComputable: g,
                                        loaded: M,
                                        total: f
                                    });
                                    for (let P = 0, A = h.length; P < A; P++) {
                                        const w = h[P];
                                        w.onProgress && w.onProgress(L)
                                    }
                                    p.enqueue(v),
                                    E()
                                }
                            }
                            , _ => {
                                p.error(_)
                            }
                            )
                        }
                    }
                });
                return new Response(m)
            } else
                throw new BM(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`,c)
        }
        ).then(c => {
            switch (l) {
            case "arraybuffer":
                return c.arrayBuffer();
            case "blob":
                return c.blob();
            case "document":
                return c.text().then(h => new DOMParser().parseFromString(h, a));
            case "json":
                return c.json();
            default:
                if (a === void 0)
                    return c.text();
                {
                    const d = /charset="?([^;"\s]*)"?/i.exec(a)
                      , u = d && d[1] ? d[1].toLowerCase() : void 0
                      , f = new TextDecoder(u);
                    return c.arrayBuffer().then(g => f.decode(g))
                }
            }
        }
        ).then(c => {
            Gn.add(e, c);
            const h = xn[e];
            delete xn[e];
            for (let d = 0, u = h.length; d < u; d++) {
                const f = h[d];
                f.onLoad && f.onLoad(c)
            }
        }
        ).catch(c => {
            const h = xn[e];
            if (h === void 0)
                throw this.manager.itemError(e),
                c;
            delete xn[e];
            for (let d = 0, u = h.length; d < u; d++) {
                const f = h[d];
                f.onError && f.onError(c)
            }
            this.manager.itemError(e)
        }
        ).finally( () => {
            this.manager.itemEnd(e)
        }
        ),
        this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e,
        this
    }
    setMimeType(e) {
        return this.mimeType = e,
        this
    }
}
class uh extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , o = Gn.get(e);
        if (o !== void 0)
            return r.manager.itemStart(e),
            setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o;
        const a = ps("img");
        function l() {
            h(),
            Gn.add(e, this),
            t && t(this),
            r.manager.itemEnd(e)
        }
        function c(d) {
            h(),
            i && i(d),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
        function h() {
            a.removeEventListener("load", l, !1),
            a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1),
        a.addEventListener("error", c, !1),
        e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin),
        r.manager.itemStart(e),
        a.src = e,
        a
    }
}
class zM extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = new fa;
        r.colorSpace = Tt;
        const o = new uh(this.manager);
        o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path);
        let a = 0;
        function l(c) {
            o.load(e[c], function(h) {
                r.images[c] = h,
                a++,
                a === 6 && (r.needsUpdate = !0,
                t && t(r))
            }, void 0, i)
        }
        for (let c = 0; c < e.length; ++c)
            l(c);
        return r
    }
}
class kM extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , o = new _a
          , a = new br(this.manager);
        return a.setResponseType("arraybuffer"),
        a.setRequestHeader(this.requestHeader),
        a.setPath(this.path),
        a.setWithCredentials(r.withCredentials),
        a.load(e, function(l) {
            let c;
            try {
                c = r.parse(l)
            } catch (h) {
                if (i !== void 0)
                    i(h);
                else {
                    console.error(h);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width,
            o.image.height = c.height,
            o.image.data = c.data),
            o.wrapS = c.wrapS !== void 0 ? c.wrapS : sn,
            o.wrapT = c.wrapT !== void 0 ? c.wrapT : sn,
            o.magFilter = c.magFilter !== void 0 ? c.magFilter : _t,
            o.minFilter = c.minFilter !== void 0 ? c.minFilter : _t,
            o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1,
            c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace),
            c.flipY !== void 0 && (o.flipY = c.flipY),
            c.format !== void 0 && (o.format = c.format),
            c.type !== void 0 && (o.type = c.type),
            c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps,
            o.minFilter = rn),
            c.mipmapCount === 1 && (o.minFilter = _t),
            c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps),
            o.needsUpdate = !0,
            t && t(o, c)
        }, n, i),
        o
    }
}
class Ea extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = new vt
          , o = new uh(this.manager);
        return o.setCrossOrigin(this.crossOrigin),
        o.setPath(this.path),
        o.load(e, function(a) {
            r.image = a,
            r.needsUpdate = !0,
            t !== void 0 && t(r)
        }, n, i),
        r
    }
}
class Er extends it {
    constructor(e, t=1) {
        super(),
        this.isLight = !0,
        this.type = "Light",
        this.color = new be(e),
        this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t),
        this.color.copy(e.color),
        this.intensity = e.intensity,
        this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(),
        t.object.intensity = this.intensity,
        this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()),
        this.distance !== void 0 && (t.object.distance = this.distance),
        this.angle !== void 0 && (t.object.angle = this.angle),
        this.decay !== void 0 && (t.object.decay = this.decay),
        this.penumbra !== void 0 && (t.object.penumbra = this.penumbra),
        this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()),
        this.target !== void 0 && (t.object.target = this.target.uuid),
        t
    }
}
const co = new Oe
  , tc = new C
  , nc = new C;
class Ta {
    constructor(e) {
        this.camera = e,
        this.intensity = 1,
        this.bias = 0,
        this.normalBias = 0,
        this.radius = 1,
        this.blurSamples = 8,
        this.mapSize = new ee(512,512),
        this.map = null,
        this.mapPass = null,
        this.matrix = new Oe,
        this.autoUpdate = !0,
        this.needsUpdate = !1,
        this._frustum = new pa,
        this._frameExtents = new ee(1,1),
        this._viewportCount = 1,
        this._viewports = [new Qe(0,0,1,1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera
          , n = this.matrix;
        tc.setFromMatrixPosition(e.matrixWorld),
        t.position.copy(tc),
        nc.setFromMatrixPosition(e.target.matrixWorld),
        t.lookAt(nc),
        t.updateMatrixWorld(),
        co.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(co),
        n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
        n.multiply(co)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(),
        this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(),
        this.intensity = e.intensity,
        this.bias = e.bias,
        this.radius = e.radius,
        this.mapSize.copy(e.mapSize),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity),
        this.bias !== 0 && (e.bias = this.bias),
        this.normalBias !== 0 && (e.normalBias = this.normalBias),
        this.radius !== 1 && (e.radius = this.radius),
        (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()),
        e.camera = this.camera.toJSON(!1).object,
        delete e.camera.matrix,
        e
    }
}
class HM extends Ta {
    constructor() {
        super(new wt(50,1,.5,500)),
        this.isSpotLightShadow = !0,
        this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera
          , n = zi * 2 * e.angle * this.focus
          , i = this.mapSize.width / this.mapSize.height
          , r = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || r !== t.far) && (t.fov = n,
        t.aspect = i,
        t.far = r,
        t.updateProjectionMatrix()),
        super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e),
        this.focus = e.focus,
        this
    }
}
class GM extends Er {
    constructor(e, t, n=0, i=Math.PI / 3, r=0, o=2) {
        super(e, t),
        this.isSpotLight = !0,
        this.type = "SpotLight",
        this.position.copy(it.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new it,
        this.distance = n,
        this.angle = i,
        this.penumbra = r,
        this.decay = o,
        this.map = null,
        this.shadow = new HM
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.angle = e.angle,
        this.penumbra = e.penumbra,
        this.decay = e.decay,
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
const ic = new Oe
  , ts = new C
  , ho = new C;
class VM extends Ta {
    constructor() {
        super(new wt(90,1,.5,500)),
        this.isPointLightShadow = !0,
        this._frameExtents = new ee(4,2),
        this._viewportCount = 6,
        this._viewports = [new Qe(2,1,1,1), new Qe(0,1,1,1), new Qe(3,1,1,1), new Qe(1,1,1,1), new Qe(3,0,1,1), new Qe(1,0,1,1)],
        this._cubeDirections = [new C(1,0,0), new C(-1,0,0), new C(0,0,1), new C(0,0,-1), new C(0,1,0), new C(0,-1,0)],
        this._cubeUps = [new C(0,1,0), new C(0,1,0), new C(0,1,0), new C(0,1,0), new C(0,0,1), new C(0,0,-1)]
    }
    updateMatrices(e, t=0) {
        const n = this.camera
          , i = this.matrix
          , r = e.distance || n.far;
        r !== n.far && (n.far = r,
        n.updateProjectionMatrix()),
        ts.setFromMatrixPosition(e.matrixWorld),
        n.position.copy(ts),
        ho.copy(n.position),
        ho.add(this._cubeDirections[t]),
        n.up.copy(this._cubeUps[t]),
        n.lookAt(ho),
        n.updateMatrixWorld(),
        i.makeTranslation(-ts.x, -ts.y, -ts.z),
        ic.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse),
        this._frustum.setFromProjectionMatrix(ic)
    }
}
class WM extends Er {
    constructor(e, t, n=0, i=2) {
        super(e, t),
        this.isPointLight = !0,
        this.type = "PointLight",
        this.distance = n,
        this.decay = i,
        this.shadow = new VM
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t),
        this.distance = e.distance,
        this.decay = e.decay,
        this.shadow = e.shadow.clone(),
        this
    }
}
class XM extends Ta {
    constructor() {
        super(new ma(-5,5,5,-5,.5,500)),
        this.isDirectionalLightShadow = !0
    }
}
class fh extends Er {
    constructor(e, t) {
        super(e, t),
        this.isDirectionalLight = !0,
        this.type = "DirectionalLight",
        this.position.copy(it.DEFAULT_UP),
        this.updateMatrix(),
        this.target = new it,
        this.shadow = new XM
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e),
        this.target = e.target.clone(),
        this.shadow = e.shadow.clone(),
        this
    }
}
class qM extends Er {
    constructor(e, t) {
        super(e, t),
        this.isAmbientLight = !0,
        this.type = "AmbientLight"
    }
}
class cs {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."),
        typeof TextDecoder < "u")
            return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++)
            t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")),
        /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class YM extends Dn {
    constructor(e) {
        super(e),
        this.isImageBitmapLoader = !0,
        typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."),
        typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."),
        this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e,
        this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""),
        this.path !== void 0 && (e = this.path + e),
        e = this.manager.resolveURL(e);
        const r = this
          , o = Gn.get(e);
        if (o !== void 0) {
            if (r.manager.itemStart(e),
            o.then) {
                o.then(c => {
                    t && t(c),
                    r.manager.itemEnd(e)
                }
                ).catch(c => {
                    i && i(c)
                }
                );
                return
            }
            return setTimeout(function() {
                t && t(o),
                r.manager.itemEnd(e)
            }, 0),
            o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include",
        a.headers = this.requestHeader;
        const l = fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(r.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return Gn.add(e, c),
            t && t(c),
            r.manager.itemEnd(e),
            c
        }).catch(function(c) {
            i && i(c),
            Gn.remove(e),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        });
        Gn.add(e, l),
        r.manager.itemStart(e)
    }
}
const wa = "\\[\\]\\.:\\/"
  , jM = new RegExp("[" + wa + "]","g")
  , Aa = "[^" + wa + "]"
  , KM = "[^" + wa.replace("\\.", "") + "]"
  , $M = /((?:WC+[\/:])*)/.source.replace("WC", Aa)
  , ZM = /(WCOD+)?/.source.replace("WCOD", KM)
  , JM = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", Aa)
  , QM = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", Aa)
  , e0 = new RegExp("^" + $M + ZM + JM + QM + "$")
  , t0 = ["material", "materials", "bones", "map"];
class n0 {
    constructor(e, t, n) {
        const i = n || tt.parseTrackName(t);
        this._targetGroup = e,
        this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_
          , i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, r = n.length; i !== r; ++i)
            n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t)
            e[t].unbind()
    }
}
class tt {
    constructor(e, t, n) {
        this.path = t,
        this.parsedPath = n || tt.parseTrackName(t),
        this.node = tt.findNode(e, this.parsedPath.nodeName),
        this.rootNode = e,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new tt.Composite(e,t,n) : new tt(e,t,n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(jM, "")
    }
    static parseTrackName(e) {
        const t = e0.exec(e);
        if (t === null)
            throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
            nodeName: t[2],
            objectName: t[3],
            objectIndex: t[4],
            propertyName: t[5],
            propertyIndex: t[6]
        }
          , i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const r = n.nodeName.substring(i + 1);
            t0.indexOf(r) !== -1 && (n.nodeName = n.nodeName.substring(0, i),
            n.objectName = r)
        }
        if (n.propertyName === null || n.propertyName.length === 0)
            throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid)
            return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0)
                return n
        }
        if (e.children) {
            const n = function(r) {
                for (let o = 0; o < r.length; o++) {
                    const a = r[o];
                    if (a.name === t || a.uuid === t)
                        return a;
                    const l = n(a.children);
                    if (l)
                        return l
                }
                return null
            }
              , i = n(e.children);
            if (i)
                return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, r = n.length; i !== r; ++i)
            n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t],
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t),
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(),
        this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(),
        this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath
          , n = t.objectName
          , i = t.propertyName;
        let r = t.propertyIndex;
        if (e || (e = tt.findNode(this.rootNode, t.nodeName),
        this.node = e),
        this.getValue = this._getValue_unavailable,
        this.setValue = this._setValue_unavailable,
        !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let c = t.objectIndex;
            switch (n) {
            case "materials":
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.materials) {
                    console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                    return
                }
                e = e.material.materials;
                break;
            case "bones":
                if (!e.skeleton) {
                    console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                    return
                }
                e = e.skeleton.bones;
                for (let h = 0; h < e.length; h++)
                    if (e[h].name === c) {
                        c = h;
                        break
                    }
                break;
            case "map":
                if ("map"in e) {
                    e = e.map;
                    break
                }
                if (!e.material) {
                    console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                    return
                }
                if (!e.material.map) {
                    console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                    return
                }
                e = e.material.map;
                break;
            default:
                if (e[n] === void 0) {
                    console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                    return
                }
                e = e[n]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e,
        e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (r !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[r] !== void 0 && (r = e.morphTargetDictionary[r])
            }
            l = this.BindingType.ArrayElement,
            this.resolvedProperty = o,
            this.propertyIndex = r
        } else
            o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray,
            this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray,
            this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l],
        this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null,
        this.getValue = this._getValue_unbound,
        this.setValue = this._setValue_unbound
    }
}
tt.Composite = n0;
tt.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
tt.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
tt.prototype.GetterByBindingType = [tt.prototype._getValue_direct, tt.prototype._getValue_array, tt.prototype._getValue_arrayElement, tt.prototype._getValue_toArray];
tt.prototype.SetterByBindingTypeAndVersioning = [[tt.prototype._setValue_direct, tt.prototype._setValue_direct_setNeedsUpdate, tt.prototype._setValue_direct_setMatrixWorldNeedsUpdate], [tt.prototype._setValue_array, tt.prototype._setValue_array_setNeedsUpdate, tt.prototype._setValue_array_setMatrixWorldNeedsUpdate], [tt.prototype._setValue_arrayElement, tt.prototype._setValue_arrayElement_setNeedsUpdate, tt.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate], [tt.prototype._setValue_fromArray, tt.prototype._setValue_fromArray_setNeedsUpdate, tt.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]];
class sc {
    constructor(e=1, t=0, n=0) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    set(e, t, n) {
        return this.radius = e,
        this.phi = t,
        this.theta = n,
        this
    }
    copy(e) {
        return this.radius = e.radius,
        this.phi = e.phi,
        this.theta = e.theta,
        this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)),
        this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n),
        this.radius === 0 ? (this.theta = 0,
        this.phi = 0) : (this.theta = Math.atan2(e, n),
        this.phi = Math.acos(ft(t / this.radius, -1, 1))),
        this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class i0 {
    constructor() {
        this.type = "ShapePath",
        this.color = new be,
        this.subPaths = [],
        this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new Jo,
        this.subPaths.push(this.currentPath),
        this.currentPath.moveTo(e, t),
        this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t),
        this
    }
    quadraticCurveTo(e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i),
        this
    }
    bezierCurveTo(e, t, n, i, r, o) {
        return this.currentPath.bezierCurveTo(e, t, n, i, r, o),
        this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e),
        this
    }
    toShapes(e) {
        function t(p) {
            const E = [];
            for (let _ = 0, v = p.length; _ < v; _++) {
                const L = p[_]
                  , P = new hr;
                P.curves = L.curves,
                E.push(P)
            }
            return E
        }
        function n(p, E) {
            const _ = E.length;
            let v = !1;
            for (let L = _ - 1, P = 0; P < _; L = P++) {
                let A = E[L]
                  , w = E[P]
                  , S = w.x - A.x
                  , y = w.y - A.y;
                if (Math.abs(y) > Number.EPSILON) {
                    if (y < 0 && (A = E[P],
                    S = -S,
                    w = E[L],
                    y = -y),
                    p.y < A.y || p.y > w.y)
                        continue;
                    if (p.y === A.y) {
                        if (p.x === A.x)
                            return !0
                    } else {
                        const D = y * (p.x - A.x) - S * (p.y - A.y);
                        if (D === 0)
                            return !0;
                        if (D < 0)
                            continue;
                        v = !v
                    }
                } else {
                    if (p.y !== A.y)
                        continue;
                    if (w.x <= p.x && p.x <= A.x || A.x <= p.x && p.x <= w.x)
                        return !0
                }
            }
            return v
        }
        const i = Li.isClockWise
          , r = this.subPaths;
        if (r.length === 0)
            return [];
        let o, a, l;
        const c = [];
        if (r.length === 1)
            return a = r[0],
            l = new hr,
            l.curves = a.curves,
            c.push(l),
            c;
        let h = !i(r[0].getPoints());
        h = e ? !h : h;
        const d = []
          , u = [];
        let f = [], g = 0, M;
        u[g] = void 0,
        f[g] = [];
        for (let p = 0, E = r.length; p < E; p++)
            a = r[p],
            M = a.getPoints(),
            o = i(M),
            o = e ? !o : o,
            o ? (!h && u[g] && g++,
            u[g] = {
                s: new hr,
                p: M
            },
            u[g].s.curves = a.curves,
            h && g++,
            f[g] = []) : f[g].push({
                h: a,
                p: M[0]
            });
        if (!u[0])
            return t(r);
        if (u.length > 1) {
            let p = !1
              , E = 0;
            for (let _ = 0, v = u.length; _ < v; _++)
                d[_] = [];
            for (let _ = 0, v = u.length; _ < v; _++) {
                const L = f[_];
                for (let P = 0; P < L.length; P++) {
                    const A = L[P];
                    let w = !0;
                    for (let S = 0; S < u.length; S++)
                        n(A.p, u[S].p) && (_ !== S && E++,
                        w ? (w = !1,
                        d[S].push(A)) : p = !0);
                    w && d[_].push(A)
                }
            }
            E > 0 && p === !1 && (f = d)
        }
        let m;
        for (let p = 0, E = u.length; p < E; p++) {
            l = u[p].s,
            c.push(l),
            m = f[p];
            for (let _ = 0, v = m.length; _ < v; _++)
                l.holes.push(m[_].h)
        }
        return c
    }
}
class s0 extends ri {
    constructor(e, t) {
        super(),
        this.object = e,
        this.domElement = t,
        this.enabled = !0,
        this.state = -1,
        this.keys = {},
        this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        },
        this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect() {}
    disconnect() {}
    dispose() {}
    update() {}
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register",{
    detail: {
        revision: ia
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = ia);
class r0 {
    constructor(e) {
        this.scene = e
    }
    initLighting() {
        console.log("init lighting");
        const e = new qM("#FAF9F6",1);
        this.scene.add(e);
        const t = new fh(16777215,2);
        t.position.set(10, 10, 10),
        t.castShadow = !0,
        t.shadow.mapSize.width = 4096,
        t.shadow.mapSize.height = 4096,
        t.shadow.radius = 8,
        t.shadow.camera.near = 1,
        t.shadow.camera.far = 20,
        t.shadow.camera.top = 5,
        t.shadow.camera.bottom = -5,
        t.shadow.camera.left = -5,
        t.shadow.camera.right = 5,
        t.shadow.bias = -.001,
        this.scene.add(t)
    }
}
class Tr extends ct {
    constructor(e, t={}) {
        super(e),
        this.isReflector = !0,
        this.type = "Reflector",
        this.camera = new wt;
        const n = this
          , i = t.color !== void 0 ? new be(t.color) : new be(8355711)
          , r = t.textureWidth || 512
          , o = t.textureHeight || 512
          , a = t.clipBias || 0
          , l = t.shader || Tr.ReflectorShader
          , c = t.multisample !== void 0 ? t.multisample : 4
          , h = new We
          , d = new C
          , u = new C
          , f = new C
          , g = new Oe
          , M = new C(0,0,-1)
          , m = new Qe
          , p = new C
          , E = new C
          , _ = new Qe
          , v = new Oe
          , L = this.camera
          , P = new Wn(r,o,{
            samples: c,
            type: on
        })
          , A = new hn({
            name: l.name !== void 0 ? l.name : "unspecified",
            uniforms: qc.clone(l.uniforms),
            fragmentShader: l.fragmentShader,
            vertexShader: l.vertexShader
        });
        A.uniforms.tDiffuse.value = P.texture,
        A.uniforms.color.value = i,
        A.uniforms.textureMatrix.value = v,
        this.material = A,
        this.onBeforeRender = function(w, S, y) {
            if (u.setFromMatrixPosition(n.matrixWorld),
            f.setFromMatrixPosition(y.matrixWorld),
            g.extractRotation(n.matrixWorld),
            d.set(0, 0, 1),
            d.applyMatrix4(g),
            p.subVectors(u, f),
            p.dot(d) > 0)
                return;
            p.reflect(d).negate(),
            p.add(u),
            g.extractRotation(y.matrixWorld),
            M.set(0, 0, -1),
            M.applyMatrix4(g),
            M.add(f),
            E.subVectors(u, M),
            E.reflect(d).negate(),
            E.add(u),
            L.position.copy(p),
            L.up.set(0, 1, 0),
            L.up.applyMatrix4(g),
            L.up.reflect(d),
            L.lookAt(E),
            L.far = y.far,
            L.updateMatrixWorld(),
            L.projectionMatrix.copy(y.projectionMatrix),
            v.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1),
            v.multiply(L.projectionMatrix),
            v.multiply(L.matrixWorldInverse),
            v.multiply(n.matrixWorld),
            h.setFromNormalAndCoplanarPoint(d, u),
            h.applyMatrix4(L.matrixWorldInverse),
            m.set(h.normal.x, h.normal.y, h.normal.z, h.constant);
            const D = L.projectionMatrix;
            _.x = (Math.sign(m.x) + D.elements[8]) / D.elements[0],
            _.y = (Math.sign(m.y) + D.elements[9]) / D.elements[5],
            _.z = -1,
            _.w = (1 + D.elements[10]) / D.elements[14],
            m.multiplyScalar(2 / m.dot(_)),
            D.elements[2] = m.x,
            D.elements[6] = m.y,
            D.elements[10] = m.z + 1 - a,
            D.elements[14] = m.w,
            n.visible = !1;
            const G = w.getRenderTarget()
              , F = w.xr.enabled
              , O = w.shadowMap.autoUpdate;
            w.xr.enabled = !1,
            w.shadowMap.autoUpdate = !1,
            w.setRenderTarget(P),
            w.state.buffers.depth.setMask(!0),
            w.autoClear === !1 && w.clear(),
            w.render(S, L),
            w.xr.enabled = F,
            w.shadowMap.autoUpdate = O,
            w.setRenderTarget(G);
            const V = y.viewport;
            V !== void 0 && w.state.viewport(V),
            n.visible = !0
        }
        ,
        this.getRenderTarget = function() {
            return P
        }
        ,
        this.dispose = function() {
            P.dispose(),
            n.material.dispose()
        }
    }
}
Tr.ReflectorShader = {
    name: "ReflectorShader",
    uniforms: {
        color: {
            value: null
        },
        tDiffuse: {
            value: null
        },
        textureMatrix: {
            value: null
        }
    },
    vertexShader: `
		uniform mat4 textureMatrix;
		varying vec4 vUv;

		#include <common>
		#include <logdepthbuf_pars_vertex>

		void main() {

			vUv = textureMatrix * vec4( position, 1.0 );

			gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );

			#include <logdepthbuf_vertex>

		}`,
    fragmentShader: `
		uniform vec3 color;
		uniform sampler2D tDiffuse;
		varying vec4 vUv;

		#include <logdepthbuf_pars_fragment>

		float blendOverlay( float base, float blend ) {

			return( base < 0.5 ? ( 2.0 * base * blend ) : ( 1.0 - 2.0 * ( 1.0 - base ) * ( 1.0 - blend ) ) );

		}

		vec3 blendOverlay( vec3 base, vec3 blend ) {

			return vec3( blendOverlay( base.r, blend.r ), blendOverlay( base.g, blend.g ), blendOverlay( base.b, blend.b ) );

		}

		void main() {

			#include <logdepthbuf_fragment>

			vec4 base = texture2DProj( tDiffuse, vUv );
			gl_FragColor = vec4( blendOverlay( base.rgb, color ), 1.0 );

			#include <tonemapping_fragment>
			#include <colorspace_fragment>

		}`
};
class o0 {
    constructor(e, t, n) {
        this.scene = e,
        this.camera = t
    }
    initFloor() {
        const e = new an(100,100)
          , t = new Tr(e,{
            clipBias: .003,
            textureWidth: window.innerWidth * window.devicePixelRatio,
            textureHeight: window.innerHeight * window.devicePixelRatio,
            color: "#FFFFFF",
            recursion: 1
        });
        t.rotation.x = -Math.PI / 2,
        t.position.y = -1.6,
        this.scene.add(t),
        t.receiveShadow = !0;
        const n = new an(100,100)
          , i = new wn({
            color: "#FFFFFF",
            transparent: !0,
            opacity: .9,
            reflectivity: .5,
            blur: .5
        })
          , r = new ct(n,i);
        r.rotation.x = -Math.PI / 2,
        r.position.y = -1.4,
        this.scene.add(r)
    }
}
class a0 extends kM {
    constructor(e) {
        super(e),
        this.type = on
    }
    parse(e) {
        const o = function(w, S) {
            switch (w) {
            case 1:
                throw new Error("THREE.RGBELoader: Read Error: " + (S || ""));
            case 2:
                throw new Error("THREE.RGBELoader: Write Error: " + (S || ""));
            case 3:
                throw new Error("THREE.RGBELoader: Bad File Format: " + (S || ""));
            default:
            case 4:
                throw new Error("THREE.RGBELoader: Memory Error: " + (S || ""))
            }
        }
          , h = `
`
          , d = function(w, S, y) {
            S = S || 1024;
            let G = w.pos
              , F = -1
              , O = 0
              , V = ""
              , B = String.fromCharCode.apply(null, new Uint16Array(w.subarray(G, G + 128)));
            for (; 0 > (F = B.indexOf(h)) && O < S && G < w.byteLength; )
                V += B,
                O += B.length,
                G += 128,
                B += String.fromCharCode.apply(null, new Uint16Array(w.subarray(G, G + 128)));
            return -1 < F ? (w.pos += O + F + 1,
            V + B.slice(0, F)) : !1
        }
          , u = function(w) {
            const S = /^#\?(\S+)/
              , y = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/
              , D = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/
              , G = /^\s*FORMAT=(\S+)\s*$/
              , F = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/
              , O = {
                valid: 0,
                string: "",
                comments: "",
                programtype: "RGBE",
                format: "",
                gamma: 1,
                exposure: 1,
                width: 0,
                height: 0
            };
            let V, B;
            for ((w.pos >= w.byteLength || !(V = d(w))) && o(1, "no header found"),
            (B = V.match(S)) || o(3, "bad initial token"),
            O.valid |= 1,
            O.programtype = B[1],
            O.string += V + `
`; V = d(w),
            V !== !1; ) {
                if (O.string += V + `
`,
                V.charAt(0) === "#") {
                    O.comments += V + `
`;
                    continue
                }
                if ((B = V.match(y)) && (O.gamma = parseFloat(B[1])),
                (B = V.match(D)) && (O.exposure = parseFloat(B[1])),
                (B = V.match(G)) && (O.valid |= 2,
                O.format = B[1]),
                (B = V.match(F)) && (O.valid |= 4,
                O.height = parseInt(B[1], 10),
                O.width = parseInt(B[2], 10)),
                O.valid & 2 && O.valid & 4)
                    break
            }
            return O.valid & 2 || o(3, "missing format specifier"),
            O.valid & 4 || o(3, "missing image size specifier"),
            O
        }
          , f = function(w, S, y) {
            const D = S;
            if (D < 8 || D > 32767 || w[0] !== 2 || w[1] !== 2 || w[2] & 128)
                return new Uint8Array(w);
            D !== (w[2] << 8 | w[3]) && o(3, "wrong scanline width");
            const G = new Uint8Array(4 * S * y);
            G.length || o(4, "unable to allocate buffer space");
            let F = 0
              , O = 0;
            const V = 4 * D
              , B = new Uint8Array(4)
              , q = new Uint8Array(V);
            let W = y;
            for (; W > 0 && O < w.byteLength; ) {
                O + 4 > w.byteLength && o(1),
                B[0] = w[O++],
                B[1] = w[O++],
                B[2] = w[O++],
                B[3] = w[O++],
                (B[0] != 2 || B[1] != 2 || (B[2] << 8 | B[3]) != D) && o(3, "bad rgbe scanline format");
                let ae = 0, le;
                for (; ae < V && O < w.byteLength; ) {
                    le = w[O++];
                    const Ce = le > 128;
                    if (Ce && (le -= 128),
                    (le === 0 || ae + le > V) && o(3, "bad scanline data"),
                    Ce) {
                        const ze = w[O++];
                        for (let X = 0; X < le; X++)
                            q[ae++] = ze
                    } else
                        q.set(w.subarray(O, O + le), ae),
                        ae += le,
                        O += le
                }
                const me = D;
                for (let Ce = 0; Ce < me; Ce++) {
                    let ze = 0;
                    G[F] = q[Ce + ze],
                    ze += D,
                    G[F + 1] = q[Ce + ze],
                    ze += D,
                    G[F + 2] = q[Ce + ze],
                    ze += D,
                    G[F + 3] = q[Ce + ze],
                    F += 4
                }
                W--
            }
            return G
        }
          , g = function(w, S, y, D) {
            const G = w[S + 3]
              , F = Math.pow(2, G - 128) / 255;
            y[D + 0] = w[S + 0] * F,
            y[D + 1] = w[S + 1] * F,
            y[D + 2] = w[S + 2] * F,
            y[D + 3] = 1
        }
          , M = function(w, S, y, D) {
            const G = w[S + 3]
              , F = Math.pow(2, G - 128) / 255;
            y[D + 0] = Ls.toHalfFloat(Math.min(w[S + 0] * F, 65504)),
            y[D + 1] = Ls.toHalfFloat(Math.min(w[S + 1] * F, 65504)),
            y[D + 2] = Ls.toHalfFloat(Math.min(w[S + 2] * F, 65504)),
            y[D + 3] = Ls.toHalfFloat(1)
        }
          , m = new Uint8Array(e);
        m.pos = 0;
        const p = u(m)
          , E = p.width
          , _ = p.height
          , v = f(m.subarray(m.pos), E, _);
        let L, P, A;
        switch (this.type) {
        case Pt:
            A = v.length / 4;
            const w = new Float32Array(A * 4);
            for (let y = 0; y < A; y++)
                g(v, y * 4, w, y * 4);
            L = w,
            P = Pt;
            break;
        case on:
            A = v.length / 4;
            const S = new Uint16Array(A * 4);
            for (let y = 0; y < A; y++)
                M(v, y * 4, S, y * 4);
            L = S,
            P = on;
            break;
        default:
            throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: E,
            height: _,
            data: L,
            header: p.string,
            gamma: p.gamma,
            exposure: p.exposure,
            type: P
        }
    }
    setDataType(e) {
        return this.type = e,
        this
    }
    load(e, t, n, i) {
        function r(o, a) {
            switch (o.type) {
            case Pt:
            case on:
                o.colorSpace = xt,
                o.minFilter = _t,
                o.magFilter = _t,
                o.generateMipmaps = !1,
                o.flipY = !0;
                break
            }
            t && t(o, a)
        }
        return super.load(e, r, n, i)
    }
}
class l0 {
    constructor(e, t) {
        this.scene = e,
        this.renderer = t,
        this.envMapLoaded = !1,
        this.init()
    }
    async init() {
        try {
            const e = await this.loadEnvironment();
            console.log("Environment map loaded:", e),
            this.scene.environment = e,
            this.envMapLoaded = !0;
            const t = new CustomEvent("environmentLoaded");
            document.dispatchEvent(t);
            const n = document.querySelector(".loader-overlay");
            n && (n.style.display = "none")
        } catch (e) {
            console.error("Failed to load environment map:", e)
        }
    }
    loadEnvironment() {
        return new Promise( (e, t) => {
            const n = new a0;
            n.setDataType(Pt),
            n.setCrossOrigin("anonymous");
            const i = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
              , r = i ? "./bg/brown_photostudio_04_2k.hdr" : "./bg/Jewelry-HDRI-Studio-Light-Beel-v5-gray.hdr";
            console.log("Loading HDR for device:", i ? "mobile" : "desktop"),
            n.load(r, o => {
                const a = new ms(this.renderer);
                a.compileEquirectangularShader();
                const l = a.fromEquirectangular(o).texture;
                o.dispose(),
                a.dispose(),
                e(l)
            }
            , void 0, o => {
                console.error("Error loading HDR texture:", o),
                t(o)
            }
            )
        }
        )
    }
}
class c0 {
    constructor(e) {
        this.scene = e,
        this.camera = null,
        this.initCamera()
    }
    initCamera() {
        this.camera = new wt(75,window.innerWidth / window.innerHeight,.1,2e3),
        this.camera.position.set(1, 1, 3),
        this.scene.add(this.camera)
    }
    getCamera() {
        return this.camera
    }
    updateCameraOnResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight,
        this.camera.updateProjectionMatrix()
    }
}
class h0 {
    constructor() {
        this.initRenderer()
    }
    initRenderer() {
        const e = {
            exposure: 1.2,
            toneMapping: "ACESFilmic",
            blurriness: .3,
            intensity: 1
        }
          , t = {
            None: Rn,
            Linear: gc,
            Reinhard: Mc,
            Cineon: _c,
            ACESFilmic: vc,
            AgX: yc,
            Neutral: Sc,
            Custom: xc
        }
          , n = /iPhone|iPad|iPod|Android/i.test(navigator.userAgent)
          , i = n ? Math.min(window.devicePixelRatio, 2) : window.devicePixelRatio;
        this.renderer = new Bg({
            antialias: !n,
            stencil: !0,
            alpha: !0,
            preserveDrawingBuffer: !0,
            powerPreference: "high-performance"
        }),
        this.renderer.setPixelRatio(i),
        this.renderer.toneMapping = t[e.toneMapping],
        this.renderer.toneMappingExposure = e.exposure,
        this.renderer.setSize(window.innerWidth, window.innerHeight),
        this.renderer.localClippingEnabled = !0,
        this.renderer.outputEncoding = void 0,
        n && (this.renderer.shadowMap.enabled = !1,
        this.renderer.shadowMap.type = pc)
    }
    getRenderer() {
        return this.renderer
    }
    updateRendererOnResize() {
        this.renderer.setSize(window.innerWidth, window.innerHeight)
    }
}
const rc = {
    type: "change"
}
  , Ra = {
    type: "start"
}
  , ph = {
    type: "end"
}
  , nr = new vs
  , oc = new We
  , d0 = Math.cos(70 * Oc.DEG2RAD)
  , pt = new C
  , Lt = 2 * Math.PI
  , nt = {
    NONE: -1,
    ROTATE: 0,
    DOLLY: 1,
    PAN: 2,
    TOUCH_ROTATE: 3,
    TOUCH_PAN: 4,
    TOUCH_DOLLY_PAN: 5,
    TOUCH_DOLLY_ROTATE: 6
}
  , uo = 1e-6;
class u0 extends s0 {
    constructor(e, t=null) {
        super(e, t),
        this.state = nt.NONE,
        this.enabled = !0,
        this.target = new C,
        this.cursor = new C,
        this.minDistance = 0,
        this.maxDistance = 1 / 0,
        this.minZoom = 0,
        this.maxZoom = 1 / 0,
        this.minTargetRadius = 0,
        this.maxTargetRadius = 1 / 0,
        this.minPolarAngle = 0,
        this.maxPolarAngle = Math.PI,
        this.minAzimuthAngle = -1 / 0,
        this.maxAzimuthAngle = 1 / 0,
        this.enableDamping = !1,
        this.dampingFactor = .05,
        this.enableZoom = !0,
        this.zoomSpeed = 1,
        this.enableRotate = !0,
        this.rotateSpeed = 1,
        this.enablePan = !0,
        this.panSpeed = 1,
        this.screenSpacePanning = !0,
        this.keyPanSpeed = 7,
        this.zoomToCursor = !1,
        this.autoRotate = !1,
        this.autoRotateSpeed = 2,
        this.keys = {
            LEFT: "ArrowLeft",
            UP: "ArrowUp",
            RIGHT: "ArrowRight",
            BOTTOM: "ArrowDown"
        },
        this.mouseButtons = {
            LEFT: Ai.ROTATE,
            MIDDLE: Ai.DOLLY,
            RIGHT: Ai.PAN
        },
        this.touches = {
            ONE: Ei.ROTATE,
            TWO: Ei.DOLLY_PAN
        },
        this.target0 = this.target.clone(),
        this.position0 = this.object.position.clone(),
        this.zoom0 = this.object.zoom,
        this._domElementKeyEvents = null,
        this._lastPosition = new C,
        this._lastQuaternion = new ln,
        this._lastTargetPosition = new C,
        this._quat = new ln().setFromUnitVectors(e.up, new C(0,1,0)),
        this._quatInverse = this._quat.clone().invert(),
        this._spherical = new sc,
        this._sphericalDelta = new sc,
        this._scale = 1,
        this._panOffset = new C,
        this._rotateStart = new ee,
        this._rotateEnd = new ee,
        this._rotateDelta = new ee,
        this._panStart = new ee,
        this._panEnd = new ee,
        this._panDelta = new ee,
        this._dollyStart = new ee,
        this._dollyEnd = new ee,
        this._dollyDelta = new ee,
        this._dollyDirection = new C,
        this._mouse = new ee,
        this._performCursorZoom = !1,
        this._pointers = [],
        this._pointerPositions = {},
        this._controlActive = !1,
        this._onPointerMove = p0.bind(this),
        this._onPointerDown = f0.bind(this),
        this._onPointerUp = m0.bind(this),
        this._onContextMenu = S0.bind(this),
        this._onMouseWheel = _0.bind(this),
        this._onKeyDown = v0.bind(this),
        this._onTouchStart = x0.bind(this),
        this._onTouchMove = y0.bind(this),
        this._onMouseDown = g0.bind(this),
        this._onMouseMove = M0.bind(this),
        this._interceptControlDown = b0.bind(this),
        this._interceptControlUp = E0.bind(this),
        this.domElement !== null && this.connect(),
        this.update()
    }
    connect() {
        this.domElement.addEventListener("pointerdown", this._onPointerDown),
        this.domElement.addEventListener("pointercancel", this._onPointerUp),
        this.domElement.addEventListener("contextmenu", this._onContextMenu),
        this.domElement.addEventListener("wheel", this._onMouseWheel, {
            passive: !1
        }),
        this.domElement.getRootNode().addEventListener("keydown", this._interceptControlDown, {
            passive: !0,
            capture: !0
        }),
        this.domElement.style.touchAction = "none"
    }
    disconnect() {
        this.domElement.removeEventListener("pointerdown", this._onPointerDown),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.domElement.removeEventListener("pointercancel", this._onPointerUp),
        this.domElement.removeEventListener("wheel", this._onMouseWheel),
        this.domElement.removeEventListener("contextmenu", this._onContextMenu),
        this.stopListenToKeyEvents(),
        this.domElement.getRootNode().removeEventListener("keydown", this._interceptControlDown, {
            capture: !0
        }),
        this.domElement.style.touchAction = "auto"
    }
    dispose() {
        this.disconnect()
    }
    getPolarAngle() {
        return this._spherical.phi
    }
    getAzimuthalAngle() {
        return this._spherical.theta
    }
    getDistance() {
        return this.object.position.distanceTo(this.target)
    }
    listenToKeyEvents(e) {
        e.addEventListener("keydown", this._onKeyDown),
        this._domElementKeyEvents = e
    }
    stopListenToKeyEvents() {
        this._domElementKeyEvents !== null && (this._domElementKeyEvents.removeEventListener("keydown", this._onKeyDown),
        this._domElementKeyEvents = null)
    }
    saveState() {
        this.target0.copy(this.target),
        this.position0.copy(this.object.position),
        this.zoom0 = this.object.zoom
    }
    reset() {
        this.target.copy(this.target0),
        this.object.position.copy(this.position0),
        this.object.zoom = this.zoom0,
        this.object.updateProjectionMatrix(),
        this.dispatchEvent(rc),
        this.update(),
        this.state = nt.NONE
    }
    update(e=null) {
        const t = this.object.position;
        pt.copy(t).sub(this.target),
        pt.applyQuaternion(this._quat),
        this._spherical.setFromVector3(pt),
        this.autoRotate && this.state === nt.NONE && this._rotateLeft(this._getAutoRotationAngle(e)),
        this.enableDamping ? (this._spherical.theta += this._sphericalDelta.theta * this.dampingFactor,
        this._spherical.phi += this._sphericalDelta.phi * this.dampingFactor) : (this._spherical.theta += this._sphericalDelta.theta,
        this._spherical.phi += this._sphericalDelta.phi);
        let n = this.minAzimuthAngle
          , i = this.maxAzimuthAngle;
        isFinite(n) && isFinite(i) && (n < -Math.PI ? n += Lt : n > Math.PI && (n -= Lt),
        i < -Math.PI ? i += Lt : i > Math.PI && (i -= Lt),
        n <= i ? this._spherical.theta = Math.max(n, Math.min(i, this._spherical.theta)) : this._spherical.theta = this._spherical.theta > (n + i) / 2 ? Math.max(n, this._spherical.theta) : Math.min(i, this._spherical.theta)),
        this._spherical.phi = Math.max(this.minPolarAngle, Math.min(this.maxPolarAngle, this._spherical.phi)),
        this._spherical.makeSafe(),
        this.enableDamping === !0 ? this.target.addScaledVector(this._panOffset, this.dampingFactor) : this.target.add(this._panOffset),
        this.target.sub(this.cursor),
        this.target.clampLength(this.minTargetRadius, this.maxTargetRadius),
        this.target.add(this.cursor);
        let r = !1;
        if (this.zoomToCursor && this._performCursorZoom || this.object.isOrthographicCamera)
            this._spherical.radius = this._clampDistance(this._spherical.radius);
        else {
            const o = this._spherical.radius;
            this._spherical.radius = this._clampDistance(this._spherical.radius * this._scale),
            r = o != this._spherical.radius
        }
        if (pt.setFromSpherical(this._spherical),
        pt.applyQuaternion(this._quatInverse),
        t.copy(this.target).add(pt),
        this.object.lookAt(this.target),
        this.enableDamping === !0 ? (this._sphericalDelta.theta *= 1 - this.dampingFactor,
        this._sphericalDelta.phi *= 1 - this.dampingFactor,
        this._panOffset.multiplyScalar(1 - this.dampingFactor)) : (this._sphericalDelta.set(0, 0, 0),
        this._panOffset.set(0, 0, 0)),
        this.zoomToCursor && this._performCursorZoom) {
            let o = null;
            if (this.object.isPerspectiveCamera) {
                const a = pt.length();
                o = this._clampDistance(a * this._scale);
                const l = a - o;
                this.object.position.addScaledVector(this._dollyDirection, l),
                this.object.updateMatrixWorld(),
                r = !!l
            } else if (this.object.isOrthographicCamera) {
                const a = new C(this._mouse.x,this._mouse.y,0);
                a.unproject(this.object);
                const l = this.object.zoom;
                this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
                this.object.updateProjectionMatrix(),
                r = l !== this.object.zoom;
                const c = new C(this._mouse.x,this._mouse.y,0);
                c.unproject(this.object),
                this.object.position.sub(c).add(a),
                this.object.updateMatrixWorld(),
                o = pt.length()
            } else
                console.warn("WARNING: OrbitControls.js encountered an unknown camera type - zoom to cursor disabled."),
                this.zoomToCursor = !1;
            o !== null && (this.screenSpacePanning ? this.target.set(0, 0, -1).transformDirection(this.object.matrix).multiplyScalar(o).add(this.object.position) : (nr.origin.copy(this.object.position),
            nr.direction.set(0, 0, -1).transformDirection(this.object.matrix),
            Math.abs(this.object.up.dot(nr.direction)) < d0 ? this.object.lookAt(this.target) : (oc.setFromNormalAndCoplanarPoint(this.object.up, this.target),
            nr.intersectPlane(oc, this.target))))
        } else if (this.object.isOrthographicCamera) {
            const o = this.object.zoom;
            this.object.zoom = Math.max(this.minZoom, Math.min(this.maxZoom, this.object.zoom / this._scale)),
            o !== this.object.zoom && (this.object.updateProjectionMatrix(),
            r = !0)
        }
        return this._scale = 1,
        this._performCursorZoom = !1,
        r || this._lastPosition.distanceToSquared(this.object.position) > uo || 8 * (1 - this._lastQuaternion.dot(this.object.quaternion)) > uo || this._lastTargetPosition.distanceToSquared(this.target) > uo ? (this.dispatchEvent(rc),
        this._lastPosition.copy(this.object.position),
        this._lastQuaternion.copy(this.object.quaternion),
        this._lastTargetPosition.copy(this.target),
        !0) : !1
    }
    _getAutoRotationAngle(e) {
        return e !== null ? Lt / 60 * this.autoRotateSpeed * e : Lt / 60 / 60 * this.autoRotateSpeed
    }
    _getZoomScale(e) {
        const t = Math.abs(e * .01);
        return Math.pow(.95, this.zoomSpeed * t)
    }
    _rotateLeft(e) {
        this._sphericalDelta.theta -= e
    }
    _rotateUp(e) {
        this._sphericalDelta.phi -= e
    }
    _panLeft(e, t) {
        pt.setFromMatrixColumn(t, 0),
        pt.multiplyScalar(-e),
        this._panOffset.add(pt)
    }
    _panUp(e, t) {
        this.screenSpacePanning === !0 ? pt.setFromMatrixColumn(t, 1) : (pt.setFromMatrixColumn(t, 0),
        pt.crossVectors(this.object.up, pt)),
        pt.multiplyScalar(e),
        this._panOffset.add(pt)
    }
    _pan(e, t) {
        const n = this.domElement;
        if (this.object.isPerspectiveCamera) {
            const i = this.object.position;
            pt.copy(i).sub(this.target);
            let r = pt.length();
            r *= Math.tan(this.object.fov / 2 * Math.PI / 180),
            this._panLeft(2 * e * r / n.clientHeight, this.object.matrix),
            this._panUp(2 * t * r / n.clientHeight, this.object.matrix)
        } else
            this.object.isOrthographicCamera ? (this._panLeft(e * (this.object.right - this.object.left) / this.object.zoom / n.clientWidth, this.object.matrix),
            this._panUp(t * (this.object.top - this.object.bottom) / this.object.zoom / n.clientHeight, this.object.matrix)) : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),
            this.enablePan = !1)
    }
    _dollyOut(e) {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale /= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
        this.enableZoom = !1)
    }
    _dollyIn(e) {
        this.object.isPerspectiveCamera || this.object.isOrthographicCamera ? this._scale *= e : (console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),
        this.enableZoom = !1)
    }
    _updateZoomParameters(e, t) {
        if (!this.zoomToCursor)
            return;
        this._performCursorZoom = !0;
        const n = this.domElement.getBoundingClientRect()
          , i = e - n.left
          , r = t - n.top
          , o = n.width
          , a = n.height;
        this._mouse.x = i / o * 2 - 1,
        this._mouse.y = -(r / a) * 2 + 1,
        this._dollyDirection.set(this._mouse.x, this._mouse.y, 1).unproject(this.object).sub(this.object.position).normalize()
    }
    _clampDistance(e) {
        return Math.max(this.minDistance, Math.min(this.maxDistance, e))
    }
    _handleMouseDownRotate(e) {
        this._rotateStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownDolly(e) {
        this._updateZoomParameters(e.clientX, e.clientX),
        this._dollyStart.set(e.clientX, e.clientY)
    }
    _handleMouseDownPan(e) {
        this._panStart.set(e.clientX, e.clientY)
    }
    _handleMouseMoveRotate(e) {
        this._rotateEnd.set(e.clientX, e.clientY),
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(Lt * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(Lt * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd),
        this.update()
    }
    _handleMouseMoveDolly(e) {
        this._dollyEnd.set(e.clientX, e.clientY),
        this._dollyDelta.subVectors(this._dollyEnd, this._dollyStart),
        this._dollyDelta.y > 0 ? this._dollyOut(this._getZoomScale(this._dollyDelta.y)) : this._dollyDelta.y < 0 && this._dollyIn(this._getZoomScale(this._dollyDelta.y)),
        this._dollyStart.copy(this._dollyEnd),
        this.update()
    }
    _handleMouseMovePan(e) {
        this._panEnd.set(e.clientX, e.clientY),
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd),
        this.update()
    }
    _handleMouseWheel(e) {
        this._updateZoomParameters(e.clientX, e.clientY),
        e.deltaY < 0 ? this._dollyIn(this._getZoomScale(e.deltaY)) : e.deltaY > 0 && this._dollyOut(this._getZoomScale(e.deltaY)),
        this.update()
    }
    _handleKeyDown(e) {
        let t = !1;
        switch (e.code) {
        case this.keys.UP:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(Lt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.BOTTOM:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateUp(-Lt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(0, -this.keyPanSpeed),
            t = !0;
            break;
        case this.keys.LEFT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(Lt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(this.keyPanSpeed, 0),
            t = !0;
            break;
        case this.keys.RIGHT:
            e.ctrlKey || e.metaKey || e.shiftKey ? this._rotateLeft(-Lt * this.rotateSpeed / this.domElement.clientHeight) : this._pan(-this.keyPanSpeed, 0),
            t = !0;
            break
        }
        t && (e.preventDefault(),
        this.update())
    }
    _handleTouchStartRotate(e) {
        if (this._pointers.length === 1)
            this._rotateStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , n = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._rotateStart.set(n, i)
        }
    }
    _handleTouchStartPan(e) {
        if (this._pointers.length === 1)
            this._panStart.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , n = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._panStart.set(n, i)
        }
    }
    _handleTouchStartDolly(e) {
        const t = this._getSecondPointerPosition(e)
          , n = e.pageX - t.x
          , i = e.pageY - t.y
          , r = Math.sqrt(n * n + i * i);
        this._dollyStart.set(0, r)
    }
    _handleTouchStartDollyPan(e) {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enablePan && this._handleTouchStartPan(e)
    }
    _handleTouchStartDollyRotate(e) {
        this.enableZoom && this._handleTouchStartDolly(e),
        this.enableRotate && this._handleTouchStartRotate(e)
    }
    _handleTouchMoveRotate(e) {
        if (this._pointers.length == 1)
            this._rotateEnd.set(e.pageX, e.pageY);
        else {
            const n = this._getSecondPointerPosition(e)
              , i = .5 * (e.pageX + n.x)
              , r = .5 * (e.pageY + n.y);
            this._rotateEnd.set(i, r)
        }
        this._rotateDelta.subVectors(this._rotateEnd, this._rotateStart).multiplyScalar(this.rotateSpeed);
        const t = this.domElement;
        this._rotateLeft(Lt * this._rotateDelta.x / t.clientHeight),
        this._rotateUp(Lt * this._rotateDelta.y / t.clientHeight),
        this._rotateStart.copy(this._rotateEnd)
    }
    _handleTouchMovePan(e) {
        if (this._pointers.length === 1)
            this._panEnd.set(e.pageX, e.pageY);
        else {
            const t = this._getSecondPointerPosition(e)
              , n = .5 * (e.pageX + t.x)
              , i = .5 * (e.pageY + t.y);
            this._panEnd.set(n, i)
        }
        this._panDelta.subVectors(this._panEnd, this._panStart).multiplyScalar(this.panSpeed),
        this._pan(this._panDelta.x, this._panDelta.y),
        this._panStart.copy(this._panEnd)
    }
    _handleTouchMoveDolly(e) {
        const t = this._getSecondPointerPosition(e)
          , n = e.pageX - t.x
          , i = e.pageY - t.y
          , r = Math.sqrt(n * n + i * i);
        this._dollyEnd.set(0, r),
        this._dollyDelta.set(0, Math.pow(this._dollyEnd.y / this._dollyStart.y, this.zoomSpeed)),
        this._dollyOut(this._dollyDelta.y),
        this._dollyStart.copy(this._dollyEnd);
        const o = (e.pageX + t.x) * .5
          , a = (e.pageY + t.y) * .5;
        this._updateZoomParameters(o, a)
    }
    _handleTouchMoveDollyPan(e) {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enablePan && this._handleTouchMovePan(e)
    }
    _handleTouchMoveDollyRotate(e) {
        this.enableZoom && this._handleTouchMoveDolly(e),
        this.enableRotate && this._handleTouchMoveRotate(e)
    }
    _addPointer(e) {
        this._pointers.push(e.pointerId)
    }
    _removePointer(e) {
        delete this._pointerPositions[e.pointerId];
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId) {
                this._pointers.splice(t, 1);
                return
            }
    }
    _isTrackingPointer(e) {
        for (let t = 0; t < this._pointers.length; t++)
            if (this._pointers[t] == e.pointerId)
                return !0;
        return !1
    }
    _trackPointer(e) {
        let t = this._pointerPositions[e.pointerId];
        t === void 0 && (t = new ee,
        this._pointerPositions[e.pointerId] = t),
        t.set(e.pageX, e.pageY)
    }
    _getSecondPointerPosition(e) {
        const t = e.pointerId === this._pointers[0] ? this._pointers[1] : this._pointers[0];
        return this._pointerPositions[t]
    }
    _customWheelEvent(e) {
        const t = e.deltaMode
          , n = {
            clientX: e.clientX,
            clientY: e.clientY,
            deltaY: e.deltaY
        };
        switch (t) {
        case 1:
            n.deltaY *= 16;
            break;
        case 2:
            n.deltaY *= 100;
            break
        }
        return e.ctrlKey && !this._controlActive && (n.deltaY *= 10),
        n
    }
}
function f0(s) {
    this.enabled !== !1 && (this._pointers.length === 0 && (this.domElement.setPointerCapture(s.pointerId),
    this.domElement.addEventListener("pointermove", this._onPointerMove),
    this.domElement.addEventListener("pointerup", this._onPointerUp)),
    !this._isTrackingPointer(s) && (this._addPointer(s),
    s.pointerType === "touch" ? this._onTouchStart(s) : this._onMouseDown(s)))
}
function p0(s) {
    this.enabled !== !1 && (s.pointerType === "touch" ? this._onTouchMove(s) : this._onMouseMove(s))
}
function m0(s) {
    switch (this._removePointer(s),
    this._pointers.length) {
    case 0:
        this.domElement.releasePointerCapture(s.pointerId),
        this.domElement.removeEventListener("pointermove", this._onPointerMove),
        this.domElement.removeEventListener("pointerup", this._onPointerUp),
        this.dispatchEvent(ph),
        this.state = nt.NONE;
        break;
    case 1:
        const e = this._pointers[0]
          , t = this._pointerPositions[e];
        this._onTouchStart({
            pointerId: e,
            pageX: t.x,
            pageY: t.y
        });
        break
    }
}
function g0(s) {
    let e;
    switch (s.button) {
    case 0:
        e = this.mouseButtons.LEFT;
        break;
    case 1:
        e = this.mouseButtons.MIDDLE;
        break;
    case 2:
        e = this.mouseButtons.RIGHT;
        break;
    default:
        e = -1
    }
    switch (e) {
    case Ai.DOLLY:
        if (this.enableZoom === !1)
            return;
        this._handleMouseDownDolly(s),
        this.state = nt.DOLLY;
        break;
    case Ai.ROTATE:
        if (s.ctrlKey || s.metaKey || s.shiftKey) {
            if (this.enablePan === !1)
                return;
            this._handleMouseDownPan(s),
            this.state = nt.PAN
        } else {
            if (this.enableRotate === !1)
                return;
            this._handleMouseDownRotate(s),
            this.state = nt.ROTATE
        }
        break;
    case Ai.PAN:
        if (s.ctrlKey || s.metaKey || s.shiftKey) {
            if (this.enableRotate === !1)
                return;
            this._handleMouseDownRotate(s),
            this.state = nt.ROTATE
        } else {
            if (this.enablePan === !1)
                return;
            this._handleMouseDownPan(s),
            this.state = nt.PAN
        }
        break;
    default:
        this.state = nt.NONE
    }
    this.state !== nt.NONE && this.dispatchEvent(Ra)
}
function M0(s) {
    switch (this.state) {
    case nt.ROTATE:
        if (this.enableRotate === !1)
            return;
        this._handleMouseMoveRotate(s);
        break;
    case nt.DOLLY:
        if (this.enableZoom === !1)
            return;
        this._handleMouseMoveDolly(s);
        break;
    case nt.PAN:
        if (this.enablePan === !1)
            return;
        this._handleMouseMovePan(s);
        break
    }
}
function _0(s) {
    this.enabled === !1 || this.enableZoom === !1 || this.state !== nt.NONE || (s.preventDefault(),
    this.dispatchEvent(Ra),
    this._handleMouseWheel(this._customWheelEvent(s)),
    this.dispatchEvent(ph))
}
function v0(s) {
    this.enabled === !1 || this.enablePan === !1 || this._handleKeyDown(s)
}
function x0(s) {
    switch (this._trackPointer(s),
    this._pointers.length) {
    case 1:
        switch (this.touches.ONE) {
        case Ei.ROTATE:
            if (this.enableRotate === !1)
                return;
            this._handleTouchStartRotate(s),
            this.state = nt.TOUCH_ROTATE;
            break;
        case Ei.PAN:
            if (this.enablePan === !1)
                return;
            this._handleTouchStartPan(s),
            this.state = nt.TOUCH_PAN;
            break;
        default:
            this.state = nt.NONE
        }
        break;
    case 2:
        switch (this.touches.TWO) {
        case Ei.DOLLY_PAN:
            if (this.enableZoom === !1 && this.enablePan === !1)
                return;
            this._handleTouchStartDollyPan(s),
            this.state = nt.TOUCH_DOLLY_PAN;
            break;
        case Ei.DOLLY_ROTATE:
            if (this.enableZoom === !1 && this.enableRotate === !1)
                return;
            this._handleTouchStartDollyRotate(s),
            this.state = nt.TOUCH_DOLLY_ROTATE;
            break;
        default:
            this.state = nt.NONE
        }
        break;
    default:
        this.state = nt.NONE
    }
    this.state !== nt.NONE && this.dispatchEvent(Ra)
}
function y0(s) {
    switch (this._trackPointer(s),
    this.state) {
    case nt.TOUCH_ROTATE:
        if (this.enableRotate === !1)
            return;
        this._handleTouchMoveRotate(s),
        this.update();
        break;
    case nt.TOUCH_PAN:
        if (this.enablePan === !1)
            return;
        this._handleTouchMovePan(s),
        this.update();
        break;
    case nt.TOUCH_DOLLY_PAN:
        if (this.enableZoom === !1 && this.enablePan === !1)
            return;
        this._handleTouchMoveDollyPan(s),
        this.update();
        break;
    case nt.TOUCH_DOLLY_ROTATE:
        if (this.enableZoom === !1 && this.enableRotate === !1)
            return;
        this._handleTouchMoveDollyRotate(s),
        this.update();
        break;
    default:
        this.state = nt.NONE
    }
}
function S0(s) {
    this.enabled !== !1 && s.preventDefault()
}
function b0(s) {
    s.key === "Control" && (this._controlActive = !0,
    this.domElement.getRootNode().addEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
function E0(s) {
    s.key === "Control" && (this._controlActive = !1,
    this.domElement.getRootNode().removeEventListener("keyup", this._interceptControlUp, {
        passive: !0,
        capture: !0
    }))
}
class T0 {
    constructor(e, t) {
        this.camera = e,
        this.rendererDomElement = t,
        this.controls = null,
        this.setupOrbitControls()
    }
    setupOrbitControls() {
        this.controls = new u0(this.camera,this.rendererDomElement),
        this.controls.enableDamping = !0,
        this.controls.dampingFactor = .05,
        this.controls.maxPolarAngle = Math.PI / 2.1,
        this.controls.enableZoom = !0,
        this.controls.enablePan = !1
    }
    updateOrbitControlsTarget(e) {
        e === 2 ? this.controls.target.set(0, 0, 0) : e === 3 ? this.controls.target.set(0, 0, 0) : e === 4 && this.controls.target.set(0, 0, 0),
        this.controls.update()
    }
    updateControls() {
        this.controls.update()
    }
}
class ac extends ba {
    constructor(e, t={}) {
        const n = t.font;
        if (n === void 0)
            super();
        else {
            const i = n.generateShapes(e, t.size);
            t.depth === void 0 && t.height !== void 0 && console.warn("THREE.TextGeometry: .height is now depreciated. Please use .depth instead"),
            t.depth = t.depth !== void 0 ? t.depth : t.height !== void 0 ? t.height : 50,
            t.bevelThickness === void 0 && (t.bevelThickness = 10),
            t.bevelSize === void 0 && (t.bevelSize = 8),
            t.bevelEnabled === void 0 && (t.bevelEnabled = !1),
            super(i, t)
        }
        this.type = "TextGeometry"
    }
}
function lc(s, e) {
    if (e === Jh)
        return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."),
        s;
    if (e === qo || e === Uc) {
        let t = s.getIndex();
        if (t === null) {
            const o = []
              , a = s.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++)
                    o.push(l);
                s.setIndex(o),
                t = s.getIndex()
            } else
                return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."),
                s
        }
        const n = t.count - 2
          , i = [];
        if (e === qo)
            for (let o = 1; o <= n; o++)
                i.push(t.getX(0)),
                i.push(t.getX(o)),
                i.push(t.getX(o + 1));
        else
            for (let o = 0; o < n; o++)
                o % 2 === 0 ? (i.push(t.getX(o)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)),
                i.push(t.getX(o + 1)),
                i.push(t.getX(o)));
        i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const r = s.clone();
        return r.setIndex(i),
        r.clearGroups(),
        r
    } else
        return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e),
        s
}
class wr extends Dn {
    constructor(e) {
        super(e),
        this.dracoLoader = null,
        this.ktx2Loader = null,
        this.meshoptDecoder = null,
        this.pluginCallbacks = [],
        this.register(function(t) {
            return new P0(t)
        }),
        this.register(function(t) {
            return new D0(t)
        }),
        this.register(function(t) {
            return new k0(t)
        }),
        this.register(function(t) {
            return new H0(t)
        }),
        this.register(function(t) {
            return new G0(t)
        }),
        this.register(function(t) {
            return new I0(t)
        }),
        this.register(function(t) {
            return new U0(t)
        }),
        this.register(function(t) {
            return new N0(t)
        }),
        this.register(function(t) {
            return new F0(t)
        }),
        this.register(function(t) {
            return new C0(t)
        }),
        this.register(function(t) {
            return new O0(t)
        }),
        this.register(function(t) {
            return new L0(t)
        }),
        this.register(function(t) {
            return new z0(t)
        }),
        this.register(function(t) {
            return new B0(t)
        }),
        this.register(function(t) {
            return new A0(t)
        }),
        this.register(function(t) {
            return new V0(t)
        }),
        this.register(function(t) {
            return new W0(t)
        })
    }
    load(e, t, n, i) {
        const r = this;
        let o;
        if (this.resourcePath !== "")
            o = this.resourcePath;
        else if (this.path !== "") {
            const c = cs.extractUrlBase(e);
            o = cs.resolveURL(c, this.path)
        } else
            o = cs.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(c) {
            i ? i(c) : console.error(c),
            r.manager.itemError(e),
            r.manager.itemEnd(e)
        }
          , l = new br(this.manager);
        l.setPath(this.path),
        l.setResponseType("arraybuffer"),
        l.setRequestHeader(this.requestHeader),
        l.setWithCredentials(this.withCredentials),
        l.load(e, function(c) {
            try {
                r.parse(c, o, function(h) {
                    t(h),
                    r.manager.itemEnd(e)
                }, a)
            } catch (h) {
                a(h)
            }
        }, n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e,
        this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e,
        this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e,
        this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e),
        this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1),
        this
    }
    parse(e, t, n, i) {
        let r;
        const o = {}
          , a = {}
          , l = new TextDecoder;
        if (typeof e == "string")
            r = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (l.decode(new Uint8Array(e,0,4)) === mh) {
                try {
                    o[Ve.KHR_BINARY_GLTF] = new X0(e)
                } catch (d) {
                    i && i(d);
                    return
                }
                r = JSON.parse(o[Ve.KHR_BINARY_GLTF].content)
            } else
                r = JSON.parse(l.decode(e));
        else
            r = e;
        if (r.asset === void 0 || r.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const c = new s_(r,{
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        c.fileLoader.setRequestHeader(this.requestHeader);
        for (let h = 0; h < this.pluginCallbacks.length; h++) {
            const d = this.pluginCallbacks[h](c);
            d.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"),
            a[d.name] = d,
            o[d.name] = !0
        }
        if (r.extensionsUsed)
            for (let h = 0; h < r.extensionsUsed.length; ++h) {
                const d = r.extensionsUsed[h]
                  , u = r.extensionsRequired || [];
                switch (d) {
                case Ve.KHR_MATERIALS_UNLIT:
                    o[d] = new R0;
                    break;
                case Ve.KHR_DRACO_MESH_COMPRESSION:
                    o[d] = new q0(r,this.dracoLoader);
                    break;
                case Ve.KHR_TEXTURE_TRANSFORM:
                    o[d] = new Y0;
                    break;
                case Ve.KHR_MESH_QUANTIZATION:
                    o[d] = new j0;
                    break;
                default:
                    u.indexOf(d) >= 0 && a[d] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + d + '".')
                }
            }
        c.setExtensions(o),
        c.setPlugins(a),
        c.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise(function(i, r) {
            n.parse(e, t, i, r)
        }
        )
    }
}
function w0() {
    let s = {};
    return {
        get: function(e) {
            return s[e]
        },
        add: function(e, t) {
            s[e] = t
        },
        remove: function(e) {
            delete s[e]
        },
        removeAll: function() {
            s = {}
        }
    }
}
const Ve = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class A0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_LIGHTS_PUNCTUAL,
        this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser
          , t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const r = t[n];
            r.extensions && r.extensions[this.name] && r.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, r.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser
          , n = "light:" + e;
        let i = t.cache.get(n);
        if (i)
            return i;
        const r = t.json
          , l = ((r.extensions && r.extensions[this.name] || {}).lights || [])[e];
        let c;
        const h = new be(16777215);
        l.color !== void 0 && h.setRGB(l.color[0], l.color[1], l.color[2], xt);
        const d = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
        case "directional":
            c = new fh(h),
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        case "point":
            c = new WM(h),
            c.distance = d;
            break;
        case "spot":
            c = new GM(h),
            c.distance = d,
            l.spot = l.spot || {},
            l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0,
            l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4,
            c.angle = l.spot.outerConeAngle,
            c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle,
            c.target.position.set(0, 0, -1),
            c.add(c.target);
            break;
        default:
            throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0),
        c.decay = 2,
        Sn(c, l),
        l.intensity !== void 0 && (c.intensity = l.intensity),
        c.name = t.createUniqueName(l.name || "light_" + e),
        i = Promise.resolve(c),
        t.cache.add(n, i),
        i
    }
    getDependency(e, t) {
        if (e === "light")
            return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this
          , n = this.parser
          , r = n.json.nodes[e]
          , a = (r.extensions && r.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return n._getNodeRef(t.cache, a, l)
        })
    }
}
class R0 {
    constructor() {
        this.name = Ve.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return wn
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new be(1,1,1),
        e.opacity = 1;
        const r = t.pbrMetallicRoughness;
        if (r) {
            if (Array.isArray(r.baseColorFactor)) {
                const o = r.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], xt),
                e.opacity = o[3]
            }
            r.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", r.baseColorTexture, Tt))
        }
        return Promise.all(i)
    }
}
class C0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = i.extensions[this.name].emissiveStrength;
        return r !== void 0 && (t.emissiveIntensity = r),
        Promise.resolve()
    }
}
class P0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor),
        o.clearcoatTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)),
        o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor),
        o.clearcoatRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)),
        o.clearcoatNormalTexture !== void 0 && (r.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)),
        o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new ee(a,a)
        }
        return Promise.all(r)
    }
}
class D0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = i.extensions[this.name];
        return t.dispersion = r.dispersion !== void 0 ? r.dispersion : 0,
        Promise.resolve()
    }
}
class L0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor),
        o.iridescenceTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)),
        o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor),
        t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]),
        o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum),
        o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum),
        o.iridescenceThicknessTexture !== void 0 && r.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)),
        Promise.all(r)
    }
}
class I0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = [];
        t.sheenColor = new be(0,0,0),
        t.sheenRoughness = 0,
        t.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], xt)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor),
        o.sheenColorTexture !== void 0 && r.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Tt)),
        o.sheenRoughnessTexture !== void 0 && r.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)),
        Promise.all(r)
    }
}
class U0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor),
        o.transmissionTexture !== void 0 && r.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)),
        Promise.all(r)
    }
}
class N0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0,
        o.thicknessTexture !== void 0 && r.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)),
        t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new be().setRGB(a[0], a[1], a[2], xt),
        Promise.all(r)
    }
}
class F0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = i.extensions[this.name];
        return t.ior = r.ior !== void 0 ? r.ior : 1.5,
        Promise.resolve()
    }
}
class O0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1,
        o.specularTexture !== void 0 && r.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new be().setRGB(a[0], a[1], a[2], xt),
        o.specularColorTexture !== void 0 && r.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Tt)),
        Promise.all(r)
    }
}
class B0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1,
        o.bumpTexture !== void 0 && r.push(n.assignTexture(t, "bumpMap", o.bumpTexture)),
        Promise.all(r)
    }
}
class z0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Wt
    }
    extendMaterialParams(e, t) {
        const n = this.parser
          , i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name])
            return Promise.resolve();
        const r = []
          , o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength),
        o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation),
        o.anisotropyTexture !== void 0 && r.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)),
        Promise.all(r)
    }
}
class k0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser
          , n = t.json
          , i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name])
            return null;
        const r = i.extensions[this.name]
          , o = t.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0)
                throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, r.source, o)
    }
}
class H0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.EXT_TEXTURE_WEBP,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const o = r.extensions[t]
          , a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return n.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class G0 {
    constructor(e) {
        this.parser = e,
        this.name = Ve.EXT_TEXTURE_AVIF,
        this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name
          , n = this.parser
          , i = n.json
          , r = i.textures[e];
        if (!r.extensions || !r.extensions[t])
            return null;
        const o = r.extensions[t]
          , a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c)
                return n.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0)
                throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=",
            t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        }
        )),
        this.isSupported
    }
}
class V0 {
    constructor(e) {
        this.name = Ve.EXT_MESHOPT_COMPRESSION,
        this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json
          , n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name]
              , r = this.parser.getDependency("buffer", i.buffer)
              , o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0)
                    throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return r.then(function(a) {
                const l = i.byteOffset || 0
                  , c = i.byteLength || 0
                  , h = i.count
                  , d = i.byteStride
                  , u = new Uint8Array(a,l,c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(h, d, u, i.mode, i.filter).then(function(f) {
                    return f.buffer
                }) : o.ready.then(function() {
                    const f = new ArrayBuffer(h * d);
                    return o.decodeGltfBuffer(new Uint8Array(f), h, d, u, i.mode, i.filter),
                    f
                })
            })
        } else
            return null
    }
}
class W0 {
    constructor(e) {
        this.name = Ve.EXT_MESH_GPU_INSTANCING,
        this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json
          , n = t.nodes[e];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0)
            return null;
        const i = t.meshes[n.mesh];
        for (const c of i.primitives)
            if (c.mode !== Ht.TRIANGLES && c.mode !== Ht.TRIANGLE_STRIP && c.mode !== Ht.TRIANGLE_FAN && c.mode !== void 0)
                return null;
        const o = n.extensions[this.name].attributes
          , a = []
          , l = {};
        for (const c in o)
            a.push(this.parser.getDependency("accessor", o[c]).then(h => (l[c] = h,
            l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)),
        Promise.all(a).then(c => {
            const h = c.pop()
              , d = h.isGroup ? h.children : [h]
              , u = c[0].count
              , f = [];
            for (const g of d) {
                const M = new Oe
                  , m = new C
                  , p = new ln
                  , E = new C(1,1,1)
                  , _ = new Xg(g.geometry,g.material,u);
                for (let v = 0; v < u; v++)
                    l.TRANSLATION && m.fromBufferAttribute(l.TRANSLATION, v),
                    l.ROTATION && p.fromBufferAttribute(l.ROTATION, v),
                    l.SCALE && E.fromBufferAttribute(l.SCALE, v),
                    _.setMatrixAt(v, M.compose(m, p, E));
                for (const v in l)
                    if (v === "_COLOR_0") {
                        const L = l[v];
                        _.instanceColor = new Ko(L.array,L.itemSize,L.normalized)
                    } else
                        v !== "TRANSLATION" && v !== "ROTATION" && v !== "SCALE" && g.geometry.setAttribute(v, l[v]);
                it.prototype.copy.call(_, g),
                this.parser.assignFinalMaterial(_),
                f.push(_)
            }
            return h.isGroup ? (h.clear(),
            h.add(...f),
            h) : f[0]
        }
        ))
    }
}
const mh = "glTF"
  , ns = 12
  , cc = {
    JSON: 1313821514,
    BIN: 5130562
};
class X0 {
    constructor(e) {
        this.name = Ve.KHR_BINARY_GLTF,
        this.content = null,
        this.body = null;
        const t = new DataView(e,0,ns)
          , n = new TextDecoder;
        if (this.header = {
            magic: n.decode(new Uint8Array(e.slice(0, 4))),
            version: t.getUint32(4, !0),
            length: t.getUint32(8, !0)
        },
        this.header.magic !== mh)
            throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2)
            throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const i = this.header.length - ns
          , r = new DataView(e,ns);
        let o = 0;
        for (; o < i; ) {
            const a = r.getUint32(o, !0);
            o += 4;
            const l = r.getUint32(o, !0);
            if (o += 4,
            l === cc.JSON) {
                const c = new Uint8Array(e,ns + o,a);
                this.content = n.decode(c)
            } else if (l === cc.BIN) {
                const c = ns + o;
                this.body = e.slice(c, c + a)
            }
            o += a
        }
        if (this.content === null)
            throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class q0 {
    constructor(e, t) {
        if (!t)
            throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = Ve.KHR_DRACO_MESH_COMPRESSION,
        this.json = e,
        this.dracoLoader = t,
        this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json
          , i = this.dracoLoader
          , r = e.extensions[this.name].bufferView
          , o = e.extensions[this.name].attributes
          , a = {}
          , l = {}
          , c = {};
        for (const h in o) {
            const d = ta[h] || h.toLowerCase();
            a[d] = o[h]
        }
        for (const h in e.attributes) {
            const d = ta[h] || h.toLowerCase();
            if (o[h] !== void 0) {
                const u = n.accessors[e.attributes[h]]
                  , f = Ii[u.componentType];
                c[d] = f.name,
                l[d] = u.normalized === !0
            }
        }
        return t.getDependency("bufferView", r).then(function(h) {
            return new Promise(function(d, u) {
                i.decodeDracoFile(h, function(f) {
                    for (const g in f.attributes) {
                        const M = f.attributes[g]
                          , m = l[g];
                        m !== void 0 && (M.normalized = m)
                    }
                    d(f)
                }, a, c, xt, u)
            }
            )
        })
    }
}
class Y0 {
    constructor() {
        this.name = Ve.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(),
        t.texCoord !== void 0 && (e.channel = t.texCoord),
        t.offset !== void 0 && e.offset.fromArray(t.offset),
        t.rotation !== void 0 && (e.rotation = t.rotation),
        t.scale !== void 0 && e.repeat.fromArray(t.scale),
        e.needsUpdate = !0),
        e
    }
}
class j0 {
    constructor() {
        this.name = Ve.KHR_MESH_QUANTIZATION
    }
}
class gh extends ys {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer
          , n = this.sampleValues
          , i = this.valueSize
          , r = e * i * 3 + i;
        for (let o = 0; o !== i; o++)
            t[o] = n[r + o];
        return t
    }
    interpolate_(e, t, n, i) {
        const r = this.resultBuffer
          , o = this.sampleValues
          , a = this.valueSize
          , l = a * 2
          , c = a * 3
          , h = i - t
          , d = (n - t) / h
          , u = d * d
          , f = u * d
          , g = e * c
          , M = g - c
          , m = -2 * f + 3 * u
          , p = f - u
          , E = 1 - m
          , _ = p - u + d;
        for (let v = 0; v !== a; v++) {
            const L = o[M + v + a]
              , P = o[M + v + l] * h
              , A = o[g + v + a]
              , w = o[g + v] * h;
            r[v] = E * L + _ * P + m * A + p * w
        }
        return r
    }
}
const K0 = new ln;
class $0 extends gh {
    interpolate_(e, t, n, i) {
        const r = super.interpolate_(e, t, n, i);
        return K0.fromArray(r).normalize().toArray(r),
        r
    }
}
const Ht = {
    FLOAT: 5126,
    FLOAT_MAT3: 35675,
    FLOAT_MAT4: 35676,
    FLOAT_VEC2: 35664,
    FLOAT_VEC3: 35665,
    FLOAT_VEC4: 35666,
    LINEAR: 9729,
    REPEAT: 10497,
    SAMPLER_2D: 35678,
    POINTS: 0,
    LINES: 1,
    LINE_LOOP: 2,
    LINE_STRIP: 3,
    TRIANGLES: 4,
    TRIANGLE_STRIP: 5,
    TRIANGLE_FAN: 6,
    UNSIGNED_BYTE: 5121,
    UNSIGNED_SHORT: 5123
}
  , Ii = {
    5120: Int8Array,
    5121: Uint8Array,
    5122: Int16Array,
    5123: Uint16Array,
    5125: Uint32Array,
    5126: Float32Array
}
  , hc = {
    9728: Ct,
    9729: _t,
    9984: Ec,
    9985: ir,
    9986: is,
    9987: rn
}
  , dc = {
    33071: sn,
    33648: ur,
    10497: Fi
}
  , fo = {
    SCALAR: 1,
    VEC2: 2,
    VEC3: 3,
    VEC4: 4,
    MAT2: 4,
    MAT3: 9,
    MAT4: 16
}
  , ta = {
    POSITION: "position",
    NORMAL: "normal",
    TANGENT: "tangent",
    TEXCOORD_0: "uv",
    TEXCOORD_1: "uv1",
    TEXCOORD_2: "uv2",
    TEXCOORD_3: "uv3",
    COLOR_0: "color",
    WEIGHTS_0: "skinWeight",
    JOINTS_0: "skinIndex"
}
  , zn = {
    scale: "scale",
    translation: "position",
    rotation: "quaternion",
    weights: "morphTargetInfluences"
}
  , Z0 = {
    CUBICSPLINE: void 0,
    LINEAR: us,
    STEP: ds
}
  , po = {
    OPAQUE: "OPAQUE",
    MASK: "MASK",
    BLEND: "BLEND"
};
function J0(s) {
    return s.DefaultMaterial === void 0 && (s.DefaultMaterial = new En({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Jt
    })),
    s.DefaultMaterial
}
function Jn(s, e, t) {
    for (const n in t.extensions)
        s[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {},
        e.userData.gltfExtensions[n] = t.extensions[n])
}
function Sn(s, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(s.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}
function Q0(s, e, t) {
    let n = !1
      , i = !1
      , r = !1;
    for (let c = 0, h = e.length; c < h; c++) {
        const d = e[c];
        if (d.POSITION !== void 0 && (n = !0),
        d.NORMAL !== void 0 && (i = !0),
        d.COLOR_0 !== void 0 && (r = !0),
        n && i && r)
            break
    }
    if (!n && !i && !r)
        return Promise.resolve(s);
    const o = []
      , a = []
      , l = [];
    for (let c = 0, h = e.length; c < h; c++) {
        const d = e[c];
        if (n) {
            const u = d.POSITION !== void 0 ? t.getDependency("accessor", d.POSITION) : s.attributes.position;
            o.push(u)
        }
        if (i) {
            const u = d.NORMAL !== void 0 ? t.getDependency("accessor", d.NORMAL) : s.attributes.normal;
            a.push(u)
        }
        if (r) {
            const u = d.COLOR_0 !== void 0 ? t.getDependency("accessor", d.COLOR_0) : s.attributes.color;
            l.push(u)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const h = c[0]
          , d = c[1]
          , u = c[2];
        return n && (s.morphAttributes.position = h),
        i && (s.morphAttributes.normal = d),
        r && (s.morphAttributes.color = u),
        s.morphTargetsRelative = !0,
        s
    })
}
function e_(s, e) {
    if (s.updateMorphTargets(),
    e.weights !== void 0)
        for (let t = 0, n = e.weights.length; t < n; t++)
            s.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (s.morphTargetInfluences.length === t.length) {
            s.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++)
                s.morphTargetDictionary[t[n]] = n
        } else
            console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}
function t_(s) {
    let e;
    const t = s.extensions && s.extensions[Ve.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + mo(t.attributes) : e = s.indices + ":" + mo(s.attributes) + ":" + s.mode,
    s.targets !== void 0)
        for (let n = 0, i = s.targets.length; n < i; n++)
            e += ":" + mo(s.targets[n]);
    return e
}
function mo(s) {
    let e = "";
    const t = Object.keys(s).sort();
    for (let n = 0, i = t.length; n < i; n++)
        e += t[n] + ":" + s[t[n]] + ";";
    return e
}
function na(s) {
    switch (s) {
    case Int8Array:
        return 1 / 127;
    case Uint8Array:
        return 1 / 255;
    case Int16Array:
        return 1 / 32767;
    case Uint16Array:
        return 1 / 65535;
    default:
        throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}
function n_(s) {
    return s.search(/\.jpe?g($|\?)/i) > 0 || s.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : s.search(/\.webp($|\?)/i) > 0 || s.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const i_ = new Oe;
class s_ {
    constructor(e={}, t={}) {
        this.json = e,
        this.extensions = {},
        this.plugins = {},
        this.options = t,
        this.cache = new w0,
        this.associations = new Map,
        this.primitiveCache = {},
        this.nodeCache = {},
        this.meshCache = {
            refs: {},
            uses: {}
        },
        this.cameraCache = {
            refs: {},
            uses: {}
        },
        this.lightCache = {
            refs: {},
            uses: {}
        },
        this.sourceCache = {},
        this.textureCache = {},
        this.nodeNamesUsed = {};
        let n = !1
          , i = -1
          , r = !1
          , o = -1;
        if (typeof navigator < "u") {
            const a = navigator.userAgent;
            n = /^((?!chrome|android).)*safari/i.test(a) === !0;
            const l = a.match(/Version\/(\d+)/);
            i = n && l ? parseInt(l[1], 10) : -1,
            r = a.indexOf("Firefox") > -1,
            o = r ? a.match(/Firefox\/([0-9]+)\./)[1] : -1
        }
        typeof createImageBitmap > "u" || n && i < 17 || r && o < 98 ? this.textureLoader = new Ea(this.options.manager) : this.textureLoader = new YM(this.options.manager),
        this.textureLoader.setCrossOrigin(this.options.crossOrigin),
        this.textureLoader.setRequestHeader(this.options.requestHeader),
        this.fileLoader = new br(this.options.manager),
        this.fileLoader.setResponseType("arraybuffer"),
        this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this
          , i = this.json
          , r = this.extensions;
        this.cache.removeAll(),
        this.nodeCache = {},
        this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }),
        Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return Jn(r, a, i),
            Sn(a, i),
            Promise.all(n._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                for (const l of a.scenes)
                    l.updateMatrixWorld();
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || []
          , t = this.json.skins || []
          , n = this.json.meshes || [];
        for (let i = 0, r = t.length; i < r; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++)
                e[o[a]].isBone = !0
        }
        for (let i = 0, r = e.length; i < r; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh),
            o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)),
            o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0),
        e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1)
            return n;
        const i = n.clone()
          , r = (o, a) => {
            const l = this.associations.get(o);
            l != null && this.associations.set(a, l);
            for (const [c,h] of o.children.entries())
                r(h, a.children[c])
        }
        ;
        return r(n, i),
        i.name += "_instance_" + e.uses[t]++,
        i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i)
                return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const r = e(t[i]);
            r && n.push(r)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
            case "scene":
                i = this.loadScene(t);
                break;
            case "node":
                i = this._invokeOne(function(r) {
                    return r.loadNode && r.loadNode(t)
                });
                break;
            case "mesh":
                i = this._invokeOne(function(r) {
                    return r.loadMesh && r.loadMesh(t)
                });
                break;
            case "accessor":
                i = this.loadAccessor(t);
                break;
            case "bufferView":
                i = this._invokeOne(function(r) {
                    return r.loadBufferView && r.loadBufferView(t)
                });
                break;
            case "buffer":
                i = this.loadBuffer(t);
                break;
            case "material":
                i = this._invokeOne(function(r) {
                    return r.loadMaterial && r.loadMaterial(t)
                });
                break;
            case "texture":
                i = this._invokeOne(function(r) {
                    return r.loadTexture && r.loadTexture(t)
                });
                break;
            case "skin":
                i = this.loadSkin(t);
                break;
            case "animation":
                i = this._invokeOne(function(r) {
                    return r.loadAnimation && r.loadAnimation(t)
                });
                break;
            case "camera":
                i = this.loadCamera(t);
                break;
            default:
                if (i = this._invokeOne(function(r) {
                    return r != this && r.getDependency && r.getDependency(e, t)
                }),
                !i)
                    throw new Error("Unknown type: " + e);
                break
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this
              , i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(r, o) {
                return n.getDependency(e, o)
            })),
            this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e]
          , n = this.fileLoader;
        if (t.type && t.type !== "arraybuffer")
            throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0)
            return Promise.resolve(this.extensions[Ve.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(r, o) {
            n.load(cs.resolveURL(t.uri, i.path), r, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        }
        )
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(n) {
            const i = t.byteLength || 0
              , r = t.byteOffset || 0;
            return n.slice(r, r + i)
        })
    }
    loadAccessor(e) {
        const t = this
          , n = this.json
          , i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = fo[i.type]
              , a = Ii[i.componentType]
              , l = i.normalized === !0
              , c = new a(i.count * o);
            return Promise.resolve(new Dt(c,o,l))
        }
        const r = [];
        return i.bufferView !== void 0 ? r.push(this.getDependency("bufferView", i.bufferView)) : r.push(null),
        i.sparse !== void 0 && (r.push(this.getDependency("bufferView", i.sparse.indices.bufferView)),
        r.push(this.getDependency("bufferView", i.sparse.values.bufferView))),
        Promise.all(r).then(function(o) {
            const a = o[0]
              , l = fo[i.type]
              , c = Ii[i.componentType]
              , h = c.BYTES_PER_ELEMENT
              , d = h * l
              , u = i.byteOffset || 0
              , f = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0
              , g = i.normalized === !0;
            let M, m;
            if (f && f !== d) {
                const p = Math.floor(u / f)
                  , E = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + p + ":" + i.count;
                let _ = t.cache.get(E);
                _ || (M = new c(a,p * f,i.count * f / h),
                _ = new kg(M,f / h),
                t.cache.add(E, _)),
                m = new Ma(_,l,u % f / h,g)
            } else
                a === null ? M = new c(i.count * l) : M = new c(a,u,i.count * l),
                m = new Dt(M,l,g);
            if (i.sparse !== void 0) {
                const p = fo.SCALAR
                  , E = Ii[i.sparse.indices.componentType]
                  , _ = i.sparse.indices.byteOffset || 0
                  , v = i.sparse.values.byteOffset || 0
                  , L = new E(o[1],_,i.sparse.count * p)
                  , P = new c(o[2],v,i.sparse.count * l);
                a !== null && (m = new Dt(m.array.slice(),m.itemSize,m.normalized));
                for (let A = 0, w = L.length; A < w; A++) {
                    const S = L[A];
                    if (m.setX(S, P[A * l]),
                    l >= 2 && m.setY(S, P[A * l + 1]),
                    l >= 3 && m.setZ(S, P[A * l + 2]),
                    l >= 4 && m.setW(S, P[A * l + 3]),
                    l >= 5)
                        throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return m
        })
    }
    loadTexture(e) {
        const t = this.json
          , n = this.options
          , r = t.textures[e].source
          , o = t.images[r];
        let a = this.textureLoader;
        if (o.uri) {
            const l = n.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, r, a)
    }
    loadTextureImage(e, t, n) {
        const i = this
          , r = this.json
          , o = r.textures[e]
          , a = r.images[t]
          , l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l])
            return this.textureCache[l];
        const c = this.loadImageSource(t, n).then(function(h) {
            h.flipY = !1,
            h.name = o.name || a.name || "",
            h.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (h.name = a.uri);
            const u = (r.samplers || {})[o.sampler] || {};
            return h.magFilter = hc[u.magFilter] || _t,
            h.minFilter = hc[u.minFilter] || rn,
            h.wrapS = dc[u.wrapS] || Fi,
            h.wrapT = dc[u.wrapT] || Fi,
            i.associations.set(h, {
                textures: e
            }),
            h
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c,
        c
    }
    loadImageSource(e, t) {
        const n = this
          , i = this.json
          , r = this.options;
        if (this.sourceCache[e] !== void 0)
            return this.sourceCache[e].then(d => d.clone());
        const o = i.images[e]
          , a = self.URL || self.webkitURL;
        let l = o.uri || ""
          , c = !1;
        if (o.bufferView !== void 0)
            l = n.getDependency("bufferView", o.bufferView).then(function(d) {
                c = !0;
                const u = new Blob([d],{
                    type: o.mimeType
                });
                return l = a.createObjectURL(u),
                l
            });
        else if (o.uri === void 0)
            throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const h = Promise.resolve(l).then(function(d) {
            return new Promise(function(u, f) {
                let g = u;
                t.isImageBitmapLoader === !0 && (g = function(M) {
                    const m = new vt(M);
                    m.needsUpdate = !0,
                    u(m)
                }
                ),
                t.load(cs.resolveURL(d, r.path), g, void 0, f)
            }
            )
        }).then(function(d) {
            return c === !0 && a.revokeObjectURL(l),
            Sn(d, o),
            d.userData.mimeType = o.mimeType || n_(o.uri),
            d
        }).catch(function(d) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l),
            d
        });
        return this.sourceCache[e] = h,
        h
    }
    assignTexture(e, t, n, i) {
        const r = this;
        return this.getDependency("texture", n.index).then(function(o) {
            if (!o)
                return null;
            if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(),
            o.channel = n.texCoord),
            r.extensions[Ve.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[Ve.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = r.associations.get(o);
                    o = r.extensions[Ve.KHR_TEXTURE_TRANSFORM].extendTexture(o, a),
                    r.associations.set(o, l)
                }
            }
            return i !== void 0 && (o.colorSpace = i),
            e[t] = o,
            o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = t.attributes.tangent === void 0
          , r = t.attributes.color !== void 0
          , o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new nh,
            $t.prototype.copy.call(l, n),
            l.color.copy(n.color),
            l.map = n.map,
            l.sizeAttenuation = !1,
            this.cache.add(a, l)),
            n = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new th,
            $t.prototype.copy.call(l, n),
            l.color.copy(n.color),
            l.map = n.map,
            this.cache.add(a, l)),
            n = l
        }
        if (i || r || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            i && (a += "derivative-tangents:"),
            r && (a += "vertex-colors:"),
            o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = n.clone(),
            r && (l.vertexColors = !0),
            o && (l.flatShading = !0),
            i && (l.normalScale && (l.normalScale.y *= -1),
            l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)),
            this.cache.add(a, l),
            this.associations.set(l, this.associations.get(n))),
            n = l
        }
        e.material = n
    }
    getMaterialType() {
        return En
    }
    loadMaterial(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.materials[e];
        let o;
        const a = {}
          , l = r.extensions || {}
          , c = [];
        if (l[Ve.KHR_MATERIALS_UNLIT]) {
            const d = i[Ve.KHR_MATERIALS_UNLIT];
            o = d.getMaterialType(),
            c.push(d.extendParams(a, r, t))
        } else {
            const d = r.pbrMetallicRoughness || {};
            if (a.color = new be(1,1,1),
            a.opacity = 1,
            Array.isArray(d.baseColorFactor)) {
                const u = d.baseColorFactor;
                a.color.setRGB(u[0], u[1], u[2], xt),
                a.opacity = u[3]
            }
            d.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", d.baseColorTexture, Tt)),
            a.metalness = d.metallicFactor !== void 0 ? d.metallicFactor : 1,
            a.roughness = d.roughnessFactor !== void 0 ? d.roughnessFactor : 1,
            d.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", d.metallicRoughnessTexture)),
            c.push(t.assignTexture(a, "roughnessMap", d.metallicRoughnessTexture))),
            o = this._invokeOne(function(u) {
                return u.getMaterialType && u.getMaterialType(e)
            }),
            c.push(Promise.all(this._invokeAll(function(u) {
                return u.extendMaterialParams && u.extendMaterialParams(e, a)
            })))
        }
        r.doubleSided === !0 && (a.side = Bt);
        const h = r.alphaMode || po.OPAQUE;
        if (h === po.BLEND ? (a.transparent = !0,
        a.depthWrite = !1) : (a.transparent = !1,
        h === po.MASK && (a.alphaTest = r.alphaCutoff !== void 0 ? r.alphaCutoff : .5)),
        r.normalTexture !== void 0 && o !== wn && (c.push(t.assignTexture(a, "normalMap", r.normalTexture)),
        a.normalScale = new ee(1,1),
        r.normalTexture.scale !== void 0)) {
            const d = r.normalTexture.scale;
            a.normalScale.set(d, d)
        }
        if (r.occlusionTexture !== void 0 && o !== wn && (c.push(t.assignTexture(a, "aoMap", r.occlusionTexture)),
        r.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = r.occlusionTexture.strength)),
        r.emissiveFactor !== void 0 && o !== wn) {
            const d = r.emissiveFactor;
            a.emissive = new be().setRGB(d[0], d[1], d[2], xt)
        }
        return r.emissiveTexture !== void 0 && o !== wn && c.push(t.assignTexture(a, "emissiveMap", r.emissiveTexture, Tt)),
        Promise.all(c).then(function() {
            const d = new o(a);
            return r.name && (d.name = r.name),
            Sn(d, r),
            t.associations.set(d, {
                materials: e
            }),
            r.extensions && Jn(i, d, r),
            d
        })
    }
    createUniqueName(e) {
        const t = tt.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0,
        t)
    }
    loadGeometries(e) {
        const t = this
          , n = this.extensions
          , i = this.primitiveCache;
        function r(a) {
            return n[Ve.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return uc(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a]
              , h = t_(c)
              , d = i[h];
            if (d)
                o.push(d.promise);
            else {
                let u;
                c.extensions && c.extensions[Ve.KHR_DRACO_MESH_COMPRESSION] ? u = r(c) : u = uc(new Qt, c, t),
                i[h] = {
                    primitive: c,
                    promise: u
                },
                o.push(u)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this
          , n = this.json
          , i = this.extensions
          , r = n.meshes[e]
          , o = r.primitives
          , a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const h = o[l].material === void 0 ? J0(this.cache) : this.getDependency("material", o[l].material);
            a.push(h)
        }
        return a.push(t.loadGeometries(o)),
        Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1)
              , h = l[l.length - 1]
              , d = [];
            for (let f = 0, g = h.length; f < g; f++) {
                const M = h[f]
                  , m = o[f];
                let p;
                const E = c[f];
                if (m.mode === Ht.TRIANGLES || m.mode === Ht.TRIANGLE_STRIP || m.mode === Ht.TRIANGLE_FAN || m.mode === void 0)
                    p = r.isSkinnedMesh === !0 ? new Gg(M,E) : new ct(M,E),
                    p.isSkinnedMesh === !0 && p.normalizeSkinWeights(),
                    m.mode === Ht.TRIANGLE_STRIP ? p.geometry = lc(p.geometry, Uc) : m.mode === Ht.TRIANGLE_FAN && (p.geometry = lc(p.geometry, qo));
                else if (m.mode === Ht.LINES)
                    p = new qg(M,E);
                else if (m.mode === Ht.LINE_STRIP)
                    p = new xa(M,E);
                else if (m.mode === Ht.LINE_LOOP)
                    p = new Yg(M,E);
                else if (m.mode === Ht.POINTS)
                    p = new jg(M,E);
                else
                    throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + m.mode);
                Object.keys(p.geometry.morphAttributes).length > 0 && e_(p, r),
                p.name = t.createUniqueName(r.name || "mesh_" + e),
                Sn(p, r),
                m.extensions && Jn(i, p, m),
                t.assignFinalMaterial(p),
                d.push(p)
            }
            for (let f = 0, g = d.length; f < g; f++)
                t.associations.set(d[f], {
                    meshes: e,
                    primitives: f
                });
            if (d.length === 1)
                return r.extensions && Jn(i, d[0], r),
                d[0];
            const u = new An;
            r.extensions && Jn(i, u, r),
            t.associations.set(u, {
                meshes: e
            });
            for (let f = 0, g = d.length; f < g; f++)
                u.add(d[f]);
            return u
        })
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e]
          , i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? t = new wt(Oc.radToDeg(i.yfov),i.aspectRatio || 1,i.znear || 1,i.zfar || 2e6) : n.type === "orthographic" && (t = new ma(-i.xmag,i.xmag,i.ymag,-i.ymag,i.znear,i.zfar)),
        n.name && (t.name = this.createUniqueName(n.name)),
        Sn(t, n),
        Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e]
          , n = [];
        for (let i = 0, r = t.joints.length; i < r; i++)
            n.push(this._loadNodeShallow(t.joints[i]));
        return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null),
        Promise.all(n).then(function(i) {
            const r = i.pop()
              , o = i
              , a = []
              , l = [];
            for (let c = 0, h = o.length; c < h; c++) {
                const d = o[c];
                if (d) {
                    a.push(d);
                    const u = new Oe;
                    r !== null && u.fromArray(r.array, c * 16),
                    l.push(u)
                } else
                    console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
            }
            return new va(a,l)
        })
    }
    loadAnimation(e) {
        const t = this.json
          , n = this
          , i = t.animations[e]
          , r = i.name ? i.name : "animation_" + e
          , o = []
          , a = []
          , l = []
          , c = []
          , h = [];
        for (let d = 0, u = i.channels.length; d < u; d++) {
            const f = i.channels[d]
              , g = i.samplers[f.sampler]
              , M = f.target
              , m = M.node
              , p = i.parameters !== void 0 ? i.parameters[g.input] : g.input
              , E = i.parameters !== void 0 ? i.parameters[g.output] : g.output;
            M.node !== void 0 && (o.push(this.getDependency("node", m)),
            a.push(this.getDependency("accessor", p)),
            l.push(this.getDependency("accessor", E)),
            c.push(g),
            h.push(M))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(h)]).then(function(d) {
            const u = d[0]
              , f = d[1]
              , g = d[2]
              , M = d[3]
              , m = d[4]
              , p = [];
            for (let E = 0, _ = u.length; E < _; E++) {
                const v = u[E]
                  , L = f[E]
                  , P = g[E]
                  , A = M[E]
                  , w = m[E];
                if (v === void 0)
                    continue;
                v.updateMatrix && v.updateMatrix();
                const S = n._createAnimationTracks(v, L, P, A, w);
                if (S)
                    for (let y = 0; y < S.length; y++)
                        p.push(S[y])
            }
            return new IM(r,void 0,p)
        })
    }
    createNodeMesh(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(r) {
            const o = n._getNodeRef(n.meshCache, i.mesh, r);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = i.weights.length; l < c; l++)
                        a.morphTargetInfluences[l] = i.weights[l]
            }),
            o
        })
    }
    loadNode(e) {
        const t = this.json
          , n = this
          , i = t.nodes[e]
          , r = n._loadNodeShallow(e)
          , o = []
          , a = i.children || [];
        for (let c = 0, h = a.length; c < h; c++)
            o.push(n.getDependency("node", a[c]));
        const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
        return Promise.all([r, Promise.all(o), l]).then(function(c) {
            const h = c[0]
              , d = c[1]
              , u = c[2];
            u !== null && h.traverse(function(f) {
                f.isSkinnedMesh && f.bind(u, i_)
            });
            for (let f = 0, g = d.length; f < g; f++)
                h.add(d[f]);
            return h
        })
    }
    _loadNodeShallow(e) {
        const t = this.json
          , n = this.extensions
          , i = this;
        if (this.nodeCache[e] !== void 0)
            return this.nodeCache[e];
        const r = t.nodes[e]
          , o = r.name ? i.createUniqueName(r.name) : ""
          , a = []
          , l = i._invokeOne(function(c) {
            return c.createNodeMesh && c.createNodeMesh(e)
        });
        return l && a.push(l),
        r.camera !== void 0 && a.push(i.getDependency("camera", r.camera).then(function(c) {
            return i._getNodeRef(i.cameraCache, r.camera, c)
        })),
        i._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(e)
        }).forEach(function(c) {
            a.push(c)
        }),
        this.nodeCache[e] = Promise.all(a).then(function(c) {
            let h;
            if (r.isBone === !0 ? h = new eh : c.length > 1 ? h = new An : c.length === 1 ? h = c[0] : h = new it,
            h !== c[0])
                for (let d = 0, u = c.length; d < u; d++)
                    h.add(c[d]);
            if (r.name && (h.userData.name = r.name,
            h.name = o),
            Sn(h, r),
            r.extensions && Jn(n, h, r),
            r.matrix !== void 0) {
                const d = new Oe;
                d.fromArray(r.matrix),
                h.applyMatrix4(d)
            } else
                r.translation !== void 0 && h.position.fromArray(r.translation),
                r.rotation !== void 0 && h.quaternion.fromArray(r.rotation),
                r.scale !== void 0 && h.scale.fromArray(r.scale);
            return i.associations.has(h) || i.associations.set(h, {}),
            i.associations.get(h).nodes = e,
            h
        }),
        this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions
          , n = this.json.scenes[e]
          , i = this
          , r = new An;
        n.name && (r.name = i.createUniqueName(n.name)),
        Sn(r, n),
        n.extensions && Jn(t, r, n);
        const o = n.nodes || []
          , a = [];
        for (let l = 0, c = o.length; l < c; l++)
            a.push(i.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let h = 0, d = l.length; h < d; h++)
                r.add(l[h]);
            const c = h => {
                const d = new Map;
                for (const [u,f] of i.associations)
                    (u instanceof $t || u instanceof vt) && d.set(u, f);
                return h.traverse(u => {
                    const f = i.associations.get(u);
                    f != null && d.set(u, f)
                }
                ),
                d
            }
            ;
            return i.associations = c(r),
            r
        })
    }
    _createAnimationTracks(e, t, n, i, r) {
        const o = []
          , a = e.name ? e.name : e.uuid
          , l = [];
        zn[r.path] === zn.weights ? e.traverse(function(u) {
            u.morphTargetInfluences && l.push(u.name ? u.name : u.uuid)
        }) : l.push(a);
        let c;
        switch (zn[r.path]) {
        case zn.weights:
            c = Hi;
            break;
        case zn.rotation:
            c = Gi;
            break;
        case zn.position:
        case zn.scale:
            c = Vi;
            break;
        default:
            switch (n.itemSize) {
            case 1:
                c = Hi;
                break;
            case 2:
            case 3:
            default:
                c = Vi;
                break
            }
            break
        }
        const h = i.interpolation !== void 0 ? Z0[i.interpolation] : us
          , d = this._getArrayFromAccessor(n);
        for (let u = 0, f = l.length; u < f; u++) {
            const g = new c(l[u] + "." + zn[r.path],t.array,d,h);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(g),
            o.push(g)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const n = na(t.constructor)
              , i = new Float32Array(t.length);
            for (let r = 0, o = t.length; r < o; r++)
                i[r] = t[r] * n;
            t = i
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(n) {
            const i = this instanceof Gi ? $0 : gh;
            return new i(this.times,this.values,this.getValueSize() / 3,n)
        }
        ,
        e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}
function r_(s, e, t) {
    const n = e.attributes
      , i = new Pn;
    if (n.POSITION !== void 0) {
        const a = t.json.accessors[n.POSITION]
          , l = a.min
          , c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (i.set(new C(l[0],l[1],l[2]), new C(c[0],c[1],c[2])),
            a.normalized) {
                const h = na(Ii[a.componentType]);
                i.min.multiplyScalar(h),
                i.max.multiplyScalar(h)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else
        return;
    const r = e.targets;
    if (r !== void 0) {
        const a = new C
          , l = new C;
        for (let c = 0, h = r.length; c < h; c++) {
            const d = r[c];
            if (d.POSITION !== void 0) {
                const u = t.json.accessors[d.POSITION]
                  , f = u.min
                  , g = u.max;
                if (f !== void 0 && g !== void 0) {
                    if (l.setX(Math.max(Math.abs(f[0]), Math.abs(g[0]))),
                    l.setY(Math.max(Math.abs(f[1]), Math.abs(g[1]))),
                    l.setZ(Math.max(Math.abs(f[2]), Math.abs(g[2]))),
                    u.normalized) {
                        const M = na(Ii[u.componentType]);
                        l.multiplyScalar(M)
                    }
                    a.max(l)
                } else
                    console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    s.boundingBox = i;
    const o = new dn;
    i.getCenter(o.center),
    o.radius = i.min.distanceTo(i.max) / 2,
    s.boundingSphere = o
}
function uc(s, e, t) {
    const n = e.attributes
      , i = [];
    function r(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            s.setAttribute(a, l)
        })
    }
    for (const o in n) {
        const a = ta[o] || o.toLowerCase();
        a in s.attributes || i.push(r(n[o], a))
    }
    if (e.indices !== void 0 && !s.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            s.setIndex(a)
        });
        i.push(o)
    }
    return je.workingColorSpace !== xt && "COLOR_0"in n && console.warn(`THREE.GLTFLoader: Converting vertex colors from "srgb-linear" to "${je.workingColorSpace}" not supported.`),
    Sn(s, e),
    r_(s, e, t),
    Promise.all(i).then(function() {
        return e.targets !== void 0 ? Q0(s, e.targets, t) : s
    })
}
class o_ extends Dn {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const r = this
          , o = new br(this.manager);
        o.setPath(this.path),
        o.setRequestHeader(this.requestHeader),
        o.setWithCredentials(this.withCredentials),
        o.load(e, function(a) {
            const l = r.parse(JSON.parse(a));
            t && t(l)
        }, n, i)
    }
    parse(e) {
        return new a_(e)
    }
}
class a_ {
    constructor(e) {
        this.isFont = !0,
        this.type = "Font",
        this.data = e
    }
    generateShapes(e, t=100) {
        const n = []
          , i = l_(e, t, this.data);
        for (let r = 0, o = i.length; r < o; r++)
            n.push(...i[r].toShapes());
        return n
    }
}
function l_(s, e, t) {
    const n = Array.from(s)
      , i = e / t.resolution
      , r = (t.boundingBox.yMax - t.boundingBox.yMin + t.underlineThickness) * i
      , o = [];
    let a = 0
      , l = 0;
    for (let c = 0; c < n.length; c++) {
        const h = n[c];
        if (h === `
`)
            a = 0,
            l -= r;
        else {
            const d = c_(h, i, a, l, t);
            a += d.offsetX,
            o.push(d.path)
        }
    }
    return o
}
function c_(s, e, t, n, i) {
    const r = i.glyphs[s] || i.glyphs["?"];
    if (!r) {
        console.error('THREE.Font: character "' + s + '" does not exists in font family ' + i.familyName + ".");
        return
    }
    const o = new i0;
    let a, l, c, h, d, u, f, g;
    if (r.o) {
        const M = r._cachedOutline || (r._cachedOutline = r.o.split(" "));
        for (let m = 0, p = M.length; m < p; )
            switch (M[m++]) {
            case "m":
                a = M[m++] * e + t,
                l = M[m++] * e + n,
                o.moveTo(a, l);
                break;
            case "l":
                a = M[m++] * e + t,
                l = M[m++] * e + n,
                o.lineTo(a, l);
                break;
            case "q":
                c = M[m++] * e + t,
                h = M[m++] * e + n,
                d = M[m++] * e + t,
                u = M[m++] * e + n,
                o.quadraticCurveTo(d, u, c, h);
                break;
            case "b":
                c = M[m++] * e + t,
                h = M[m++] * e + n,
                d = M[m++] * e + t,
                u = M[m++] * e + n,
                f = M[m++] * e + t,
                g = M[m++] * e + n,
                o.bezierCurveTo(d, u, f, g, c, h);
                break
            }
    }
    return {
        offsetX: r.ha * e,
        path: o
    }
}
class h_ {
    constructor(e, t, n, i) {
        this.scene = e,
        this.modelManager = t,
        this.renderer = i,
        i.localClippingEnabled = !0,
        this.clippingPlanes = [],
        this.isEnable = !1,
        this.triEnable = !1,
        this.triBool = !1,
        this.currentVal = 0,
        this.biColorSingleBool = !1,
        this.triColorSingleBool = !1,
        this.helperModeltriRing1 = null,
        this.helperModeltriRing2 = null
    }
    removeClippingTriOneRing() {
        console.log("hell"),
        console.log("hell 2"),
        this.helperModeltriRing1 != null && (this.helperModeltriRing1.traverse(e => {
            e.isMesh && (e.material && e.material.dispose(),
            e.geometry && e.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing1),
        this.helperModeltriRing1 = null),
        this.helperModeltriRing2 != null && (this.helperModeltriRing2.traverse(e => {
            e.isMesh && (e.material && e.material.dispose(),
            e.geometry && e.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing2),
        this.helperModeltriRing2 = null)
    }
    biColorOneRing(e) {
        if (e == "Segment 1:1") {
            this.pmHelper.biColorSegmentOnering();
            return
        }
        this.removeHelperModelAndClipping(),
        this.isEnable = !0;
        let t = 0;
        e === "1:1" ? t = 0 : e === "1:2" ? t = .05 : e === "1:3" && (t = .1);
        let n = this.modelManager.currentDisplayedModels[this.modelManager.selectedModel - 1];
        n || (n = this.modelManager.currentDisplayedModels[0]),
        this.modelManager.currentDisplayedModels.length === 1 && (n.position.set(0, 0, 0),
        this.helperModel = this.cloneModelWithUniqueMaterial(n),
        this.scene.add(this.helperModel),
        this.applyColorToModel(this.helperModel, "#E3E3E2"),
        this.clippingPlaneRingSingleBi = new We(new C(1,0,0),t),
        this.clippingPlaneRingHelperBi = new We(new C(-1,0,0),-t),
        n.traverse(i => {
            i.isMesh && (i.material.clippingPlanes = [this.clippingPlaneRingSingleBi],
            i.material.clipShadows = !0,
            i.material.needsUpdate = !0)
        }
        ),
        this.helperModel.traverse(i => {
            i.isMesh && (i.material.clippingPlanes = [this.clippingPlaneRingHelperBi],
            i.material.clipShadows = !0,
            i.material.needsUpdate = !0)
        }
        ),
        this.biColorSingleBool = !0,
        console.log("Clipping plane applied to the selected model and helper model."))
    }
    handlePair(e, t, n, i) {
        console.log("modelmanager", this.modelManager.currentDisplayedModels.length, this.modelManager.selectedModel, this.modelManager.pair1),
        this.currentVal = n,
        this.triBool = i;
        let r = 0
          , o = .7
          , a = -.7;
        n === "1:1" || (n === "1:2" ? o += .05 : n === "1:3" ? o += .07 : n === "1:4" && (o += .09));
        let l = -.7
          , c = .7;
        n === "1:1" || (n === "1:2" ? l += .05 : n === "1:3" ? l += .07 : n === "1:4" && (l += .09)),
        i == !0 && (o = .7,
        l = -.7),
        r = e,
        a = -.7;
        let h = 0;
        if (this.helperModel = this.cloneModelWithUniqueMaterial(r),
        this.helperModel.position.set(a, h, 0),
        this.scene.add(this.helperModel),
        this.applyColorToModel(this.helperModel, "#E3E3E2"),
        this.clippingPlaneRing1 = new We(new C(1,0,0),o),
        this.clippingPlaneRing1helper = new We(new C(-1,0,0),-o),
        r.traverse(d => {
            d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing1],
            d.material.clipShadows = !0,
            d.material.needsUpdate = !0)
        }
        ),
        this.helperModel.traverse(d => {
            d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing1helper],
            d.material.clipShadows = !0,
            d.material.needsUpdate = !0)
        }
        ),
        i == !0) {
            let d = -.65
              , u = .75;
            n == "1:1:1" ? (d = -.65,
            u = .75) : n === "1:2:1" ? (d = -.63,
            u = .78) : n === "1:3:1" ? (d = -.6,
            u = .8) : n === "1:4:1" ? (d = -.57,
            u = .83) : n === "2:1:2" ? (d = -.657,
            u = .737) : n === "3:1:1" ? (d = -.575,
            u = .665) : n === "2:1:1" && (d = -.56,
            u = .665),
            this.getCurrentColor(r),
            this.helperModeltriRing1 = this.cloneModelWithUniqueMaterial(r),
            this.helperModeltriRing1.position.set(a, 0, 0),
            this.applyColorToModel(r, "#D8BC7E"),
            this.applyColorToModel(this.helperModeltriRing1, "#E3E3E2"),
            this.applyColorToModel(this.helperModel, "#D8BC7E"),
            this.scene.add(this.helperModeltriRing1),
            this.clippingPlaneRing1Tri = new We(new C(1,0,0),u),
            this.clippingPlaneRing1TriHelper = new We(new C(-1,0,0),d),
            this.helperModeltriRing1.traverse(f => {
                f.isMesh && (f.material.clippingPlanes = [this.clippingPlaneRing1Tri, this.clippingPlaneRing1TriHelper],
                f.material.clipShadows = !0,
                f.material.needsUpdate = !0)
            }
            )
        }
        if (r = t,
        c = .7,
        h = -.15,
        this.helperModelring2 = this.cloneModelWithUniqueMaterial(r),
        this.helperModelring2.position.set(c, h, 0),
        this.scene.add(this.helperModelring2),
        this.applyColorToModel(this.helperModelring2, "#E3E3E2"),
        this.clippingPlaneRing2 = new We(new C(1,0,0),l),
        this.clippingPlaneRing2helper = new We(new C(-1,0,0),-l),
        r.traverse(d => {
            d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing2],
            d.material.clipShadows = !0,
            d.material.needsUpdate = !0)
        }
        ),
        this.helperModelring2.traverse(d => {
            d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing2helper],
            d.material.clipShadows = !0,
            d.material.needsUpdate = !0)
        }
        ),
        i == !0) {
            let d = -.65
              , u = .75;
            n == "1:1:1" ? (d = -.65,
            u = .75) : n === "1:2:1" ? (d = -.63,
            u = .78) : n === "1:3:1" ? (d = -.6,
            u = .8) : n === "1:4:1" ? (d = -.57,
            u = .83) : n === "2:1:2" ? (d = -.657,
            u = .737) : n === "3:1:1" ? (d = -.715,
            u = .8) : n === "2:1:1" && (d = -.715,
            u = .81),
            console.log("val 0", n, d, u),
            this.getCurrentColor(r),
            this.helperModeltriRing2 = this.cloneModelWithUniqueMaterial(r),
            this.helperModeltriRing2.position.set(c, h, 0),
            this.applyColorToModel(this.helperModeltriRing2, "#B76E79"),
            this.applyColorToModel(r, "#D8BC7E"),
            this.applyColorToModel(this.helperModeltriRing2, "#E3E3E2"),
            this.applyColorToModel(this.helperModelring2, "#D8BC7E"),
            this.scene.add(this.helperModeltriRing2),
            this.clippingPlaneRing2Tri = new We(new C(1,0,0),d),
            this.clippingPlaneRing2TriHelper = new We(new C(-1,0,0),u),
            this.helperModeltriRing2.traverse(f => {
                f.isMesh && (f.material.clippingPlanes = [this.clippingPlaneRing2Tri, this.clippingPlaneRing2TriHelper],
                f.material.clipShadows = !0,
                f.material.needsUpdate = !0)
            }
            )
        }
    }
    async biTriPair(e, t=!1) {
        this.isEnable = !0,
        this.currentVal = e,
        this.triBool = t;
        let n, i = 0, r = .7;
        if (e == "Segment 1:1") {
            this.pmHelper.biColorSegment();
            return
        }
        const o = this.modelManager.currentDisplayedModels[0]
          , a = this.modelManager.currentDisplayedModels[1];
        if (this.modelManager.selectedModel == 1 ? (n = o,
        i = .7,
        r = -.7,
        e === "1:1" || (e === "1:2" ? i += .05 : e === "1:3" ? i += .07 : e === "1:4" && (i += .09))) : (n = a,
        i = -.7,
        r = .7,
        e === "1:1" || (e === "1:2" ? i += .1 : e === "1:3" ? i += .07 : e === "1:4" && (i += .09))),
        console.log("ring1", e, i),
        !n) {
            console.error("No selected model found.");
            return
        }
        if (this.modelManager.pair1 == !0) {
            this.removeHelperModelAndClipping(1),
            this.removeHelperModelAndClipping(2),
            console.log("groove type", this.modelManager.GrooveType, t, this.scene),
            this.modelManager.GrooveManagerIns.removeMidMeshes(),
            this.handlePair(o, a, e, t),
            await this.modelManager.loadMidMesh(this.modelManager.GrooveType, t),
            this.pmHelper.setoffsetValueGroove(e, t),
            console.log("groove type 2", this.modelManager.GrooveType, t, this.scene);
            return
        }
        if (n == o) {
            this.removeHelperModelAndClipping(1),
            r = -.7;
            let l = 0;
            if (this.helperModel = this.cloneModelWithUniqueMaterial(n),
            this.helperModel.position.set(r, l, 0),
            this.scene.add(this.helperModel),
            this.applyColorToModel(this.helperModel, "#E3E3E2"),
            this.clippingPlaneRing1 = new We(new C(1,0,0),i),
            this.clippingPlaneRing1helper = new We(new C(-1,0,0),-i),
            n.traverse(c => {
                c.isMesh && (c.material.clippingPlanes = [this.clippingPlaneRing1],
                c.material.clipShadows = !0,
                c.material.needsUpdate = !0)
            }
            ),
            this.helperModel.traverse(c => {
                c.isMesh && (c.material.clippingPlanes = [this.clippingPlaneRing1helper],
                c.material.clipShadows = !0,
                c.material.needsUpdate = !0)
            }
            ),
            t == !0) {
                let c = -.65
                  , h = .75;
                e == "1:1:1" ? (c = -.65,
                h = .75) : e === "1:2:1" ? (c = -.63,
                h = .78) : e === "1:3:1" ? (c = -.6,
                h = .8) : e === "1:4:1" ? (c = -.57,
                h = .83) : e === "2:1:2" ? (c = -.657,
                h = .737) : e === "3:1:1" ? (c = -.575,
                h = .665) : e === "2:1:1" && (c = -.56,
                h = .665),
                this.getCurrentColor(n),
                this.helperModeltriRing1 = this.cloneModelWithUniqueMaterial(n),
                this.helperModeltriRing1.position.set(r, 0, 0),
                this.applyColorToModel(n, "#D8BC7E"),
                this.applyColorToModel(this.helperModeltriRing1, "#E3E3E2"),
                this.applyColorToModel(this.helperModel, "#D8BC7E"),
                this.scene.add(this.helperModeltriRing1),
                this.clippingPlaneRing1Tri = new We(new C(1,0,0),h),
                this.clippingPlaneRing1TriHelper = new We(new C(-1,0,0),c),
                console.log("aaaa 1", h, c, e),
                this.helperModeltriRing1.traverse(d => {
                    d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing1Tri, this.clippingPlaneRing1TriHelper],
                    d.material.clipShadows = !0,
                    d.material.needsUpdate = !0)
                }
                )
            }
        } else if (n == a) {
            this.removeHelperModelAndClipping(2),
            console.log("aaaa 2"),
            r = .7;
            let l = -.15;
            if (this.helperModelring2 = this.cloneModelWithUniqueMaterial(n),
            this.helperModelring2.position.set(r, l, 0),
            this.scene.add(this.helperModelring2),
            this.applyColorToModel(this.helperModelring2, "#E3E3E2"),
            this.clippingPlaneRing2 = new We(new C(1,0,0),i),
            this.clippingPlaneRing2helper = new We(new C(-1,0,0),-i),
            n.traverse(c => {
                c.isMesh && (c.material.clippingPlanes = [this.clippingPlaneRing2],
                c.material.clipShadows = !0,
                c.material.needsUpdate = !0)
            }
            ),
            this.helperModelring2.traverse(c => {
                c.isMesh && (c.material.clippingPlanes = [this.clippingPlaneRing2helper],
                c.material.clipShadows = !0,
                c.material.needsUpdate = !0)
            }
            ),
            t == !0) {
                let c = -.65
                  , h = .75;
                e == "1:1:1" ? (c = -.65,
                h = .75) : e === "1:2:1" ? (c = -.63,
                h = .78) : e === "1:3:1" ? (c = -.6,
                h = .8) : e === "1:4:1" ? (c = -.57,
                h = .83) : e === "2:1:2" ? (c = -.657,
                h = .737) : e === "3:1:1" ? (c = -.715,
                h = .8) : e === "2:1:1" && (c = -.715,
                h = .81),
                this.getCurrentColor(n),
                this.helperModeltriRing2 = this.cloneModelWithUniqueMaterial(n),
                this.helperModeltriRing2.position.set(r, l, 0),
                this.applyColorToModel(n, "#D8BC7E"),
                this.applyColorToModel(this.helperModeltriRing2, "#E3E3E2"),
                this.applyColorToModel(this.helperModelring2, "#D8BC7E"),
                this.scene.add(this.helperModeltriRing2),
                this.clippingPlaneRing2Tri = new We(new C(1,0,0),c),
                this.clippingPlaneRing2TriHelper = new We(new C(-1,0,0),h),
                this.helperModeltriRing2.traverse(d => {
                    d.isMesh && (d.material.clippingPlanes = [this.clippingPlaneRing2Tri, this.clippingPlaneRing2TriHelper],
                    d.material.clipShadows = !0,
                    d.material.needsUpdate = !0)
                }
                )
            }
        }
        console.log("Clipping plane applied to the selected model and helper model.")
    }
    getClippingPlanePosition(e) {
        if (!e || !(e instanceof We))
            return console.error("Invalid clipping plane."),
            null;
        const t = e.normal.clone().multiplyScalar(e.constant);
        return console.log("aaa", t),
        t
    }
    getModelPosition(e) {
        if (!e)
            return console.error("No model provided."),
            null;
        e.updateMatrixWorld(!0);
        const t = new C;
        return t.setFromMatrixPosition(e.matrixWorld),
        t
    }
    setoffsetValue(e, t) {
        this.modelManager.currentDisplayedModels.length == 1 && this.biColorSingleBool && (this.clippingPlaneRingSingleBi.constant = parseFloat(-e),
        this.clippingPlaneRingHelperBi.constant = parseFloat(e)),
        this.modelManager.currentDisplayedModels.length == 2 && (t == "Ring 1" && (this.clippingPlaneRing1.constant = parseFloat(-e),
        this.clippingPlaneRing1helper.constant = parseFloat(e),
        this.modelManager.midMesh.position.x = parseFloat(e),
        console.log("ring 1", this.modelManager.midMesh.position.x)),
        t == "Ring 2" && (this.clippingPlaneRing2.constant = parseFloat(-e),
        this.clippingPlaneRing2helper.constant = parseFloat(e),
        this.modelManager.midMesh2.position.x = parseFloat(e),
        console.log("ring 2", this.modelManager.midMesh2.position.x)))
    }
    setoffsetValueTri(e, t, n) {
        if (this.modelManager.currentDisplayedModels.length == 1 && (this.clippingPlaneSingleRingTri.constant = parseFloat(t),
        this.clippingPlaneSingleRingTriHelper.constant = parseFloat(-e)),
        this.modelManager.currentDisplayedModels.length == 2 && (n == "Ring 1" && (this.clippingPlaneRing1Tri.constant = parseFloat(-e),
        this.clippingPlaneRing1TriHelper.constant = parseFloat(-t),
        this.modelManager.midMesh.position.x = parseFloat(e),
        this.modelManager.midMeshTri.position.x = parseFloat(-t),
        console.log("grooove move", this.modelManager.midMesh.position.x, this.modelManager.midMeshTri.position.x)),
        n == "Ring 2")) {
            if (console.log("this.clippingPlaneRing1Tri.constant", this.clippingPlaneRing2Tri.constant, this.clippingPlaneRing2TriHelper.constant),
            this.clippingPlaneRing2Tri.constant = parseFloat(e),
            this.clippingPlaneRing2TriHelper.constant = parseFloat(t),
            e == 0) {
                console.warn("u i i a grooove");
                return
            }
            this.modelManager.midMesh2.position.x = parseFloat(-e),
            this.modelManager.midMeshTri2.position.x = parseFloat(t),
            console.log("grooove move", this.modelManager.midMesh2.position.x, this.modelManager.midMeshTri2.position.x)
        }
    }
    triColorOneRing(e) {
        this.removeHelperModelAndClipping(),
        this.biColorOneRing("1:1");
        let t = .05;
        e == "1:1:1" ? (t = .05,
        console.log("val 0", e, t)) : e === "1:2:1" ? t = .1 : e === "1:3:1" ? t = .12 : e === "1:4:1" && (t = .14),
        console.log("val", e, t);
        const n = this.modelManager.currentDisplayedModels[this.modelManager.selectedModel - 1];
        let i = this.getCurrentColor(n);
        this.helperModeltri = this.cloneModelWithUniqueMaterial(n),
        this.applyColorToModel(this.helperModel, "#" + i),
        this.applyColorToModel(this.helperModeltri, "#E3E3E2"),
        this.scene.add(this.helperModeltri),
        this.clippingPlaneSingleRingTri = new We(new C(-1,0,0),t),
        this.clippingPlaneSingleRingTriHelper = new We(new C(1,0,0),t),
        this.helperModeltri.traverse(r => {
            r.isMesh && (r.material.clippingPlanes = [this.clippingPlaneSingleRingTri, this.clippingPlaneSingleRingTriHelper],
            r.material.clipShadows = !0,
            r.material.needsUpdate = !0)
        }
        )
    }
    colorChangeBi(e, t) {
        e == "#E9D4A4" && (e = "#D8BC7E");
        const n = this.modelManager.currentDisplayedModels[this.modelManager.selectedModel - 1];
        t == 1 ? this.modelManager.selectedModel == 1 ? this.applyColorToModel(this.helperModel, e) : this.modelManager.selectedModel == 2 && this.applyColorToModel(this.helperModelring2, e) : t == 2 ? this.applyColorToModel(n, e) : t == 3 && (this.helperModeltri && this.applyColorToModel(this.helperModeltri, e),
        this.helperModeltriRing1 && this.modelManager.selectedModel == 1 && this.applyColorToModel(this.helperModeltriRing1, e),
        this.helperModeltriRing2 && this.modelManager.selectedModel == 2 && this.applyColorToModel(this.helperModeltriRing2, e))
    }
    colorChangeTri(e, t) {}
    removeHelperModelAndClipping(e=1) {
        let t;
        e == 1 ? t = this.helperModel : e == 2 && (t = this.helperModelring2),
        t ? (t.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(t),
        t = null) : console.warn("No helper model to remove."),
        this.helperModeltri ? (this.helperModeltri.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltri),
        this.helperModeltri = null) : console.warn("No helper model to remove."),
        this.helperModeltriRing1 && this.modelManager.selectedModel == 1 && (this.helperModeltriRing1.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing1),
        this.helperModeltriRing1 = null),
        this.helperModeltriRing2 && this.modelManager.selectedModel == 2 && (this.helperModeltriRing2.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing2),
        this.helperModeltriRing2 = null),
        this.modelManager.pair1 && (this.helperModeltriRing1 && (this.helperModeltriRing1.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing1),
        this.helperModeltriRing1 = null),
        this.helperModeltriRing2 && (this.helperModeltriRing2.traverse(o => {
            o.isMesh && (o.material && o.material.dispose(),
            o.geometry && o.geometry.dispose())
        }
        ),
        this.scene.remove(this.helperModeltriRing2),
        this.helperModeltriRing2 = null));
        const n = this.modelManager.currentDisplayedModels[0]
          , i = this.modelManager.currentDisplayedModels[1];
        let r = 0;
        this.modelManager.selectedModel == 1 && !this.modelManager.pair1 ? r = n : this.modelManager.selectedModel == 2 && !this.modelManager.pair1 && (r = i),
        r ? r.traverse(o => {
            o.isMesh && (o.material.clippingPlanes = [],
            o.material.needsUpdate = !0)
        }
        ) : console.warn("No selected model found to remove clipping planes from."),
        this.modelManager.pair1 && (n ? n.traverse(o => {
            o.isMesh && (o.material.clippingPlanes = [],
            o.material.needsUpdate = !0)
        }
        ) : console.warn("No selected model found to remove clipping planes from."),
        i ? i.traverse(o => {
            o.isMesh && (o.material.clippingPlanes = [],
            o.material.needsUpdate = !0)
        }
        ) : console.warn("No selected model found to remove clipping planes from.")),
        this.clippingPlanes = []
    }
    cloneModelWithUniqueMaterial(e) {
        const t = e.clone();
        return t.traverse(n => {
            n.isMesh && (n.material = n.material.clone(),
            n.material.clippingPlanes = [],
            n.material.needsUpdate = !0)
        }
        ),
        t
    }
    getCurrentColor(e) {
        if (e instanceof $t)
            return e.color ? e.color.getHexString() : (console.warn("Material does not have a color property."),
            null);
        if (e instanceof it) {
            let t = null;
            return e.traverse(n => {
                n.isMesh && n.material && n.material.color && (t = n.material.color.getHexString())
            }
            ),
            t || (console.warn("No material with a color property found in the model."),
            null)
        }
        return console.warn("Input is not a Material or Object3D."),
        null
    }
    applyColorToModel(e, t) {
        console.log("colorvalue", t),
        e.traverse(n => {
            if (n.isMesh) {
                const i = n.material;
                i && i.color && (i.color.set(t),
                i.needsUpdate = !0)
            }
        }
        ),
        console.log(`Color ${t} applied to the model.`),
        console.log("this", this.modelManager.currentDisplayedModels, e)
    }
    changeModelColor(e, t) {
        console.log("colorvalue", t);
        const i = (o => ({
            "#A09F9D": 2,
            "#E9D4A4": 1.14,
            "#D99058": 1.8,
            "#B76E79": 1.2,
            "#C2412D": 1
        })[o.toUpperCase()] || 2)(t);
        r(e, i);
        const r = (o, a) => {
            o.traverse(l => {
                l.isMesh && (l.material = new hn({
                    uniforms: {
                        matcapTexture: {
                            value: this.matcapTexture
                        },
                        highlightTexture: {
                            value: this.highlightTexture
                        },
                        blendFactor: {
                            value: .1
                        },
                        color: {
                            value: new be(t)
                        },
                        colorIntensity: {
                            value: a
                        }
                    },
                    vertexShader: `
                      varying vec3 vNormal;
                      varying vec3 vViewPosition;
                      varying vec2 vUv;

                      void main() {
                        vUv = uv;
                        vNormal = normalize(normalMatrix * normal);
                        vec4 modelViewPosition = modelViewMatrix * vec4(position, 1.0);
                        vViewPosition = -modelViewPosition.xyz;
                        gl_Position = projectionMatrix * modelViewPosition;
                      }
                    `,
                    fragmentShader: `
                      uniform sampler2D matcapTexture;
                      uniform sampler2D highlightTexture;
                      uniform float blendFactor;
                      uniform vec3 color;
                      uniform float colorIntensity;

                      varying vec3 vNormal;
                      varying vec3 vViewPosition;
                      varying vec2 vUv;

                      void main() {
                        vec3 viewDir = normalize(vViewPosition);
                        vec3 reflectedDir = reflect(viewDir, normalize(vNormal));
                        float m = 2.82842712474619 * sqrt(reflectedDir.z + 1.5);
                        vec2 uv = reflectedDir.xy / m + 0.7;

                        // Sample both MatCap textures and increase their brightness
                        vec4 matcapColor = texture2D(matcapTexture, uv) * 1.5;
                        vec4 highlightColor = texture2D(highlightTexture, uv) * 1.3;

                        // Blend the textures with an adjusted factor
                        vec4 blendedColor = mix(matcapColor, highlightColor, blendFactor);

                        // Apply the color tint with dynamic intensity
                        gl_FragColor = vec4(blendedColor.rgb * color * colorIntensity, blendedColor.a);
                      }
                    `
                }),
                l.material.needsUpdate = !0)
            }
            )
        }
    }
}
class d_ {
    bend(e, t, n) {
        let i = 0;
        if (n !== 0)
            if (e.vertices) {
                const r = e.vertices;
                for (let o = 0; o < r.length; o++) {
                    let a = r[o].x
                      , l = r[o].y
                      , c = r[o].z;
                    switch (t) {
                    case "x":
                        i = c * n;
                        break;
                    case "y":
                        i = a * n;
                        break;
                    default:
                        i = a * n;
                        break
                    }
                    let h = Math.sin(i)
                      , d = Math.cos(i);
                    switch (t) {
                    case "x":
                        r[o].x = a,
                        r[o].y = (l - 1 / n) * d + 1 / n,
                        r[o].z = -(l - 1 / n) * h;
                        break;
                    case "y":
                        r[o].x = -(c - 1 / n) * h,
                        r[o].y = l,
                        r[o].z = (c - 1 / n) * d + 1 / n;
                        break;
                    default:
                        r[o].x = -(l - 1 / n) * h,
                        r[o].y = (l - 1 / n) * d + 1 / n,
                        r[o].z = c;
                        break
                    }
                }
                e.verticesNeedUpdate = !0
            } else {
                const r = e.attributes.position.array;
                for (let o = 0; o < r.length; o += 3) {
                    let a = r[o]
                      , l = r[o + 1]
                      , c = r[o + 2];
                    switch (t) {
                    case "x":
                        i = c * n;
                        break;
                    case "y":
                        i = a * n;
                        break;
                    default:
                        i = a * n;
                        break
                    }
                    let h = Math.sin(i)
                      , d = Math.cos(i);
                    switch (t) {
                    case "x":
                        r[o] = a,
                        r[o + 1] = (l - 1 / n) * d + 1 / n,
                        r[o + 2] = -(l - 1 / n) * h;
                        break;
                    case "y":
                        r[o] = -(c - 1 / n) * h,
                        r[o + 1] = l,
                        r[o + 2] = (c - 1 / n) * d + 1 / n;
                        break;
                    default:
                        r[o] = -(l - 1 / n) * h,
                        r[o + 1] = (l - 1 / n) * d + 1 / n,
                        r[o + 2] = c;
                        break
                    }
                }
                e.attributes.position.needsUpdate = !0
            }
    }
}
class u_ {
    constructor(e, t, n) {
        this.scene = e,
        this.renderer = n,
        this.PreciousMetal = t,
        this.models = [],
        this.currentDisplayedModels = [],
        this.currentModelIndex = 0,
        this.selectedModel = 1,
        this.pair1 = !0,
        this.pair2 = !1,
        this.loader = new wr,
        this.tatt = new ac,
        this.fontLoader = new o_,
        this.currentFont = "./src/assets/fonts/Roboto_Regular.json",
        this.currentColor = "",
        this.shadowEnable = !0,
        this.modelGroupRing1 = new An,
        this.modelGroupRing2 = new An,
        this.GrooveBool = !0,
        this.modelId = "P1",
        this.midMesh = null,
        this.midMeshTri = null,
        this.midMesh2 = null,
        this.midMesh2Tri = null,
        this.midmeshGroove1Ring1 = null,
        this.midmeshGroove2Ring1 = null,
        this.midmeshGroove3Ring1 = null,
        this.midmeshGroove4Ring1 = null,
        this.midmeshGroove1Ring2 = null,
        this.midmeshGroove2Ring2 = null,
        this.midmeshGroove3Ring2 = null,
        this.midmeshGroove4Ring2 = null
    }
    getCurrentDisplayedModels() {
        return this.currentDisplayedModels
    }
    addShadowPair() {
        if (this.shadowEnable) {
            const t = new Ea().load("./models/shadow.png", i => {
                i.flipY = !0
            }
            )
              , n = new wn({
                map: t,
                transparent: !0,
                polygonOffset: !0,
                polygonOffsetFactor: -1,
                polygonOffsetUnits: -1
            });
            this.shadowPlane = new ct(new an(2,2),n.clone()),
            this.shadowPlane.scale.set(.7, 1.3, 1),
            this.shadowPlane.rotation.x = -Math.PI / 2,
            this.shadowPlane.position.y = -1.22,
            this.shadowPlane.renderOrder = 1,
            this.shadowClone = new ct(new an(2,2),n.clone()),
            this.shadowClone.scale.set(.7, 1.3, 1),
            this.shadowClone.rotation.x = -Math.PI / 2,
            this.shadowClone.position.y = -1.221,
            this.shadowClone.renderOrder = 2,
            this.shadowCloneRing3 = new ct(new an(2,2),n.clone()),
            this.shadowCloneRing3.scale.set(.7, 1.3, 1),
            this.shadowCloneRing3.rotation.x = -Math.PI / 2,
            this.shadowCloneRing3.position.y = -1.222,
            this.shadowCloneRing3.renderOrder = 3,
            this.shadowCloneRing4 = new ct(new an(2,2),n.clone()),
            this.shadowCloneRing4.scale.set(.7, 1.3, 1),
            this.shadowCloneRing4.rotation.x = -Math.PI / 2,
            this.shadowCloneRing4.position.y = -1.223,
            this.shadowCloneRing4.renderOrder = 4,
            this.scene.add(this.shadowPlane),
            this.scene.add(this.shadowClone),
            this.scene.add(this.shadowCloneRing3),
            this.scene.add(this.shadowCloneRing4),
            this.shadowPlane.visible = !1,
            this.shadowClone.visible = !1,
            this.shadowCloneRing3.visible = !1,
            this.shadowCloneRing4.visible = !1,
            this.updateShadowPositions(),
            this.shadowEnable = !1
        }
    }
    async loadModels(e) {
        return this.modelLoadQueue = [...e],
        this.models = new Array(e.length).fill(null),
        Promise.all([this.matcapPromise, this.highlightPromise]).then( () => {
            console.log("Matcaps loaded. Loading models...");
            const t = e.map( (n, i) => new Promise( (r, o) => {
                this.loader.load(n.glbPath, a => {
                    const l = a.scene;
                    this.models[i] = l,
                    l.traverse(c => {
                        if (c.isMesh && c.material) {
                            const h = c.material;
                            c.material = new En({
                                color: h.color || "#D8BC7E",
                                metalness: .7,
                                roughness: .1,
                                map: h.map,
                                normalMap: h.normalMap,
                                metalnessMap: h.metalnessMap,
                                roughnessMap: h.roughnessMap,
                                emissiveMap: h.emissiveMap,
                                emissive: h.emissive,
                                stencilWrite: !0,
                                stencilRef: 1,
                                stencilFunc: ii,
                                stencilZPass: fs
                            }),
                            c.material.needsUpdate = !0
                        }
                    }
                    ),
                    l.visible = !1,
                    l.userData.modelIndex = i,
                    this.scene.add(l),
                    r(l)
                }
                , void 0, a => o(a))
            }
            ));
            return Promise.all(t)
        }
        ).then(async t => {
            console.log("All models loaded.");
            const n = this.models.findIndex(i => i === null);
            if (n !== -1)
                throw new Error(`Model loading incomplete or out of order at index ${n}`);
            this.currentColor = "#D8BC7E",
            this.switchModel(0, 1, !0, !1)
        }
        ).catch(t => {
            console.error("Error in model loading:", t)
        }
        )
    }
    async loadMidMesh(e, t) {
        const n = document.querySelector(".loader-overlay");
        if (n && (n.style.display = "block"),
        e == null && (e = "V-groove"),
        this.GrooveType = e,
        this.GrooveBoolTri = t,
        console.log("type", e),
        this.midMesh) {
            console.log("Using cached midMesh"),
            this.midMesh.scale.set(1, 1, 1),
            this.midMesh.position.set(0, 0, 0);
            const {x: i, y: r, z: o} = this.GrooveManagerIns.getScaleForModel(this.modelId, e);
            this.pair1 ? (this.midMesh.scale.set(i, r, o),
            this.midMesh.position.x = -.7,
            this.scene.add(this.midMesh),
            this.midMesh.userData = "midMeshRing1",
            this.midMesh2 || (this.midMesh2 = this.cloneModelWithUniqueMaterial(this.midMesh)),
            this.midMesh2.scale.set(i * .85, r * .85, o * .85),
            this.midMesh2.position.set(.7, -.15, 0),
            this.scene.add(this.midMesh2)) : this.selectedModel === 1 ? (this.midMesh.scale.set(i, r, o),
            this.midMesh.position.x = this.currentDisplayedModels[0].position.x,
            this.scene.add(this.midMesh),
            this.midMesh.userData = "midMeshRing1",
            this.midMesh2 && this.scene.children.includes(this.midMesh2) && this.scene.remove(this.midMesh2)) : this.selectedModel === 2 && (this.midMesh2 || (this.midMesh2 = this.cloneModelWithUniqueMaterial(this.midMesh)),
            this.midMesh2.scale.set(i * .85, r * .85, o * .85),
            this.midMesh2.position.x = this.currentDisplayedModels[1].position.x,
            this.midMesh2.position.y = -.15,
            this.scene.add(this.midMesh2),
            this.midMesh && this.scene.children.includes(this.midMesh) && this.scene.remove(this.midMesh)),
            t && this.GrooveManagerIns.triGroovePair(),
            e == "Milgrain" ? ((this.pair1 || this.selectedModel === 1) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh, !0),
            (this.pair1 || this.selectedModel === 2) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh2, !0)) : ((this.pair1 || this.selectedModel === 1) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh, !1),
            (this.pair1 || this.selectedModel === 2) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh2, !1));
            const a = document.querySelector(".loader-overlay");
            return a && (a.style.display = "none"),
            {
                midMesh: this.midMesh,
                midMesh2: this.midMesh2
            }
        }
        try {
            const i = await new Promise( (c, h) => {
                this.loader.load("models/midMesh/DmidMesh.glb", d => c(d), void 0, d => h(d))
            }
            );
            this.midMesh = i.scene,
            this.midMesh.renderOrder = 1,
            this.midMesh.traverse(c => {
                if (c.isMesh && c.material) {
                    const h = c.material;
                    c.material = new En({
                        color: "#D8BC7E",
                        metalness: .9,
                        roughness: .2,
                        map: h.map,
                        normalMap: h.normalMap,
                        metalnessMap: h.metalnessMap,
                        roughnessMap: h.roughnessMap,
                        emissiveMap: h.emissiveMap,
                        emissive: h.emissive,
                        stencilWrite: !0,
                        stencilRef: 0,
                        stencilFunc: Xa,
                        stencilZPass: kn,
                        depthWrite: !0,
                        polygonOffset: !0,
                        polygonOffsetFactor: -1,
                        polygonOffsetUnits: -1
                    }),
                    c.renderOrder = 1
                }
            }
            );
            const {x: r, y: o, z: a} = this.GrooveManagerIns.getScaleForModel(this.modelId, e);
            this.midMesh2 = this.cloneModelWithUniqueMaterial(this.midMesh),
            this.midMesh2.userData = "midMeshRing2",
            this.midMesh2.renderOrder = 1,
            this.pair1 ? (this.midMesh.scale.set(r, o, a),
            this.midMesh.position.x = -.7,
            this.scene.add(this.midMesh),
            this.midMesh.userData = "midMeshRing1",
            this.midMesh2.scale.set(r * .85, o * .85, a * .85),
            this.midMesh2.position.set(.7, -.15, 0),
            this.scene.add(this.midMesh2)) : this.selectedModel === 1 ? (this.midMesh.scale.set(r, o, a),
            this.midMesh.position.x = this.currentDisplayedModels[0].position.x,
            this.scene.add(this.midMesh),
            this.midMesh.userData = "midMeshRing1") : this.selectedModel === 2 && (this.midMesh2.scale.set(r * .85, o * .85, a * .85),
            this.midMesh2.position.x = this.currentDisplayedModels[1].position.x,
            this.midMesh2.position.y = -.15,
            this.scene.add(this.midMesh2)),
            t && this.GrooveManagerIns.triGroovePair(),
            e == "Milgrain" ? ((this.pair1 || this.selectedModel === 1) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh, !0),
            (this.pair1 || this.selectedModel === 2) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh2, !0)) : ((this.pair1 || this.selectedModel === 1) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh, !1),
            (this.pair1 || this.selectedModel === 2) && this.GrooveManagerIns.toggleMilgrainGroove(this.midMesh2, !1)),
            console.log("Loaded and stored midMesh");
            const l = document.querySelector(".loader-overlay");
            return l && (l.style.display = "none"),
            {
                midMesh: this.midMesh,
                midMesh2: this.midMesh2
            }
        } catch (i) {
            throw console.error("Error loading midMesh:", i),
            i
        }
    }
    async loadStepMesh(e, t) {
        try {
            const n = await new Promise( (a, l) => {
                this.loader.load("models/midMesh/DmidMesh.glb", c => a(c), void 0, c => l(c))
            }
            );
            this.stepMesh = n.scene,
            this.stepMesh.traverse(a => {
                if (a.isMesh && a.material) {
                    const l = a.material;
                    a.material = new En({
                        color: "#D8BC7E",
                        metalness: .9,
                        roughness: .2,
                        map: l.map,
                        normalMap: l.normalMap,
                        metalnessMap: l.metalnessMap,
                        roughnessMap: l.roughnessMap,
                        emissiveMap: l.emissiveMap,
                        emissive: l.emissive,
                        stencilWrite: !0,
                        stencilRef: 0,
                        stencilFunc: Xa,
                        stencilZPass: kn,
                        depthWrite: !0,
                        polygonOffset: !0,
                        polygonOffsetFactor: -14,
                        polygonOffsetUnits: -14
                    })
                }
            }
            );
            const {x: i, y: r, z: o} = this.GrooveManagerIns.getScaleForModel(this.modelId, "Milgrain");
            this.stepMesh.scale.set(i, r, o),
            this.stepMesh2 = this.cloneModelWithUniqueMaterial(this.stepMesh),
            this.stepMesh2.scale.set(i * .85, r * .85, o * .85),
            this.stepMesh2.position.set(.7, -.15, 0)
        } catch (n) {
            throw console.error("Error loading midMeshStep:", n),
            n
        }
    }
    optimalThicknessBool(e) {
        if (this.optimalThickness = !!e,
        console.log("Optimal thickness set to:", this.optimalThickness),
        this.optimalThickness && this.pair1) {
            const t = this.currentDisplayedModels[0];
            if (t) {
                const n = t.scale.x / .15;
                this.setOptimalThickness(1, n),
                this.setOptimalThickness(2, n)
            }
        } else if (this.optimalThickness) {
            const t = this.currentDisplayedModels[this.selectedModel - 1];
            if (t) {
                const n = t.scale.x / .15;
                this.setOptimalThickness(this.selectedModel, n)
            }
        }
    }
    setOptimalThickness(e, t) {
        const o = ((t - 1) / 11 + 1) * 1.5;
        this.pair1 && e === 1 ? (this.changeRingThickness(1, o.toFixed(2).replace(".", ",") + " mm", !1),
        this.changeRingThickness(2, o.toFixed(2).replace(".", ",") + " mm", !1),
        console.log(`Optimal thickness set to ${o.toFixed(2)} for both rings based on width ${t}`)) : (this.changeRingThickness(e, o.toFixed(2).replace(".", ",") + " mm", !1),
        console.log(`Optimal thickness set to ${o.toFixed(2)} for ring ${e} based on width ${t}`))
    }
    changeRingWidth(e, t, n=!0) {
        this.pair1 == !0 ? (this.PreciousMetal.removeHelperModelAndClipping(1),
        this.PreciousMetal.removeHelperModelAndClipping(2)) : this.PreciousMetal.removeHelperModelAndClipping(e);
        const i = parseFloat(t.replace(",", "."));
        if (isNaN(i)) {
            console.warn("Invalid width value:", t);
            return
        }
        const r = this.currentDisplayedModels[e - 1];
        if (!r) {
            console.warn("Model not found for selectedRingId:", e);
            return
        }
        if (this.pair1 == !0)
            for (let o = 0; o < this.currentDisplayedModels.length; o++)
                this.currentDisplayedModels[o] && (this.currentDisplayedModels[o].scale.setX(i * .15),
                console.log(`Ring ${o + 1} width changed to: ${i}mm (pair mode)`),
                this.optimalThickness && this.setOptimalThickness(o + 1, i));
        else
            r.scale.setX(i * .15),
            console.log(`Ring ${e} width changed to: ${i}mm (individual mode)`),
            this.optimalThickness && this.setOptimalThickness(e, i)
    }
    changeRingThickness(e, t, n=!1) {
        this.pair1 == !0 ? (this.PreciousMetal.removeHelperModelAndClipping(1),
        this.PreciousMetal.removeHelperModelAndClipping(2)) : this.PreciousMetal.removeHelperModelAndClipping(e);
        const i = parseFloat(t.replace(",", "."));
        if (isNaN(i)) {
            console.warn("Invalid thickness value:", t);
            return
        }
        const r = 1
          , a = (i - r) / (12 - r) + 1;
        if (this.pair1 == !0) {
            for (let l = 0; l < this.currentDisplayedModels.length; l++)
                if (this.currentDisplayedModels[l]) {
                    let c = l + 1 == 2 ? .8 : 1;
                    this.currentDisplayedModels[l].scale.setY(a * c),
                    this.currentDisplayedModels[l].scale.setZ(a * c),
                    console.log(`Ring ${l + 1} thickness changed to: ${i}mm (pair mode)`)
                }
        } else {
            const l = this.currentDisplayedModels[e - 1];
            if (!l) {
                console.warn("Model not found for selectedRingId:", e);
                return
            }
            let c = e == 2 ? .8 : 1;
            l.scale.setY(a * c),
            l.scale.setZ(a * c),
            console.log(`Ring ${e} thickness changed to: ${i}mm (individual mode)`)
        }
    }
    setSizeCountryWise(e) {
        const t = this.getThicknessForSize(e);
        this.pair1 == !0 ? (this.changeRingThickness(1, t),
        this.changeRingThickness(2, t)) : this.changeRingThickness(this.selectedModel, t)
    }
    getThicknessForSize(e) {
        return {
            F: "1,20 mm",
            "F": "1,40 mm",
            G: "1,60 mm",
            "G": "1,80 mm",
            H: "2,00 mm",
            "H": "2,20 mm",
            I: "2,40 mm",
            "I": "2,50 mm",
            J: "2,70 mm",
            "J": "2,70 mm"
        }[e] || "2,00 mm"
    }
    currentSelectedRing(e) {
        console.log("id is ", e),
        this.selectedModel = e
    }
    currentPairUpdate(e) {
        this.pair1 = e.pair1,
        this.pair2 = e.pair2,
        console.log("this.pap", this.pair1, this.pair2)
    }
    switchModel(e, t=1, n=!0, i=!1) {
        if (this.currentColor = "#D8BC7E",
        this.PreciousMetal.isEnable == !0,
        e < 0 || e >= this.models.length) {
            console.warn("Invalid model index:", e);
            return
        }
        if (console.log("chk 0", n, t, this.pair1),
        this.selectedModel = t,
        t == 1 || t == 2) {
            this.showCurrentModels(e, this.pair1),
            console.log("chk 1");
            let r = 0;
            if (this.PreciousMetal.isEnable == !0) {
                console.log("chk 2");
                let o = this.currentDisplayedModels[0], a = this.currentDisplayedModels[1], l;
                this.PreciousMetal.currentVal ? r = this.PreciousMetal.currentVal : r = "1:1",
                this.PreciousMetal.triBool && (l = this.PreciousMetal.triBool),
                console.log("chk aa", r, l),
                r == "Segment 1:1" ? this.PreciousMetal.biTriPair(r, !1) : (console.log("chk 3", t, o, a),
                t == 1 ? this.PreciousMetal.removeHelperModelAndClipping(1) : this.PreciousMetal.removeHelperModelAndClipping(2),
                this.PreciousMetal.biTriPair(r, l))
            }
        } else
            i ? (this.showThirdModel(e, i),
            this.showFourthModel(e, i)) : t === 1 ? (this.currentModelIndex = e,
            this.showCurrentModels(e, !1)) : t === 2 ? (this.currentModelIndex = e,
            this.showSecondModel(e)) : t === 3 && this.currentDisplayedModels[2] ? (this.currentModelIndex = e,
            this.showThirdModel(e, !1)) : t === 4 && this.currentDisplayedModels[3] ? (this.currentModelIndex = e,
            this.showFourthModel(e, !1)) : console.warn("Invalid ring selection for model switching.");
        this.updateRingPositions()
    }
    showCurrentModels(e, t=!1) {
        const n = this.models[e]
          , i = this.cloneModelWithUniqueMaterial(n);
        if (this.pair1 && t) {
            const r = this.cloneModelWithUniqueMaterial(n);
            this.hideFirstTwoModels(),
            this.scene.add(i),
            i.visible = !0,
            this.currentDisplayedModels[0] = i,
            r.scale.set(.85, .85, .85),
            this.scene.add(r),
            r.visible = !0,
            this.currentDisplayedModels[1] = r,
            this.applyColorToModel(i, "#D8BC7E"),
            this.applyColorToModel(r, "#D8BC7E"),
            this.addShadowPair()
        } else
            this.selectedModel === 1 ? (this.currentDisplayedModels[0] && this.scene.remove(this.currentDisplayedModels[0]),
            this.scene.add(i),
            this.applyColorToModel(i, "#D8BC7E"),
            i.visible = !0,
            this.currentDisplayedModels[0] = i) : this.selectedModel === 2 && (this.currentDisplayedModels[1] && this.scene.remove(this.currentDisplayedModels[1]),
            i.scale.set(.85, .85, .85),
            this.scene.add(i),
            this.applyColorToModel(i, "#D8BC7E"),
            i.visible = !0,
            this.currentDisplayedModels[1] = i);
        this.updateRingPositions()
    }
    showSecondModel(e) {
        this.currentDisplayedModels[1] && this.scene.remove(this.currentDisplayedModels[1]);
        const t = this.cloneModelWithUniqueMaterial(this.models[e]);
        t.scale.set(.85, .85, .85),
        t.visible = !0,
        this.scene.add(t),
        this.currentDisplayedModels[1] = t,
        this.applyColorToModel(t, "#D8BC7E"),
        this.updateRingPositions()
    }
    showThirdModel(e, t=!1) {
        const n = this.models[e].clone();
        if (t) {
            const i = this.models[e].clone();
            this.currentDisplayedModels[2] && this.scene.remove(this.currentDisplayedModels[2]),
            this.currentDisplayedModels[3] && this.scene.remove(this.currentDisplayedModels[3]),
            n.scale.set(.85, .85, .85),
            i.scale.set(.85, .85, .85),
            this.scene.add(n),
            n.visible = !0,
            this.currentDisplayedModels[2] = n,
            this.scene.add(i),
            i.visible = !0,
            this.currentDisplayedModels[3] = i,
            this.applyColorToModel(n, "#D8BC7E"),
            this.applyColorToModel(i, "#D8BC7E")
        } else
            this.currentDisplayedModels[2] && this.scene.remove(this.currentDisplayedModels[2]),
            n.scale.set(.85, .85, .85),
            this.scene.add(n),
            n.visible = !0,
            this.currentDisplayedModels[2] = n,
            this.applyColorToModel(n, "#D8BC7E");
        this.updateRingPositions()
    }
    showFourthModel(e, t=!1) {
        const n = this.models[e].clone();
        if (t) {
            const i = this.models[e].clone();
            this.currentDisplayedModels[2] && this.scene.remove(this.currentDisplayedModels[2]),
            this.currentDisplayedModels[3] && this.scene.remove(this.currentDisplayedModels[3]),
            i.scale.set(.85, .85, .85),
            n.scale.set(.85, .85, .85),
            this.scene.add(i),
            i.visible = !0,
            this.currentDisplayedModels[2] = i,
            this.scene.add(n),
            n.visible = !0,
            this.currentDisplayedModels[3] = n,
            this.applyColorToModel(i, "#D8BC7E"),
            this.applyColorToModel(n, "#D8BC7E")
        } else
            this.currentDisplayedModels[3] && this.scene.remove(this.currentDisplayedModels[3]),
            n.scale.set(.85, .85, .85),
            this.scene.add(n),
            n.visible = !0,
            this.currentDisplayedModels[3] = n,
            this.applyColorToModel(n, "#D8BC7E");
        this.updateRingPositions()
    }
    countVisibleModels() {
        return this.currentDisplayedModels.filter(e => e && e.visible).length
    }
    updateRingPositions() {
        switch (this.countVisibleModels()) {
        case 1:
            this.currentDisplayedModels[0] && this.currentDisplayedModels[0].visible ? this.currentDisplayedModels[0].position.set(0, 0, 0) : this.currentDisplayedModels[1] && this.currentDisplayedModels[1].visible ? (this.currentDisplayedModels[1].position.set(0, -.15, 0),
            this.currentDisplayedModels[1].scale.set(.85, .85, .85)) : this.currentDisplayedModels[2] && this.currentDisplayedModels[2].visible ? (this.currentDisplayedModels[2].position.set(0, -.15, 0),
            this.currentDisplayedModels[2].scale.set(.85, .85, .85)) : this.currentDisplayedModels[3] && this.currentDisplayedModels[3].visible && (this.currentDisplayedModels[3].position.set(0, -.15, 0),
            this.currentDisplayedModels[3].scale.set(.85, .85, .85));
            break;
        case 2:
            let t = -1
              , n = -1;
            for (let a = 0; a < this.currentDisplayedModels.length; a++)
                if (this.currentDisplayedModels[a] && this.currentDisplayedModels[a].visible)
                    if (t === -1)
                        t = a;
                    else {
                        n = a;
                        break
                    }
            t !== -1 && (this.currentDisplayedModels[t].position.set(-.7, t === 0 ? 0 : -.15, 0),
            t > 0 && this.currentDisplayedModels[t].scale.set(.85, .85, .85)),
            n !== -1 && (this.currentDisplayedModels[n].position.set(.7, n === 0 ? 0 : -.15, 0),
            n > 0 && this.currentDisplayedModels[n].scale.set(.85, .85, .85));
            break;
        case 3:
            let i = -1
              , r = -1
              , o = -1;
            for (let a = 0; a < this.currentDisplayedModels.length; a++)
                if (this.currentDisplayedModels[a] && this.currentDisplayedModels[a].visible)
                    if (i === -1)
                        i = a;
                    else if (r === -1)
                        r = a;
                    else {
                        o = a;
                        break
                    }
            i !== -1 && (this.currentDisplayedModels[i].position.set(-1.1, i === 0 ? 0 : -.15, 0),
            i > 0 && this.currentDisplayedModels[i].scale.set(.85, .85, .85)),
            r !== -1 && (this.currentDisplayedModels[r].position.set(0, r === 0 ? 0 : -.15, 0),
            r > 0 && this.currentDisplayedModels[r].scale.set(.85, .85, .85)),
            o !== -1 && (this.currentDisplayedModels[o].position.set(1.1, o === 0 ? 0 : -.15, 0),
            o > 0 && this.currentDisplayedModels[o].scale.set(.85, .85, .85));
            break;
        case 4:
            this.currentDisplayedModels[0] && this.currentDisplayedModels[0].visible && this.currentDisplayedModels[0].position.set(-1.5, 0, 0),
            this.currentDisplayedModels[1] && this.currentDisplayedModels[1].visible && (this.currentDisplayedModels[1].position.set(-.5, -.15, 0),
            this.currentDisplayedModels[1].scale.set(.85, .85, .85)),
            this.currentDisplayedModels[2] && this.currentDisplayedModels[2].visible && (this.currentDisplayedModels[2].position.set(.5, -.15, 0),
            this.currentDisplayedModels[2].scale.set(.85, .85, .85)),
            this.currentDisplayedModels[3] && this.currentDisplayedModels[3].visible && (this.currentDisplayedModels[3].position.set(1.5, -.15, 0),
            this.currentDisplayedModels[3].scale.set(.85, .85, .85));
            break
        }
        this.updateShadowPositions()
    }
    updateShadowPositions() {
        if (!this.shadowPlane)
            return;
        this.countVisibleModels(),
        this.shadowPlane && (this.shadowPlane.visible = !1),
        this.shadowClone && (this.shadowClone.visible = !1),
        this.shadowCloneRing3 && (this.shadowCloneRing3.visible = !1),
        this.shadowCloneRing4 && (this.shadowCloneRing4.visible = !1);
        let e = 0;
        for (let t = 0; t < this.currentDisplayedModels.length; t++)
            if (this.currentDisplayedModels[t] && this.currentDisplayedModels[t].visible) {
                const n = this.currentDisplayedModels[t].position.x;
                e === 0 && this.shadowPlane ? (this.shadowPlane.position.x = n,
                this.shadowPlane.position.y = -1.22,
                this.shadowPlane.visible = !0) : e === 1 && this.shadowClone ? (this.shadowClone.position.x = n,
                this.shadowClone.position.y = -1.221,
                this.shadowClone.visible = !0) : e === 2 && this.shadowCloneRing3 ? (this.shadowCloneRing3.position.x = n,
                this.shadowCloneRing3.position.y = -1.222,
                this.shadowCloneRing3.visible = !0) : e === 3 && this.shadowCloneRing4 && (this.shadowCloneRing4.position.x = n,
                this.shadowCloneRing4.position.y = -1.223,
                this.shadowCloneRing4.visible = !0),
                e++
            }
    }
    cloneModelWithUniqueMaterial(e) {
        const t = e.clone();
        return t.traverse(n => {
            n.isMesh && (n.material = n.material.clone(),
            n.material.clippingPlanes = [],
            n.material.needsUpdate = !0)
        }
        ),
        t
    }
    hideFirstTwoModels() {
        this.currentDisplayedModels[0] && this.scene.remove(this.currentDisplayedModels[0]),
        this.currentDisplayedModels[1] && this.scene.remove(this.currentDisplayedModels[1])
    }
    cloneModelWithUniqueMaterial(e) {
        const t = e.clone();
        return t.traverse(n => {
            n.isMesh && (n.material = n.material.clone(),
            n.material.clippingPlanes = [],
            n.material.needsUpdate = !0)
        }
        ),
        t
    }
    addSecondModel(e, t=null) {
        this.PreciousMetal.removeHelperModelAndClipping(1),
        this.PreciousMetal.removeHelperModelAndClipping(2);
        let n;
        if (e == "engagement") {
            console.log("aaaaa", this.EngagementRingsins),
            this.EngagementRingsins.loadEngRingById(t.id),
            this.currentDisplayedModels[0].position.x = -.7,
            this.shadowPlane != null && (this.shadowPlane.position.x = -.7),
            this.shadowClone != null && (this.shadowClone.visible = !0,
            this.shadowClone.position.x = .7);
            return
        }
        if (e == "memoir") {
            console.log("raaaaa memoir", this.MemoirRingsins),
            this.MemoirRingsins.loadMemoirRingById(t.id),
            this.currentDisplayedModels[0].position.x = -.7,
            this.shadowPlane != null && (this.shadowPlane.position.x = -.7),
            this.shadowClone != null && (this.shadowClone.visible = !0,
            this.shadowClone.position.x = .7);
            return
        }
        if (e == "Wedding" && t && t.id >= 0 && t.id < this.models.length)
            console.log("aaaaa"),
            n = this.cloneModelWithUniqueMaterial(this.models[t.id]),
            n.userData.modelId = t.id;
        else if (e === "Wedding")
            n = this.cloneModelWithUniqueMaterial(this.currentDisplayedModels[0]);
        else {
            console.warn("Invalid type or selectedRing for second model");
            return
        }
        this.currentDisplayedModels[0].position.set(-.7, 0, 0),
        n.position.set(.7, -.15, 0),
        n.scale.set(.85, .85, .85),
        this.PreciousMetal.helperModel && (this.PreciousMetal.helperModel.position.x = -.7),
        this.shadowPlane.position.x = -.7,
        this.shadowClone.visible = !0,
        this.scene.add(n),
        n.visible = !0,
        this.currentDisplayedModels.push(n)
    }
    async addThirdModel(e, t=null) {
        let n;
        if (console.log("type 15", e, t),
        e.toLowerCase().includes("engage")) {
            console.log("aaaaa", this.EngagementRingsins),
            await this.EngagementRingsins.loadEngRingById(t.id),
            this.currentDisplayedModels[0].position.set(-1.1, 0, 0),
            this.currentDisplayedModels[1].position.set(0, -.15, 0),
            this.currentDisplayedModels[2] && (this.currentDisplayedModels[2].position.set(1.1, -.15, 0),
            this.currentDisplayedModels[2].scale.set(.85, .85, .85)),
            this.shadowPlane.position.x = -1.1,
            this.shadowClone.position.x = 0,
            this.shadowCloneRing3.position.x = 1.1,
            this.shadowCloneRing3.visible = !0;
            return
        }
        if (e.toLowerCase().includes("memoir")) {
            console.log("raaaaa memoir", this.MemoirRingsins),
            await this.MemoirRingsins.loadMemoirRingById(t.id),
            this.currentDisplayedModels[0].position.set(-1.1, 0, 0),
            this.currentDisplayedModels[1].position.set(0, -.15, 0),
            this.currentDisplayedModels[2] && (this.currentDisplayedModels[2].position.set(1.1, -.15, 0),
            this.currentDisplayedModels[2].scale.set(.85, .85, .85)),
            this.shadowPlane.position.x = -1.1,
            this.shadowClone.position.x = 0,
            this.shadowCloneRing3.position.x = 1.1,
            this.shadowCloneRing3.visible = !0;
            return
        } else {
            if (t && t.id >= 0 && t.id < this.models.length)
                n = this.models[t.id].clone(),
                n.userData.modelId = t.id;
            else if (e === "Wedding")
                n = this.currentDisplayedModels[0].clone();
            else {
                console.warn("Invalid type or selectedRing for third ring");
                return
            }
            console.warn("daasdasdassdInvalid tdasdasdsaype or selectedRing for third ring"),
            this.currentDisplayedModels[0].position.set(-1.1, 0, 0),
            this.currentDisplayedModels[1].position.set(0, -.15, 0),
            n.position.set(1.1, -.15, 0),
            n.scale.set(.85, .85, .85),
            this.shadowPlane.position.x = -1.1,
            this.shadowClone.position.x = 0,
            this.shadowCloneRing3.position.x = 1.1,
            this.shadowCloneRing3.visible = !0,
            this.scene.add(n),
            n.visible = !0,
            this.currentDisplayedModels.push(n)
        }
    }
    async addFourthModel(e, t=null) {
        try {
            if (console.log("Adding fourth model - type:", e, "selectedRing:", t),
            e && e.toLowerCase().includes("engage") || t && t.name && t.name.toLowerCase().includes("engage")) {
                console.log("Adding fourth model as Engagement ring"),
                await this.EngagementRingsins.loadEngRingById(t.id),
                this.currentDisplayedModels[0].position.set(-1.5, 0, 0),
                this.currentDisplayedModels[1].position.set(-.5, -.15, 0),
                this.currentDisplayedModels[2].position.set(.5, -.15, 0),
                this.currentDisplayedModels[3] && (this.currentDisplayedModels[3].position.set(1.5, -.15, 0),
                this.currentDisplayedModels[3].scale.set(.85, .85, .85)),
                this.shadowPlane.position.x = -1.5,
                this.shadowClone.position.x = -.5,
                this.shadowCloneRing3.position.x = .5,
                this.shadowCloneRing3.visible = !0,
                this.shadowCloneRing4.position.x = 1.5,
                this.shadowCloneRing4.visible = !0;
                return
            } else if (e && e.toLowerCase().includes("memoir") || t && t.name && t.name.toLowerCase().includes("memoir")) {
                console.log("Adding fourth model as Memoir ring"),
                await this.MemoirRingsins.loadMemoirRingById(t.id),
                this.currentDisplayedModels[0].position.set(-1.5, 0, 0),
                this.currentDisplayedModels[1].position.set(-.5, -.15, 0),
                this.currentDisplayedModels[2].position.set(.5, -.15, 0),
                this.currentDisplayedModels[3] && (this.currentDisplayedModels[3].position.set(1.5, -.15, 0),
                this.currentDisplayedModels[3].scale.set(.85, .85, .85)),
                this.shadowPlane.position.x = -1.5,
                this.shadowClone.position.x = -.5,
                this.shadowCloneRing3.position.x = .5,
                this.shadowCloneRing3.visible = !0,
                this.shadowCloneRing4.position.x = 1.5,
                this.shadowCloneRing4.visible = !0;
                return
            } else {
                let n;
                if (t && t.id >= 0 && t.id < this.models.length)
                    n = this.models[t.id].clone(),
                    n.userData.modelId = t.id;
                else if (e === "Wedding")
                    n = this.currentDisplayedModels[0].clone();
                else {
                    console.warn("Invalid type or selectedRing for fourth ring");
                    return
                }
                this.currentDisplayedModels[0].position.set(-1.5, 0, 0),
                this.currentDisplayedModels[1].position.set(-.5, -.15, 0),
                this.currentDisplayedModels[2].position.set(.5, -.15, 0),
                n.position.set(1.5, -.15, 0),
                n.scale.set(.85, .85, .85),
                this.shadowPlane.position.x = -1.5,
                this.shadowClone.position.x = -.5,
                this.shadowCloneRing3.position.x = .5,
                this.shadowCloneRing3.visible = !0,
                this.shadowCloneRing4.position.x = 1.5,
                this.shadowCloneRing4.visible = !0,
                this.scene.add(n),
                n.visible = !0,
                this.currentDisplayedModels.push(n)
            }
        } catch (n) {
            console.error("Error adding fourth model:", n)
        }
    }
    removeThirdModel() {
        if (this.currentDisplayedModels.length < 3) {
            console.warn("No third model to remove");
            return
        }
        const e = this.currentDisplayedModels.pop();
        this.scene.remove(e),
        this.currentDisplayedModels[0].position.set(-.7, 0, 0),
        this.currentDisplayedModels[1].position.set(.7, -.15, 0),
        this.currentDisplayedModels[1].scale.set(.85, .85, .85),
        this.shadowPlane && (this.shadowPlane.position.x = -.7),
        this.shadowClone && (this.shadowClone.position.x = .7,
        this.shadowClone.visible = !0),
        this.shadowCloneRing3 && (this.shadowCloneRing3.visible = !1)
    }
    setCurrentModelName(e) {
        this.currentModel = e,
        console.log("current model name", e)
    }
    removeFourthModel() {
        if (this.currentDisplayedModels.length < 4) {
            console.warn("No fourth model to remove");
            return
        }
        const e = this.currentDisplayedModels.pop();
        this.scene.remove(e),
        this.currentDisplayedModels[0].position.set(-1.1, 0, 0),
        this.currentDisplayedModels[1].position.set(0, -.15, 0),
        this.currentDisplayedModels[2].position.set(1.1, -.15, 0),
        this.currentDisplayedModels[1].scale.set(.85, .85, .85),
        this.currentDisplayedModels[2].scale.set(.85, .85, .85),
        this.shadowPlane && (this.shadowPlane.position.x = -1.1),
        this.shadowClone && (this.shadowClone.position.x = 0,
        this.shadowClone.visible = !0),
        this.shadowCloneRing3 && (this.shadowCloneRing3.position.x = 1.1,
        this.shadowCloneRing3.visible = !0),
        this.shadowCloneRing4 && (this.shadowCloneRing4.visible = !1),
        console.log("removeFourth", this.currentDisplayedModels, this.models)
    }
    removeSecondModel() {
        if (this.pair1 = !1,
        this.PreciousMetal.removeHelperModelAndClipping(1),
        this.PreciousMetal.removeHelperModelAndClipping(2),
        this.PreciousMetal.removeClippingTriOneRing(),
        this.PreciousMetal.isEnable = !1,
        window.parent.postMessage({
            action: "removeSecondModel",
            payload: {
                pair1: this.pair1
            }
        }, "*"),
        this.currentDisplayedModels.length < 2) {
            console.warn("No second model to remove");
            return
        }
        const e = this.currentDisplayedModels[1];
        this.scene.remove(e),
        this.currentDisplayedModels.splice(1, 1),
        this.currentDisplayedModels[0].position.set(0, 0, 0),
        this.shadowPlane && (this.shadowPlane.position.x = 0),
        this.shadowClone && (this.shadowClone.visible = !1)
    }
    applyColorToModel(e, t) {
        e.traverse(n => {
            if (n.isMesh) {
                const i = n.material;
                i && i.color && (i.color.set(t),
                i.needsUpdate = !0)
            }
        }
        ),
        console.log(`Color ${t} applied to the model.`)
    }
    changeModelColor(e, t=!1) {
        console.log("colorvalue", e);
        const n = a => ({
            "#A09F9D": 2,
            "#E9D4A4": 2.14,
            "#D99058": 1.8,
            "#B76E79": 1.2,
            "#C2412D": 1
        })[a.toUpperCase()] || 2;
        this.currentColor = e;
        const i = (a, l) => {
            a.traverse(c => {
                c.isMesh && (c.material.color = new be(e),
                c.material.needsUpdate = !0)
            }
            )
        }
          , r = n(e)
          , o = this.currentDisplayedModels[this.selectedModel - 1];
        if (!o) {
            console.warn("Model not found for selectedRingId:", this.selectedModel);
            return
        }
        if (i(o),
        console.log(`Color changed for ring ${this.selectedModel} to: ${e} with intensity ${r}`),
        this.pair1 && this.currentDisplayedModels.length > 1) {
            const a = this.currentDisplayedModels[0]
              , l = this.currentDisplayedModels[1];
            i(a),
            i(l),
            console.log(`Color changed for pair1 (ring 1 and ring 2) to: ${e} with intensity ${r}`)
        }
        if (this.pair2 && this.currentDisplayedModels.length > 3) {
            const a = this.currentDisplayedModels[2]
              , l = this.currentDisplayedModels[3];
            i(a),
            i(l),
            console.log(`Color changed for pair2 (ring 3 and ring 4) to: ${e} with intensity ${r}`)
        }
    }
    engraveTextOnModel(e, t={}) {
        console.log("Engraving..."),
        this.engravingText = e,
        this.pair1 && (this.engravingTextPair1 = e),
        this.pair2 && (this.engravingTextPair2 = e),
        !this.pair1 && this.selectedModel == 1 && (this.engravingTextRing1 = e),
        !this.pair1 && this.selectedModel == 2 && (this.engravingTextRing2 = e);
        const n = {
            1: {
                size: .45,
                height: .05,
                depthOffset: .34,
                color: this.currentColor,
                position: {
                    x: 0,
                    y: -.5,
                    z: -.6
                },
                rotation: {
                    x: -.5,
                    y: 0,
                    z: 1.55
                }
            },
            2: {
                size: .45,
                height: .05,
                depthOffset: .34,
                color: this.currentColor,
                position: {
                    x: 0,
                    y: -.5,
                    z: -.6
                },
                rotation: {
                    x: -.5,
                    y: 0,
                    z: 1.55
                }
            },
            3: {
                size: .45,
                height: .05,
                depthOffset: .34,
                color: this.currentColor,
                position: {
                    x: 0,
                    y: -.5,
                    z: -.6
                },
                rotation: {
                    x: -.5,
                    y: 0,
                    z: 1.55
                }
            },
            4: {
                size: .45,
                height: .05,
                depthOffset: .34,
                color: this.currentColor,
                position: {
                    x: 0,
                    y: -.5,
                    z: -.6
                },
                rotation: {
                    x: -.5,
                    y: 0,
                    z: 1.55
                }
            }
        }
          , i = n[this.fontIndex] || n[1]
          , {size: r=i.size, height: o=i.height, depthOffset: a=i.depthOffset, color: l=i.color, position: c=i.position, rotation: h=i.rotation} = t;
        this.fontLoader.load(this.currentFont, d => {
            const u = f => {
                const g = new ac(e,{
                    font: d,
                    size: r,
                    height: o
                });
                g.computeBoundingBox(),
                g.center();
                const M = new d_;
                console.log("model", f),
                f.userData.modelIndex == 0 ? M.bend(g, "y", Math.PI / 10.7) : f.userData.modelIndex == 1 || f.userData.modelIndex == 2 || f.userData.modelIndex == 3 ? M.bend(g, "y", Math.PI / 10.75) : f.userData.modelIndex == 4 ? M.bend(g, "y", Math.PI / 11.5) : f.userData.modelIndex == 5 ? M.bend(g, "y", Math.PI / 11) : f.userData.modelIndex == 6 ? M.bend(g, "y", Math.PI / 10.8) : f.userData.modelIndex == 7 || f.userData.modelIndex == 8 || f.userData.modelIndex == 9 || f.userData.modelIndex == 10 || f.userData.modelIndex == 11 ? M.bend(g, "y", Math.PI / 11) : f.userData.modelIndex == 12 ? M.bend(g, "y", Math.PI / 10.75) : f.userData.modelIndex == 13 ? M.bend(g, "y", Math.PI / 10.65) : f.userData.modelIndex == 14 ? M.bend(g, "y", Math.PI / 10.8) : M.bend(g, "y", Math.PI / 10.75);
                const m = new En({
                    color: l,
                    metalness: .5,
                    roughness: .7,
                    transparent: !0,
                    opacity: .4,
                    depthWrite: !1,
                    side: Jt
                })
                  , p = new ct(g,m);
                p.name = "engravingText",
                p.position.set(c.x, c.y, c.z - a),
                p.rotation.set(h.x, h.y, h.z),
                p.scale.set(.3, .3, .3);
                const E = g.clone()
                  , _ = new En({
                    color: new be(l).multiplyScalar(.3),
                    metalness: .5,
                    roughness: .7,
                    depthWrite: !0,
                    side: Jt
                })
                  , v = new ct(E,_);
                v.position.copy(p.position),
                f.userData.modelIndex == 0 ? (console.log("model 1"),
                v.position.z += .0585,
                v.position.y += .0193) : f.userData.modelIndex == 1 ? (console.log("model 2", f.userData.modelIndex),
                v.position.z += .058,
                v.position.y += .019) : f.userData.modelIndex == 2 ? (console.log("model 3"),
                v.position.z += .0385,
                v.position.y += .0098) : f.userData.modelIndex == 3 ? (console.log("model 4"),
                v.position.z += .03,
                v.position.y += .005) : f.userData.modelIndex == 4 ? (v.position.z += .033,
                v.position.y += .005) : f.userData.modelIndex == 5 ? (v.position.z += .025,
                v.position.y += .005) : f.userData.modelIndex == 6 ? (v.position.z += .06,
                v.position.y += .02) : f.userData.modelIndex == 7 ? (v.position.z += .025,
                v.position.y += .005) : f.userData.modelIndex == 8 ? v.position.z += .02 : f.userData.modelIndex == 9 ? (v.position.z -= .0037,
                v.position.y -= .004) : f.userData.modelIndex == 10 ? v.position.z += .02 : f.userData.modelIndex == 11 ? (v.position.z += .035,
                v.position.y += .008) : f.userData.modelIndex == 12 ? (v.position.z += .0385,
                v.position.y += .006) : f.userData.modelIndex == 13 ? v.position.z += .018 : (f.userData.modelIndex == 14,
                v.position.z += .06,
                v.position.y += .02),
                v.rotation.copy(p.rotation),
                v.scale.copy(p.scale),
                v.scale.multiplyScalar(1),
                v.name = "test",
                p.name = "test",
                f.add(v),
                f.add(p),
                console.log(`Engraved text "${e}" on the model`, this.currentFont)
            }
            ;
            if (this.pair1 && this.currentDisplayedModels.length > 1) {
                const f = this.currentDisplayedModels[0]
                  , g = this.currentDisplayedModels[1];
                this.engravingText = e,
                f && u(f),
                g && u(g),
                console.log(`Engraved text "${e}" on both pair1 rings.`)
            } else {
                const f = this.currentDisplayedModels[this.selectedModel - 1];
                if (!f) {
                    console.warn("Model not found for selectedRingId:", this.selectedModel);
                    return
                }
                this.engravingText = e,
                u(f),
                console.log(`Engraved text "${e}" on model ${this.selectedModel}`)
            }
        }
        )
    }
    removeEngraving() {
        console.log("Removing engraving...");
        const e = t => {
            const n = [];
            t.traverse(i => {
                i.isMesh && i.name === "test" && n.push(i)
            }
            ),
            n.forEach(i => {
                t.remove(i),
                i.geometry.dispose(),
                i.material.dispose(),
                i.visible = !1
            }
            )
        }
        ;
        if (this.pair1 && this.currentDisplayedModels.length > 1) {
            const t = this.currentDisplayedModels[0]
              , n = this.currentDisplayedModels[1];
            t && e(t),
            n && e(n),
            console.log("Engraving removed from both pair1 rings.")
        } else {
            const t = this.currentDisplayedModels[this.selectedModel - 1];
            if (!t) {
                console.warn("Model not found for selectedRingId:", this.selectedModel);
                return
            }
            e(t),
            console.log(`Engraving removed from model ${this.selectedModel}`)
        }
    }
    changeFont(e) {
        const t = ["./src/assets/fonts/Roboto_Regular.json", "./src/assets/fonts/optimer_regular.typeface.json", "./src/assets/fonts/gentilis.json", "./src/assets/fonts/optimer_regular.typeface.json", "./src/assets/fonts/helvetiker_regular.typeface.json", "./src/assets/fonts/droid_serif_regular.json"];
        if (e === -1)
            return this.currentFont = "./src/assets/fonts/Love_Romance_Regular.json",
            console.log(`Font changed to: ${this.currentFont}`),
            Promise.resolve();
        if (e < 1 || e > t.length)
            return console.warn(`Invalid font index: ${e}. Please choose a number between 1 and ${t.length}.`),
            Promise.reject(new Error("Invalid font index."));
        const n = t[e - 1];
        return this.currentFont = n,
        this.fontIndex = e,
        console.log(`Attempting to load font: ${this.currentFont}`),
        new Promise( (i, r) => {
            fetch(this.currentFont).then(o => {
                if (!o.ok)
                    throw new Error(`Failed to load font: ${this.currentFont}, Status: ${o.status}`);
                return o.json()
            }
            ).then(o => {
                console.log(`Font loaded successfully: ${this.currentFont}`),
                i(o)
            }
            ).catch(o => {
                console.error(`Error loading font: ${this.currentFont}`, o.message),
                r(o)
            }
            )
        }
        )
    }
    fixRenderingOrder() {
        this.scene.traverse(e => {
            e.name && (e.name.includes("diamond") || e.name.includes("diamondHolder")) && (e.renderOrder = 4,
            e.traverse(t => {
                t.isMesh && (t.renderOrder = 4,
                t.material && (t.material.depthWrite = !0,
                t.material.depthTest = !0,
                t.material.transparent = !1,
                t.material.polygonOffset = !1,
                t.material.needsUpdate = !0))
            }
            )),
            (e.userData === "midMeshRing1" || e.userData === "midMeshRing2") && (e.renderOrder = 1,
            e.traverse(t => {
                t.isMesh && (t.renderOrder = 1)
            }
            ))
        }
        ),
        this.renderer && (this.renderer.clearDepth(),
        this.renderer.render(this.scene, this.camera))
    }
}
class f_ {
    constructor(e, t) {
        this.pMetalManager = t,
        this.modelManager = e,
        window.addEventListener("message", this.handleMessage.bind(this))
    }
    handleMessage(e) {
        const {action: t, modelId: n, type: i, id: r, selectedRing: o, value: a, pair: l, isEngraving: c, isBiCol: h, isTriCol: d, isMetal: u, field: f, grooveId: g, stoneDist: M, position: m, ringIdentifier: p} = e.data;
        switch (t) {
        case "changeModel":
            this.changeModel(n, o.id, l.pair1, l.pair2);
            break;
        case "addRing":
            this.addRing(i, o);
            break;
        case "removeRing":
            this.removeRing();
            break;
        case "selectModel":
            this.currentSelectedRing(n);
            break;
        case "addStone":
            i == "Number" && (console.log("add stone aa", a, M),
            this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.addDiamondsToRingFront({
                diamondCount: a,
                ringIndex: this.modelManager.selectedModel,
                distribution: M
            })),
            a == "Smooth conversion" && (this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel
            }, a),
            console.log("smooth conversion", this.modelManager.selectedModel),
            this.modelManager.fixRenderingOrder()),
            a == "Pav" && (this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel,
                modelUrl: "diamondm/circle.glb"
            }, a)),
            a == "Rail setting" && (console.log("rail setting", this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel,
                modelUrl: "diamondm/rect.glb"
            }, a)),
            a == "Smooth Stone" && (this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel,
                modelUrl: "diamondm/d3.glb"
            }, a)),
            a == "Rail setting Across" && (console.log("rail setting across", this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel,
                modelUrl: "diamondm/engStone.glb"
            }, a)),
            a == "Smooth setting Across" && (console.log("Smooth setting Across", this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.loadDiamondToRing({
                ringIndex: this.modelManager.selectedModel,
                modelUrl: "diamondm/oval.glb"
            }, a)),
            a == "Without" && (console.log("remove diamond", this.modelManager.selectedModel),
            this.modelManager.StoneManagerIns.removeDiamondsFromRing(this.modelManager.selectedModel));
            break;
        case "stoneSize":
            this.modelManager.StoneManagerIns.changeStoneSize(a);
            break;
        case "stonePosition":
            typeof a == "string" || a instanceof String ? this.modelManager.StoneManagerIns.changeStonePosition(a) : this.modelManager.StoneManagerIns.handleStonePositionSlider(a);
            break;
        case "updatePairStatus":
            console.log("ipair", a),
            this.modelManager.currentPairUpdate(a);
            break;
        case "changeWidth":
            console.log("changeWidth action received:", a, o.id),
            this.modelManager.changeRingWidth(o.id, a);
            break;
        case "changeHeight":
            console.log("Height action received:", a, o.id),
            this.modelManager.changeRingThickness(o.id, a);
            break;
        case "optimalHeight":
            this.modelManager.optimalThicknessBool(a);
        case "countrySize":
            this.modelManager.setSizeCountryWise(a);
            break;
        case "changeColor":
            if (h == null && d == null) {
                this.modelManager.changeModelColor(a.colorCode),
                console.log("value", a.colorCode, a.value);
                return
            }
            if (h && h.name === "Two tone")
                f === "single" || f === "triColored1" ? this.pMetalManager.colorChangeBi(a.colorCode, 1) : f === "twoTone" || f === "triColored2" ? this.pMetalManager.colorChangeBi(a.colorCode, 2) : (f === "triColored" || f === "triColored3") && this.pMetalManager.colorChangeBi(a.colorCode, 3);
            else if (h && h.name === "Tri Colored")
                f === "single" || f === "triColored1" ? this.pMetalManager.colorChangeBi(a.colorCode, 1) : f === "twoTone" || f === "triColored3" ? this.pMetalManager.colorChangeBi(a.colorCode, 3) : (f === "triColored" || f === "triColored2") && this.pMetalManager.colorChangeBi(a.colorCode, 2);
            else if (m) {
                const L = parseInt(m);
                !isNaN(L) && L >= 1 && L <= 3 && this.pMetalManager.colorChangeBi(a.colorCode, L)
            }
            break;
        case "EngraveSymbol":
            console.log("hello", a),
            this.modelManager.removeEngraving(),
            this.modelManager.changeFont(-1),
            a.value == "double-heart" ? this.modelManager.engraveTextOnModel("GG") : a.value == "heart" ? this.modelManager.engraveTextOnModel("G") : a.value == "double-ring" ? this.modelManager.engraveTextOnModel("MGN") : a.value == "infinity" && this.modelManager.engraveTextOnModel("gSg"),
            this.modelManager.changeFont(1);
            break;
        case "EngraveText":
            console.log("hello frm text", c),
            this.modelManager.removeEngraving(),
            this.modelManager.engraveTextOnModel(c);
            break;
        case "addGroove":
            if (console.log("calss groove", i, a, o),
            i == "defaultAdd") {
                this.modelManager.GrooveManagerIns.addGroove(o);
                break
            }
            if (i == "defaultDelete") {
                this.modelManager.GrooveManagerIns.removeGroove(o);
                break
            }
            if (i == "Without") {
                this.modelManager.GrooveManagerIns.removeMidMeshes(),
                this.modelManager.GrooveBool = !1;
                break
            }
            if (i == "width" || i == "depth") {
                this.modelManager.GrooveManagerIns.adjustWidthAndDepth(o, a, i);
                break
            } else
                this.modelManager.loadMidMesh(i, !1);
            break;
        case "addStep":
            if (console.log("calss groove step", a, i),
            a == "left")
                if (i == "Without") {
                    this.modelManager.StepsManagerIns.removeLeftSteps();
                    break
                } else
                    i == "Milgrain" ? this.modelManager.StepsManagerIns.addLeftStep(!0) : this.modelManager.StepsManagerIns.addLeftStep(!1);
            if (a == "right")
                if (i == "Without") {
                    this.modelManager.StepsManagerIns.removeRightSteps();
                    break
                } else
                    i == "Milgrain" ? this.modelManager.StepsManagerIns.addRightStep(!0) : this.modelManager.StepsManagerIns.addRightStep(!1);
            break;
        case "changeGrooveSlider":
            console.log("calss groove f", a, o, g),
            i == "initial" || this.modelManager.GrooveManagerIns.setoffsetValueGroove(a, o);
            break;
        case "changeSlider":
            console.log("calss", a, o),
            this.pMetalManager.setoffsetValue(a, o);
            break;
        case "changeMultiSlider":
            console.log("calss tri", a, this.pMetalManager.isEnable, o),
            this.pMetalManager.setoffsetValueTri(a.left, a.right, o);
            break;
        case "PreciousMetal":
            console.log("PreciousMetal change", a, h, d, p);
            let E = this.modelManager.currentDisplayedModels.length;
            if (a === 0) {
                this.pMetalManager.removeHelperModelAndClipping(1),
                this.pMetalManager.removeHelperModelAndClipping(2),
                this.pMetalManager.removeClippingTriOneRing(),
                this.modelManager.GrooveManagerIns.removeMidMeshes(),
                this.pMetalManager.isEnable = !1;
                return
            }
            const _ = h === !0 || h && h.name === "Two tone"
              , v = !_ && (d === !0 || h && h.name === "Tri Colored");
            E === 1 && _ ? this.pMetalManager.biColorOneRing(a) : E === 1 && v ? this.pMetalManager.triColorOneRing(a) : E === 1 ? this.pMetalManager.triColorOneRing(a) : E === 2 && _ ? this.pMetalManager.biTriPair(a) : E === 2 && this.pMetalManager.biTriPair(a, !0);
            break;
        case "FontChange":
            this.modelManager.removeEngraving(),
            a == "svnfont00" ? (this.modelManager.changeFont(1),
            this.modelManager.engraveTextOnModel(this.modelManager.engravingTextPair1)) : a == "svnfont01" ? (this.modelManager.changeFont(2),
            this.modelManager.engraveTextOnModel(this.modelManager.engravingTextPair1)) : a == "svnfont02" ? (this.modelManager.changeFont(5),
            this.modelManager.engraveTextOnModel(this.modelManager.engravingTextPair1)) : a == "svnfont03" ? (this.modelManager.changeFont(4),
            this.modelManager.engraveTextOnModel(this.modelManager.engravingTextPair1)) : a == "svnfont04" ? (this.modelManager.changeFont(5),
            this.modelManager.engraveTextOnModel(this.modelManager.engravingTextPair1)) : console.log("unknown font value", a);
            break;
        default:
            console.warn("Unknown action:", t);
            break
        }
    }
    changeModel(e, t, n, i) {
        if (!e) {
            console.warn("No model ID provided");
            return
        }
        this.iframeMsgToSwitchModel(e, t, n, i)
    }
    async addRing(e, t) {
        console.log("Adding ring - type:", e, "selectedRing:", t);
        try {
            this.modelManager.currentDisplayedModels.length === 1 ? t && t.name && t.name.toLowerCase().includes("engage") ? await this.modelManager.addSecondModel("engagement", t) : t && t.name && t.name.toLowerCase().includes("memoir") ? await this.modelManager.addSecondModel("memoir", t) : e ? await this.modelManager.addSecondModel(e, t) : t && await this.modelManager.addSecondModel(null, t) : this.modelManager.currentDisplayedModels.length === 2 ? t && t.name && t.name.toLowerCase().includes("engage") ? await this.modelManager.addThirdModel("engagement", t) : t && t.name && t.name.toLowerCase().includes("memoir") ? await this.modelManager.addThirdModel("memoir", t) : e ? await this.modelManager.addThirdModel(e, t) : t && await this.modelManager.addThirdModel(null, t) : this.modelManager.currentDisplayedModels.length === 3 ? t && t.name && t.name.toLowerCase().includes("engage") ? await this.modelManager.addFourthModel("engagement", t) : t && t.name && t.name.toLowerCase().includes("memoir") ? await this.modelManager.addFourthModel("memoir", t) : e ? await this.modelManager.addFourthModel(e, t) : t && await this.modelManager.addFourthModel(null, t) : console.warn("Cannot add a ring at this stage")
        } catch (n) {
            console.error("Error adding ring:", n)
        }
    }
    removeRing() {
        this.modelManager.currentDisplayedModels.length === 2 ? this.modelManager.removeSecondModel() : this.modelManager.currentDisplayedModels.length === 3 ? this.modelManager.removeThirdModel() : this.modelManager.currentDisplayedModels.length === 4 ? this.modelManager.removeFourthModel() : console.warn("No ring to remove or invalid ID")
    }
    currentSelectedRing(e) {
        this.modelManager.currentSelectedRing(e)
    }
    iframeMsgToSwitchModel(e, t, n=!1, i=!1) {
        switch (this.modelManager.modelId = e,
        e) {
        case "P1":
            this.modelManager.switchModel(0, t, n, i);
            break;
        case "P2":
            this.modelManager.switchModel(1, t, n, i);
            break;
        case "P3":
            this.modelManager.switchModel(2, t, n, i);
            break;
        case "P4":
            this.modelManager.switchModel(3, t, n, i);
            break;
        case "P5":
            this.modelManager.switchModel(4, t, n, i);
            break;
        case "P6":
            this.modelManager.switchModel(5, t, n, i);
            break;
        case "P7":
            this.modelManager.switchModel(6, t, n, i);
            break;
        case "P8":
            this.modelManager.switchModel(7, t, n, i);
            break;
        case "P9":
            this.modelManager.switchModel(8, t, n, i);
            break;
        case "P10":
            this.modelManager.switchModel(9, t, n, i);
            break;
        case "P11":
            this.modelManager.switchModel(10, t, n, i);
            break;
        case "P12":
            this.modelManager.switchModel(11, t, n, i);
            break;
        case "P13":
            this.modelManager.switchModel(12, t, n, i);
            break;
        case "P14":
            this.modelManager.switchModel(13, t, n, i);
            break;
        case "P15":
            this.modelManager.switchModel(14, t, n, i);
            break;
        default:
            console.warn("Unknown model identifier:", e);
            break
        }
        this.modelManager.setCurrentModelName(e),
        this.modelManager.GrooveBool == !0
    }
}
class p_ {
    constructor(e, t, n) {
        this.scene = e,
        this.pMetalMain = t,
        this.modelManager = n
    }
    biColorSegmentOnering() {
        if (this.modelManager.currentDisplayedModels.length === 1) {
            const e = this.modelManager.currentDisplayedModels[this.modelManager.selectedModel - 1];
            this.pMetalMain.helperModel = this.pMetalMain.cloneModelWithUniqueMaterial(e),
            this.scene.add(this.pMetalMain.helperModel),
            this.pMetalMain.applyColorToModel(this.pMetalMain.helperModel, "#A09F9D"),
            this.pMetalMain.clippingPlaneRingSingleBi = new We(new C(0,-1,.3),0),
            this.pMetalMain.clippingPlaneRingHelperBi = new We(new C(0,1,-.3),0),
            e.traverse(t => {
                t.isMesh && (t.material.clippingPlanes = [this.pMetalMain.clippingPlaneRingSingleBi],
                t.material.clipShadows = !0,
                t.material.needsUpdate = !0)
            }
            ),
            this.pMetalMain.helperModel.traverse(t => {
                t.isMesh && (t.material.clippingPlanes = [this.pMetalMain.clippingPlaneRingHelperBi],
                t.material.clipShadows = !0,
                t.material.needsUpdate = !0)
            }
            ),
            this.pMetalMain.biColorSingleBool = !0,
            console.log("Clipping plane applied to the selected model and helper model.")
        }
    }
    biColorSegment() {
        this.modelManager.GrooveManagerIns.removeMidMeshes(),
        this.modelManager.selectedModel == 1 && this.modelManager.pair1 == !1 && this.biColorSegmentRing1(),
        this.modelManager.selectedModel == 2 && this.modelManager.pair1 == !1 && this.biColorSegmentRing2(),
        this.modelManager.pair1 && (this.biColorSegmentRing1(),
        this.biColorSegmentRing2())
    }
    biColorSegmentRing1() {
        const e = this.modelManager.currentDisplayedModels[this.modelManager.selectedModel - 1];
        if (e) {
            this.pMetalMain.removeHelperModelAndClipping(1);
            let t = -.7
              , n = 0;
            this.pMetalMain.helperModel = this.pMetalMain.cloneModelWithUniqueMaterial(e),
            this.pMetalMain.helperModel.position.set(t, n, 0),
            this.scene.add(this.pMetalMain.helperModel),
            this.pMetalMain.applyColorToModel(this.pMetalMain.helperModel, "#A09F9D"),
            this.pMetalMain.clippingPlaneRing1 = new We(new C(0,-1,.3),0),
            this.pMetalMain.clippingPlaneRing1helper = new We(new C(0,1,-.3),0),
            e.traverse(i => {
                i.isMesh && (i.material.clippingPlanes = [this.pMetalMain.clippingPlaneRing1],
                i.material.clipShadows = !0,
                i.material.needsUpdate = !0)
            }
            ),
            this.pMetalMain.helperModel.traverse(i => {
                i.isMesh && (i.material.clippingPlanes = [this.pMetalMain.clippingPlaneRing1helper],
                i.material.clipShadows = !0,
                i.material.needsUpdate = !0)
            }
            )
        }
    }
    biColorSegmentRing2() {
        const e = this.modelManager.currentDisplayedModels[1];
        if (e) {
            this.pMetalMain.removeHelperModelAndClipping(2);
            let t = .7
              , n = -.15;
            this.pMetalMain.helperModelring2 = this.pMetalMain.cloneModelWithUniqueMaterial(e),
            this.pMetalMain.helperModelring2.position.set(t, n, 0),
            this.scene.add(this.pMetalMain.helperModelring2),
            this.pMetalMain.applyColorToModel(this.pMetalMain.helperModelring2, "#A09F9D"),
            this.pMetalMain.clippingPlaneRing2 = new We(new C(0,-1,.3),.1),
            this.pMetalMain.clippingPlaneRing2helper = new We(new C(0,1,-.3),.1),
            e.traverse(i => {
                i.isMesh && (i.material.clippingPlanes = [this.pMetalMain.clippingPlaneRing2],
                i.material.clipShadows = !0,
                i.material.needsUpdate = !0)
            }
            ),
            this.pMetalMain.helperModelring2.traverse(i => {
                i.isMesh && (i.material.clippingPlanes = [this.pMetalMain.clippingPlaneRing2helper],
                i.material.clipShadows = !0,
                i.material.needsUpdate = !0)
            }
            )
        }
    }
    setoffsetValueGroove(e, t) {
        if (this.modelManager.selectedModel == 1 && !this.modelManager.pair1) {
            if (t == !0) {
                e == "1:1:1" || (e === "1:2:1" ? (this.modelManager.midMesh.position.x = -.63,
                this.modelManager.midMeshTri.position.x = -.78,
                this.modelManager.midMesh2.position.x = .63,
                this.modelManager.midMeshTri2.position.x = .78) : e === "1:3:1" ? (this.modelManager.midMesh.position.x = -.6,
                this.modelManager.midMeshTri.position.x = -.8,
                this.modelManager.midMesh2.position.x = .6,
                this.modelManager.midMeshTri2.position.x = .8) : e === "1:4:1" ? (this.modelManager.midMesh.position.x = -.57,
                this.modelManager.midMeshTri.position.x = -.83,
                this.modelManager.midMesh2.position.x = .57,
                this.modelManager.midMeshTri2.position.x = .83) : e === "2:1:2" ? (this.modelManager.midMesh.position.x = -.657,
                this.modelManager.midMeshTri.position.x = -.737,
                this.modelManager.midMesh2.position.x = .657,
                this.modelManager.midMeshTri2.position.x = .737) : e === "3:1:1" ? (this.modelManager.midMesh.position.x = -.575,
                this.modelManager.midMeshTri.position.x = -.665,
                this.modelManager.midMesh2.position.x = .715,
                this.modelManager.midMeshTri2.position.x = .8) : e === "2:1:1" && (this.modelManager.midMesh.position.x = -.56,
                this.modelManager.midMeshTri.position.x = -.665,
                this.modelManager.midMesh2.position.x = .715,
                this.modelManager.midMeshTri2.position.x = .81));
                return
            }
            e === "1:1" || (e === "1:2" ? this.modelManager.midMesh.position.x -= .05 : e === "1:3" ? this.modelManager.midMesh.position.x -= .07 : e === "1:4" && (this.modelManager.midMesh.position.x -= .09))
        }
        if (this.modelManager.selectedModel == 2 && !this.modelManager.pair1)
            e === "1:1" || (e === "1:2" ? this.modelManager.midMesh2.position.x -= .1 : e === "1:3" ? this.modelManager.midMesh2.position.x -= .7 : e === "1:4" && (this.modelManager.midMesh2.position.x -= .09));
        else if (this.modelManager.pair1) {
            if (t == !0) {
                e == "1:1:1" || (e === "1:2:1" ? (this.modelManager.midMesh.position.x = -.63,
                this.modelManager.midMeshTri.position.x = -.78,
                this.modelManager.midMesh2.position.x = .63,
                this.modelManager.midMeshTri2.position.x = .78) : e === "1:3:1" ? (this.modelManager.midMesh.position.x = -.6,
                this.modelManager.midMeshTri.position.x = -.8,
                this.modelManager.midMesh2.position.x = .6,
                this.modelManager.midMeshTri2.position.x = .8) : e === "1:4:1" ? (this.modelManager.midMesh.position.x = -.57,
                this.modelManager.midMeshTri.position.x = -.83,
                this.modelManager.midMesh2.position.x = .57,
                this.modelManager.midMeshTri2.position.x = .83) : e === "2:1:2" ? (this.modelManager.midMesh.position.x = -.657,
                this.modelManager.midMeshTri.position.x = -.737,
                this.modelManager.midMesh2.position.x = .657,
                this.modelManager.midMeshTri2.position.x = .737) : e === "3:1:1" ? (this.modelManager.midMesh.position.x = -.575,
                this.modelManager.midMeshTri.position.x = -.665,
                this.modelManager.midMesh2.position.x = .715,
                this.modelManager.midMeshTri2.position.x = .8) : e === "2:1:1" && (this.modelManager.midMesh.position.x = -.56,
                this.modelManager.midMeshTri.position.x = -.665,
                this.modelManager.midMesh2.position.x = .715,
                this.modelManager.midMeshTri2.position.x = .81));
                return
            }
            e === "1:1" || (e === "1:2" ? (this.modelManager.midMesh.position.x -= .05,
            this.modelManager.midMesh2.position.x -= .05) : e === "1:3" ? (this.modelManager.midMesh.position.x -= .07,
            this.modelManager.midMesh2.position.x -= .07) : e === "1:4" && (this.modelManager.midMesh.position.x -= .09,
            this.modelManager.midMesh2.position.x -= .09))
        }
    }
}
class Ca {
    constructor(e) {
        this.renderer = e,
        this.envMap = null,
        this.envMapPMREM = null,
        this.pmremGenerator = null,
        this.textureLoader = new Ea,
        this.initializeCubemap()
    }
    initializeCubemap() {
        const e = new zM;
        this.envMap = e.load(["diamondMap/2r.jpg", "diamondMap/1r.jpg", "diamondMap/2r.jpg", "diamondMap/2r.jpg", "diamondMap/1r.jpg", "diamondMap/1r.jpg"], () => {
            console.log("Cubemap textures loaded successfully"),
            this.pmremGenerator = new ms(this.renderer),
            this.pmremGenerator.compileEquirectangularShader(),
            this.envMapPMREM = this.pmremGenerator.fromCubemap(this.envMap).texture,
            console.log("Diamond cubemap initialized and converted to PMREM")
        }
        , t => {
            console.log("Cubemap loading progress:", t)
        }
        , t => {
            console.error("Error loading cubemap textures:", t),
            console.error("Make sure diamondMap/2r.jpg and diamondMap/1r.jpg exist in your public folder")
        }
        ),
        this.envMapBigDiamond = e.load(["diamondMap/2rb.jpg", "diamondMap/1rb.jpg", "diamondMap/2rb.jpg", "diamondMap/2rb.jpg", "diamondMap/1rb.jpg", "diamondMap/1r.jpg"], t => {
            t.encoding = void 0,
            this.pmremGenerator ? this.envMapPMREMbigDiamond = this.pmremGenerator.fromCubemap(t).texture : (this.pmremGenerator = new ms(this.renderer),
            this.pmremGenerator.compileEquirectangularShader(),
            this.envMapPMREMbigDiamond = this.pmremGenerator.fromCubemap(t).texture),
            console.log("Big diamond cubemap initialized and converted to PMREM")
        }
        , t => {
            console.log("Big diamond cubemap loading progress:", t)
        }
        , t => {
            console.error("Error loading big diamond cubemap textures:", t)
        }
        )
    }
    createDiamondMaterial(e=new be(16777215)) {
        console.log("createDiamondMaterial");
        const t = new Wt({
            color: new be(16777215),
            metalness: .55,
            roughness: 0,
            envMapIntensity: 2,
            transmission: 1,
            ior: 2.4,
            reflectivity: 1.2,
            clearcoat: 1,
            clearcoatRoughness: 0,
            thickness: 4,
            transparent: !0,
            opacity: .9,
            depthWrite: !0,
            depthTest: !0,
            polygonOffset: !1,
            specularIntensity: 1,
            specularColor: new be(1,1,1),
            side: Bt
        });
        if (this.envMapPMREM)
            t.envMap = this.envMapPMREM;
        else {
            const n = () => {
                this.envMapPMREM ? (t.envMap = this.envMapPMREM,
                t.needsUpdate = !0) : setTimeout(n, 100)
            }
            ;
            n()
        }
        return t.stencilWrite = !0,
        t.stencilRef = 2,
        t.stencilFunc = ii,
        t.stencilZPass = fs,
        t
    }
    createDiamondMaterialBigDiamond(e=new be(16777215)) {
        console.log("createDiamondMaterialBigDiamond");
        const t = new Wt({
            color: new be(16777215),
            metalness: .6,
            roughness: 0,
            envMapIntensity: 1.5,
            transmission: 1,
            ior: 1.2,
            reflectivity: 1.2,
            clearcoat: 1,
            clearcoatRoughness: 0,
            thickness: 2,
            transparent: !0,
            opacity: .9,
            depthWrite: !0,
            depthTest: !0,
            polygonOffset: !1,
            specularIntensity: 1,
            specularColor: new be(1,1,1),
            side: Bt
        });
        if (this.envMapPMREMbigDiamond)
            t.envMap = this.envMapPMREMbigDiamond;
        else {
            const n = () => {
                this.envMapPMREMbigDiamond ? (t.envMap = this.envMapPMREMbigDiamond,
                t.needsUpdate = !0) : setTimeout(n, 100)
            }
            ;
            n()
        }
        return t.stencilWrite = !0,
        t.stencilRef = 2,
        t.stencilFunc = ii,
        t.stencilZPass = fs,
        t
    }
    applyDiamondTextures(e, t, n) {}
    dispose() {
        this.pmremGenerator && this.pmremGenerator.dispose(),
        this.envMapPMREM && this.envMapPMREM.dispose(),
        this.envMap && this.envMap.dispose(),
        this.envMapPMREMbigDiamond && this.envMapPMREMbigDiamond.dispose(),
        this.envMapBigDiamond && this.envMapBigDiamond.dispose()
    }
}
class m_ {
    constructor(e, t, n) {
        this.scene = e,
        this.modelManager = t,
        this.renderer = n,
        this.ringPath = null,
        this.diamondMaterialManager = new Ca(n),
        this.modelData = [{
            glbPath: "models/eng/VR001.glb",
            texturePath: "path/to/texture2.jpg"
        }, {
            glbPath: "models/eng/VR001S-BD.glb",
            texturePath: "path/to/texture3.jpg"
        }, {
            glbPath: "models/eng/VR002.glb",
            texturePath: "path/to/texture1.jpg"
        }, {
            glbPath: "models/eng/VR002S-BD.glb"
        }, {
            glbPath: "models/eng/VR003.glb"
        }, {
            glbPath: "models/eng/VR003S-BD.glb"
        }, {
            glbPath: "models/eng/VR003S-BD.glb"
        }, {
            glbPath: "models/eng/VR004.glb"
        }, {
            glbPath: "models/eng/VR005.glb"
        }, {
            glbPath: "models/eng/VR005S-BD.glb"
        }, {
            glbPath: "models/eng/VR006.glb"
        }, {
            glbPath: "models/eng/VR006S-BD.glb"
        }, {
            glbPath: "models/eng/VR007.glb"
        }, {
            glbPath: "models/eng/VR008.glb"
        }, {
            glbPath: "models/eng/VR009.glb"
        }, {
            glbPath: "models/eng/VR010.glb"
        }, {
            glbPath: "models/eng/VR011.glb"
        }, {
            glbPath: "models/eng/VR101.glb"
        }, {
            glbPath: "models/eng/VR102.glb"
        }, {
            glbPath: "models/eng/VR103.glb"
        }, {
            glbPath: "models/eng/VR104.glb"
        }, {
            glbPath: "models/eng/VR104S-BD.glb"
        }, {
            glbPath: "models/eng/VR105.glb"
        }, {
            glbPath: "models/eng/VR201.glb"
        }, {
            glbPath: "models/eng/VR202.glb"
        }, {
            glbPath: "models/eng/VR203.glb"
        }, {
            glbPath: "models/eng/VR301.glb"
        }, {
            glbPath: "models/eng/VR302.glb"
        }, {
            glbPath: "models/eng/VR401.glb"
        }, {
            glbPath: "models/eng/VR401S-BD.glb"
        }, {
            glbPath: "models/eng/VR402.glb"
        }, {
            glbPath: "models/eng/VR402S-BD.glb"
        }, {
            glbPath: "models/eng/VR403.glb"
        }, {
            glbPath: "models/eng/VR403S-BD.glb"
        }, {
            glbPath: "models/eng/VR404.glb"
        }, {
            glbPath: "models/eng/VR411SC.glb"
        }, {
            glbPath: "models/eng/VR410SC.glb"
        }, {
            glbPath: "models/eng/VR409PL.glb"
        }, {
            glbPath: "models/eng/VR409BD.glb"
        }, {
            glbPath: "models/eng/VR408SC.glb"
        }, {
            glbPath: "models/eng/VR305PL.glb"
        }, {
            glbPath: "models/eng/VR305SC.glb"
        }, {
            glbPath: "models/eng/VR304PL.glb"
        }, {
            glbPath: "models/eng/VR303PL.glb"
        }, {
            glbPath: "models/eng/VR021BD.glb"
        }, {
            glbPath: "models/eng/VR021PL.glb"
        }, {
            glbPath: "models/eng/VR020BD.glb"
        }, {
            glbPath: "models/eng/VR019BD.glb"
        }, {
            glbPath: "models/eng/VR018PS.glb"
        }, {
            glbPath: "models/eng/VR016SH.glb"
        }, {
            glbPath: "models/eng/VR016CH.glb"
        }, {
            glbPath: "models/eng/VR016BD.glb"
        }, {
            glbPath: "models/eng/VR016PL.glb"
        }, {
            glbPath: "models/eng/VR015CH.glb"
        }, {
            glbPath: "models/eng/VR015PL.glb"
        }, {
            glbPath: "models/eng/VR015BD.glb"
        }, {
            glbPath: "models/eng/VR015SC.glb"
        }, {
            glbPath: "models/eng/VR014SC.glb"
        }, {
            glbPath: "models/eng/VR014PL.glb"
        }, {
            glbPath: "models/eng/VR014CH.glb"
        }, {
            glbPath: "models/eng/VR014BD.glb"
        }, {
            glbPath: "models/eng/VR013SC.glb"
        }, {
            glbPath: "models/eng/VR013PL.glb"
        }, {
            glbPath: "models/eng/VR013CH.glb"
        }, {
            glbPath: "models/eng/VR013BD.glb"
        }, {
            glbPath: "models/eng/VR403S-BD.glb"
        }, {
            glbPath: "models/eng/VR402.glb"
        }, {
            glbPath: "models/eng/VR402S-BD.glb"
        }, {
            glbPath: "models/eng/VR401S-BD.glb"
        }, {
            glbPath: "models/eng/VR401.glb"
        }]
    }
    async loadEngRingById(e) {
        try {
            const t = document.querySelector(".loader-overlay");
            if (t && (t.style.display = "block"),
            e < 0 || e >= this.modelData.length)
                throw new Error(`Invalid ID: ${e + 1}. Please provide a valid model ID.`);
            const n = this.modelData[e];
            if (!n.glbPath)
                throw new Error(`Model path not found for ID: ${e}`);
            const i = new wr
              , o = (await new Promise( (a, l) => {
                i.load(n.glbPath, c => a(c), c => console.log(`${c.loaded / c.total * 100}% loaded`), c => l(new Error(`Error loading model: ${n.glbPath} - ${c}`)))
            }
            )).scene;
            return o.position.x = .7,
            o.position.y = -.2,
            o.scale.set(.8, .8, .8),
            this.scene.add(o),
            this.modelManager.currentDisplayedModels.push(o),
            n.glbPath == "models/eng/VR002.glb" || n.glbPath == "models/eng/VR003S-BD.glb",
            this.applyDiamondTextureToRing(o),
            console.log(`Model loaded successfully: ${n.glbPath}`, o, e),
            t && (t.style.display = "none"),
            o
        } catch (t) {
            console.error(t.message);
            const n = document.querySelector(".loader-overlay");
            return n && (n.style.display = "none"),
            null
        }
    }
    applyDiamondTextureToRing(e) {
        const t = {
            map: !1,
            normalMap: !0,
            roughnessMap: !1,
            metalnessMap: !1,
            emissiveMap: !1,
            aoMap: !1,
            envMap: !0,
            displacementMap: !1
        }
          , n = "diamondMap/1b.jpg";
        e.traverse(i => {
            if (console.log("child.name", i.name),
            i.isMesh && i.name.toLowerCase().includes("mond")) {
                console.log(`Applying diamond material to engagement ring mesh: ${i.name}`),
                i.material && (i.material.map && i.material.map.dispose(),
                i.material.normalMap && i.material.normalMap.dispose(),
                i.material.roughnessMap && i.material.roughnessMap.dispose(),
                i.material.metalnessMap && i.material.metalnessMap.dispose(),
                i.material.emissiveMap && i.material.emissiveMap.dispose(),
                i.material.aoMap && i.material.aoMap.dispose(),
                i.material.envMap && i.material.envMap.dispose(),
                i.material.displacementMap && i.material.displacementMap.dispose(),
                i.material.dispose()),
                i.material = this.diamondMaterialManager.createDiamondMaterial(),
                i.renderOrder = 4;
                const r = () => {
                    this.diamondMaterialManager.envMapPMREM && (i.material.envMap = this.diamondMaterialManager.envMapPMREM,
                    i.material.needsUpdate = !0)
                }
                ;
                if (this.diamondMaterialManager.envMapPMREM)
                    r();
                else {
                    const o = () => {
                        this.diamondMaterialManager.envMapPMREM ? r() : setTimeout(o, 100)
                    }
                    ;
                    o()
                }
                this.diamondMaterialManager.applyDiamondTextures(i.material, n, t).then( () => {
                    console.log(`Diamond material applied successfully to: ${i.name}`)
                }
                ).catch(o => {
                    console.warn(`Failed to apply diamond textures to ${i.name}:`, o)
                }
                )
            }
        }
        ),
        console.log("Diamond materials applied successfully to engagement ring model")
    }
    applyColorExcludingMeshes(e, t, n=!1) {
        e.traverse(i => {
            i.isMesh && (n == !0 && i.name.includes("_") && (i.material && i.material.color && i.material.color.set(t),
            console.warn("aaaaaa model engagement rings", i.name)),
            i.name.includes("_1") && !n || i.material && i.material.color && !n && (console.warn("aaaaaa 2"),
            i.material.color.set(t)))
        }
        )
    }
    dispose() {
        this.diamondMaterialManager && this.diamondMaterialManager.dispose()
    }
}
class g_ {
    constructor(e, t) {
        this.scene = e,
        this.midMesh = null,
        this.loader = new wr,
        this.modelManager = t,
        this.grooveCountRing1 = 1,
        this.grooveCountRing2 = 1
    }
    triGroovePair() {
        this.modelManager.midMeshTri = this.modelManager.midMesh.clone(),
        this.modelManager.midMeshTri.position.x = -.7,
        this.modelManager.midMeshTri2 = this.modelManager.midMesh2.clone(),
        this.modelManager.midMeshTri2.position.x = .7,
        this.modelManager.midMesh.position.x = -.65,
        this.modelManager.midMeshTri.position.x = -.75,
        this.modelManager.midMesh2.position.x = .65,
        this.modelManager.midMeshTri2.position.x = .75,
        this.scene.add(this.modelManager.midMeshTri),
        this.scene.add(this.modelManager.midMeshTri2)
    }
    removeMidMeshes() {
        const e = n => {
            if (n)
                return console.log("Removing mesh:", n),
                this.scene.remove(n),
                n.traverse(i => {
                    if (i.isMesh && ((i.name = "") && console.log("name AAAAAAA", i),
                    i.geometry.dispose(),
                    i.material))
                        if (Array.isArray(i.material))
                            i.material.forEach(r => {
                                for (const o in r)
                                    r[o] && r[o].isTexture && r[o].dispose();
                                r.dispose()
                            }
                            );
                        else {
                            for (const r in i.material)
                                i.material[r] && i.material[r].isTexture && i.material[r].dispose();
                            i.material.dispose()
                        }
                }
                ),
                n.visible = !1,
                null
        }
        ;
        this.modelManager.midMesh = e(this.modelManager.midMesh),
        this.modelManager.midMesh2 = e(this.modelManager.midMesh2),
        this.modelManager.midMeshTri = e(this.modelManager.midMeshTri),
        this.modelManager.midMeshTri2 = e(this.modelManager.midMeshTri2);
        let t = [];
        this.scene.traverse(n => {
            (n.userData === "midMeshRing1" || n.userData === "midMeshRing2") && (console.log("Removing from traverse:", n),
            t.push(n),
            n.name == "" && (console.log("name", n),
            t.push(n)))
        }
        ),
        t.forEach(n => {
            n.parent ? n.parent.remove(n) : this.scene.remove(n)
        }
        ),
        console.log("Mid meshes removed from scene and set to null.", this.scene)
    }
    setoffsetValueGroove(e, t) {
        this.modelManager.currentDisplayedModels.length == 1 && this.biColorSingleBool,
        this.modelManager.currentDisplayedModels.length == 2 && (t == "Ring 1" && (this.modelManager.midMesh.position.x = parseFloat(e),
        console.log("ring 1", this.modelManager.midMesh.position.x)),
        t == "Ring 2" && (this.modelManager.midMesh2.position.x = parseFloat(e),
        console.log("ring 2", this.modelManager.midMesh2.position.x)))
    }
    async toggleMilgrainGroove(e, t=!0) {
        (i => {
            i && i.traverse(r => {
                r.isMesh && r.name === "Mesh001" && (r.visible = t,
                t && (r.material || (r.material = new En),
                r.material.color.setStyle("#e4cd9d"),
                r.material.metalness = 1,
                r.material.roughness = 0))
            }
            )
        }
        )(e)
    }
    getScaleForModel(e, t) {
        let n = {
            x: .37,
            y: 1.15,
            z: 1.15
        };
        switch (e) {
        case "P1":
        case "P4":
        case "P6":
        case "P9":
        case "P11":
            n = {
                x: .37,
                y: 1.11,
                z: 1.11
            };
            break;
        case "P7":
        case "P15":
            n = {
                x: .37,
                y: 1.09,
                z: 1.09
            };
            break;
        case "P8":
            n = {
                x: .37,
                y: 1.06,
                z: 1.06
            };
            break;
        case "P12":
        case "P13":
        case "P14":
            n = {
                x: .37,
                y: 1.12,
                z: 1.12
            };
            break;
        default:
            console.log("Using default scale for modelId:", e);
            break
        }
        return t == "U-groove" && (n.x = n.x * 1.6),
        t == "Corner joint" && (n.x = n.x * 2.1),
        t == "Milgrain" && (n.x = n.x * 2.12),
        console.log("scale chk", n),
        this.defaultValueWidth1 = n.x,
        this.defaultValueDepth1 = n.y,
        n
    }
    removeMidMeshes() {
        const e = n => {
            if (n)
                return console.log("Removing mesh:", n),
                this.scene.remove(n),
                n.traverse(i => {
                    if (i.isMesh && ((i.name = "") && console.log("name AAAAAAA", i),
                    i.geometry.dispose(),
                    i.material))
                        if (Array.isArray(i.material))
                            i.material.forEach(r => {
                                for (const o in r)
                                    r[o] && r[o].isTexture && r[o].dispose();
                                r.dispose()
                            }
                            );
                        else {
                            for (const r in i.material)
                                i.material[r] && i.material[r].isTexture && i.material[r].dispose();
                            i.material.dispose()
                        }
                }
                ),
                n.visible = !1,
                null
        }
        ;
        this.modelManager.midMesh = e(this.modelManager.midMesh),
        this.modelManager.midMesh2 = e(this.modelManager.midMesh2),
        this.modelManager.midMeshTri = e(this.modelManager.midMeshTri),
        this.modelManager.midMeshTri2 = e(this.modelManager.midMeshTri2);
        let t = [];
        this.scene.traverse(n => {
            (n.userData === "midMeshRing1" || n.userData === "midMeshRing2") && (console.log("Removing from traverse:", n),
            t.push(n),
            n.name == "" && (console.log("name", n),
            t.push(n)))
        }
        ),
        t.forEach(n => {
            n.parent ? n.parent.remove(n) : this.scene.remove(n)
        }
        ),
        console.log("Mid meshes removed from scene and set to null.", this.scene)
    }
    adjustWidthAndDepth(e=null, t, n) {
        if (e = this.modelManager.selectedModel,
        console.log("razi work", e, t, n),
        e == 1)
            n == "width" ? t == .2 ? this.modelManager.midMesh.scale.x = this.defaultValueWidth1 : t == .3 ? this.modelManager.midMesh.scale.x = this.defaultValueWidth1 + .16 : t == .4 ? this.modelManager.midMesh.scale.x = this.defaultValueWidth1 + .32 : t == .5 && (this.modelManager.midMesh.scale.x = this.defaultValueWidth1 + .48) : n == "depth" && (t == .2 ? (this.modelManager.midMesh.scale.y = this.defaultValueDepth1,
            this.modelManager.midMesh.scale.z = this.defaultValueDepth1) : t == .3 ? (this.modelManager.midMesh.scale.y = this.defaultValueDepth1 - .008,
            this.modelManager.midMesh.scale.z = this.defaultValueDepth1 - .008) : t == .4 ? (this.modelManager.midMesh.scale.y = this.defaultValueDepth1 - .0125,
            this.modelManager.midMesh.scale.z = this.defaultValueDepth1 - .0125) : t == .5 ? (this.modelManager.midMesh.scale.y = this.defaultValueDepth1 - .0145,
            this.modelManager.midMesh.scale.z = this.defaultValueDepth1 - .0145) : t == .6 && (this.modelManager.midMesh.scale.y = this.defaultValueDepth1 - .0165,
            this.modelManager.midMesh.scale.z = this.defaultValueDepth1 - .0165));
        else if (e == 2) {
            const i = this.defaultValueWidth1 * .85
              , r = this.defaultValueDepth1 * .85;
            n == "width" ? t == .2 ? this.modelManager.midMesh2.scale.x = i : t == .3 ? this.modelManager.midMesh2.scale.x = i + .16 : t == .4 ? this.modelManager.midMesh2.scale.x = i + .32 : t == .5 && (this.modelManager.midMesh2.scale.x = i + .48) : n == "depth" && (t == .2 ? (this.modelManager.midMesh2.scale.y = r,
            this.modelManager.midMesh2.scale.z = r) : t == .3 ? (this.modelManager.midMesh2.scale.y = r - .008,
            this.modelManager.midMesh2.scale.z = r - .008) : t == .4 ? (this.modelManager.midMesh2.scale.y = r - .0125,
            this.modelManager.midMesh2.scale.z = r - .0125) : t == .5 ? (this.modelManager.midMesh2.scale.y = r - .0145,
            this.modelManager.midMesh2.scale.z = r - .0145) : t == .6 && (this.modelManager.midMesh2.scale.y = r - .0165,
            this.modelManager.midMesh2.scale.z = r - .0165))
        }
    }
    addGroove(e) {
        e == "Ring 1" && (this.grooveCountRing1 == 1 ? (this.modelManager.midmeshGroove1Ring1 = this.modelManager.midMesh.clone(),
        this.modelManager.midmeshGroove1Ring1.userData = "Groove1Ring1",
        this.modelManager.midmeshGroove1Ring1.position.x = -.7,
        this.modelManager.midMesh.position.x = -.65,
        this.modelManager.midmeshGroove1Ring1.position.x = -.75,
        this.scene.add(this.modelManager.midmeshGroove1Ring1),
        this.grooveCountRing1++,
        console.log("midMeshTri", this.modelManager.midMesh.position.x, this.modelManager.midmeshGroove1Ring1.position.x)) : this.grooveCountRing1 == 2 ? (this.modelManager.midmeshGroove2Ring1 = this.modelManager.midMesh.clone(),
        this.modelManager.midmeshGroove2Ring1.userData = "Groove2Ring1",
        this.modelManager.midMesh.position.x = -.62,
        this.modelManager.midmeshGroove1Ring1.position.x = -.7,
        this.modelManager.midmeshGroove2Ring1.position.x = -.78,
        this.scene.add(this.modelManager.midmeshGroove2Ring1),
        this.grooveCountRing1++) : this.grooveCountRing1 == 3 && (this.modelManager.midmeshGroove3Ring1 = this.modelManager.midMesh.clone(),
        this.modelManager.midmeshGroove3Ring1.userData = "Groove3Ring1",
        this.modelManager.midMesh.position.x = -.58,
        this.modelManager.midmeshGroove1Ring1.position.x = -.66,
        this.modelManager.midmeshGroove2Ring1.position.x = -.74,
        this.modelManager.midmeshGroove3Ring1.position.x = -.82,
        this.scene.add(this.modelManager.midmeshGroove3Ring1),
        this.grooveCountRing1++)),
        e == "Ring 2" && (this.grooveCountRing2 == 1 ? (this.modelManager.midmeshGroove1Ring2 = this.modelManager.midMesh2.clone(),
        this.modelManager.midmeshGroove1Ring2.userData = "Groove1Ring2",
        this.modelManager.midMesh2.position.x = .65,
        this.modelManager.midmeshGroove1Ring2.position.x = .75,
        this.grooveCountRing2++,
        this.scene.add(this.modelManager.midmeshGroove1Ring2)) : this.grooveCountRing2 == 2 ? (this.modelManager.midmeshGroove2Ring2 = this.modelManager.midMesh2.clone(),
        this.modelManager.midmeshGroove2Ring2.userData = "Groove2Ring2",
        this.modelManager.midMesh2.position.x = .62,
        this.modelManager.midmeshGroove1Ring2.position.x = .7,
        this.modelManager.midmeshGroove2Ring2.position.x = .78,
        this.grooveCountRing2++,
        this.scene.add(this.modelManager.midmeshGroove2Ring2)) : this.grooveCountRing2 == 3 && (this.modelManager.midmeshGroove3Ring2 = this.modelManager.midMesh2.clone(),
        this.modelManager.midmeshGroove3Ring2.userData = "Groove3Ring2",
        this.modelManager.midMesh2.position.x = .58,
        this.modelManager.midmeshGroove1Ring2.position.x = .66,
        this.modelManager.midmeshGroove2Ring2.position.x = .74,
        this.modelManager.midmeshGroove3Ring2.position.x = .82,
        this.grooveCountRing2++,
        this.scene.add(this.modelManager.midmeshGroove3Ring2)))
    }
    removeGroove(e) {
        if (e == "Ring 1" && this.grooveCountRing1 > 1) {
            let t;
            this.grooveCountRing1 == 4 ? (this.modelManager.midmeshGroove3Ring1,
            t = "Groove3Ring1",
            this.modelManager.midMesh.position.x = -.62,
            this.modelManager.midmeshGroove1Ring1.position.x = -.7,
            this.modelManager.midmeshGroove2Ring1.position.x = -.78) : this.grooveCountRing1 == 3 ? (this.modelManager.midmeshGroove2Ring1,
            t = "Groove2Ring1",
            this.modelManager.midMesh.position.x = -.65,
            this.modelManager.midmeshGroove1Ring1.position.x = -.75) : this.grooveCountRing1 == 2 && (this.modelManager.midmeshGroove1Ring1,
            t = "Groove1Ring1",
            this.modelManager.midMesh.position.x = -.7);
            let n = [];
            this.scene.traverse(i => {
                i.userData === t && n.push(i)
            }
            ),
            n.forEach(i => {
                i.parent && i.parent.remove(i),
                this.disposeAndRemove(i)
            }
            ),
            this.grooveCountRing1--
        }
        if (e == "Ring 2" && this.grooveCountRing2 > 1) {
            let t;
            this.grooveCountRing2 == 4 ? (this.modelManager.midmeshGroove3Ring2,
            t = "Groove3Ring2",
            this.modelManager.midMesh2.position.x = .62,
            this.modelManager.midmeshGroove1Ring2.position.x = .7,
            this.modelManager.midmeshGroove2Ring2.position.x = .78) : this.grooveCountRing2 == 3 ? (this.modelManager.midmeshGroove2Ring2,
            t = "Groove2Ring2",
            this.modelManager.midMesh2.position.x = .65,
            this.modelManager.midmeshGroove1Ring2.position.x = .75) : this.grooveCountRing2 == 2 && (this.modelManager.midmeshGroove1Ring2,
            t = "Groove1Ring2",
            this.modelManager.midMesh2.position.x = .7);
            let n = [];
            this.scene.traverse(i => {
                i.userData === t && n.push(i)
            }
            ),
            n.forEach(i => {
                i.parent && i.parent.remove(i),
                this.disposeAndRemove(i)
            }
            ),
            this.grooveCountRing2--
        }
    }
    disposeAndRemove(e) {
        if (e)
            return console.log("Removing mesh:", e),
            this.scene.remove(e),
            e.traverse(t => {
                if (t.isMesh && ((t.name = "") && console.log("name AAAAAAA", t),
                t.geometry.dispose(),
                t.material))
                    if (Array.isArray(t.material))
                        t.material.forEach(n => {
                            for (const i in n)
                                n[i] && n[i].isTexture && n[i].dispose();
                            n.dispose()
                        }
                        );
                    else {
                        for (const n in t.material)
                            t.material[n] && t.material[n].isTexture && t.material[n].dispose();
                        t.material.dispose()
                    }
            }
            ),
            e.visible = !1,
            null
    }
}
class M_ {
    constructor(e, t, n) {
        this.scene = e,
        this.modelManager = t,
        this.grooveManager = n
    }
    async addLeftStep(e) {
        const t = this.modelManager.currentDisplayedModels
          , n = ["P7", "P8", "P15"];
        for (const l of t)
            if (n.includes(l.userData.modelId)) {
                alert("This ring does not support Steps");
                return
            }
        const i = l => {
            const c = [0, 3, 5, 8, 11, 12, 13]
              , h = [1, 4]
              , d = [2, 9];
            return c.includes(l) ? {
                scaleY: -.04,
                scaleZ: -.04,
                positionOffset: 0
            } : h.includes(l) ? {
                scaleY: -.045,
                scaleZ: -.045,
                positionOffset: 0
            } : d.includes(l) ? {
                scaleY: -.047,
                scaleZ: -.047,
                positionOffset: -.002
            } : {
                scaleY: -.04,
                scaleZ: -.04,
                positionOffset: 0
            }
        }
          , r = async (l, c) => {
            await this.modelManager.loadStepMesh();
            const h = l ? this.modelManager.stepMesh : this.modelManager.stepMesh2
              , d = this.modelManager.cloneModelWithUniqueMaterial(h);
            e ? this.modelManager.GrooveManagerIns.toggleMilgrainGroove(d, e) : this.modelManager.GrooveManagerIns.toggleMilgrainGroove(d, !1),
            console.log(" bugg Initial scale:", d.scale);
            const u = l ? t[0].userData.modelIndex : t[1].userData.modelIndex
              , {scaleY: f, scaleZ: g, positionOffset: M} = i(u);
            return d.userData = l ? "leftStepRing1" : "leftStepRing2",
            d.position.x = c + M,
            d.scale.y *= 1 + f,
            d.scale.z *= 1 + g,
            console.log("bug Final scale:", d.scale),
            d
        }
        ;
        if (!this.modelManager.pair1) {
            const l = await r(this.modelManager.selectedModel === 1, this.modelManager.selectedModel === 1 ? -.865 : .565);
            this.scene.add(l),
            this.modelManager.selectedModel === 1 ? this.leftStep = l : this.leftStep2 = l;
            return
        }
        const o = await r(!0, -.865)
          , a = await r(!1, .565);
        this.leftStep = o,
        this.leftStep2 = a,
        this.scene.add(o),
        this.scene.add(a)
    }
    async addRightStep(e) {
        const t = this.modelManager.currentDisplayedModels
          , n = ["P7", "P8", "P15"];
        for (const l of t)
            if (n.includes(l.userData.modelId)) {
                alert("This ring does not support Steps");
                return
            }
        const i = l => {
            const c = [0, 3, 5, 8, 11, 12, 13]
              , h = [1, 4]
              , d = [2, 9];
            return c.includes(l) ? {
                scaleY: -.04,
                scaleZ: -.04,
                positionOffset: 0
            } : h.includes(l) ? {
                scaleY: -.045,
                scaleZ: -.045,
                positionOffset: 0
            } : d.includes(l) ? {
                scaleY: -.047,
                scaleZ: -.047,
                positionOffset: .016
            } : {
                scaleY: -.04,
                scaleZ: -.04,
                positionOffset: 0
            }
        }
          , r = async (l, c) => {
            await this.modelManager.loadStepMesh();
            const h = l ? this.modelManager.stepMesh : this.modelManager.stepMesh2
              , d = this.modelManager.cloneModelWithUniqueMaterial(h);
            e ? this.modelManager.GrooveManagerIns.toggleMilgrainGroove(d, e) : this.modelManager.GrooveManagerIns.toggleMilgrainGroove(d, !1);
            const u = l ? t[0].userData.modelIndex : t[1].userData.modelIndex
              , {scaleY: f, scaleZ: g, positionOffset: M} = i(u);
            return d.userData = l ? "rightStepRing1" : "rightStepRing2",
            d.position.x = c + M,
            d.scale.y *= 1 + f,
            d.scale.z *= 1 + g,
            console.log("Right Step Initial scale:", {
                ...d.scale
            }),
            console.log("Right Step Scale modifications:", {
                scaleY: f,
                scaleZ: g
            }),
            console.log("Right Step Final scale:", {
                ...d.scale
            }),
            d
        }
        ;
        if (!this.modelManager.pair1) {
            const l = await r(this.modelManager.selectedModel === 1, this.modelManager.selectedModel === 1 ? -.52 : .85);
            this.scene.add(l),
            this.modelManager.selectedModel === 1 ? this.rightStep = l : this.rightStep2 = l;
            return
        }
        const o = await r(!0, -.52)
          , a = await r(!1, .85);
        this.rightStep = o,
        this.rightStep2 = a,
        this.scene.add(o),
        this.scene.add(a)
    }
    removeLeftSteps() {
        const e = n => {
            if (n)
                return console.log("Removing left step mesh:", n),
                this.scene.remove(n),
                n.traverse(i => {
                    if (i.isMesh && (i.geometry.dispose(),
                    i.material))
                        if (Array.isArray(i.material))
                            i.material.forEach(r => {
                                for (const o in r)
                                    r[o] && r[o].isTexture && r[o].dispose();
                                r.dispose()
                            }
                            );
                        else {
                            for (const r in i.material)
                                i.material[r] && i.material[r].isTexture && i.material[r].dispose();
                            i.material.dispose()
                        }
                }
                ),
                n.visible = !1,
                null
        }
        ;
        this.leftStep = e(this.leftStep),
        this.leftStep2 = e(this.leftStep2);
        let t = [];
        this.scene.traverse(n => {
            (n.userData === "leftStepRing1" || n.userData === "leftStepRing2") && (console.log("Removing left step from traverse:", n),
            t.push(n))
        }
        ),
        t.forEach(n => {
            n.parent ? n.parent.remove(n) : this.scene.remove(n)
        }
        ),
        console.log("Left step meshes removed from scene and set to null.", this.scene)
    }
    removeRightSteps() {
        const e = n => {
            if (n)
                return console.log("Removing right step mesh:", n),
                this.scene.remove(n),
                n.traverse(i => {
                    if (i.isMesh && (i.geometry.dispose(),
                    i.material))
                        if (Array.isArray(i.material))
                            i.material.forEach(r => {
                                for (const o in r)
                                    r[o] && r[o].isTexture && r[o].dispose();
                                r.dispose()
                            }
                            );
                        else {
                            for (const r in i.material)
                                i.material[r] && i.material[r].isTexture && i.material[r].dispose();
                            i.material.dispose()
                        }
                }
                ),
                n.visible = !1,
                null
        }
        ;
        this.rightStep = e(this.rightStep),
        this.rightStep2 = e(this.rightStep2);
        let t = [];
        this.scene.traverse(n => {
            (n.userData === "rightStepRing1" || n.userData === "rightStepRing2") && (console.log("Removing right step from traverse:", n),
            t.push(n))
        }
        ),
        t.forEach(n => {
            n.parent ? n.parent.remove(n) : this.scene.remove(n)
        }
        ),
        console.log("Right step meshes removed from scene and set to null.", this.scene)
    }
}
class __ {
    constructor(e, t, n) {
        this.scene = e,
        this.modelManager = t,
        this.renderer = n,
        this.diamondMaterialManager = new Ca(n)
    }
    async loadDiamondToRing(e={}, t) {
        const n = {
            ringIndex: 1,
            scale: {
                x: 17.2,
                y: 17.2,
                z: 21.5
            },
            position: {
                x: 0,
                y: .5,
                z: 1.05
            },
            rotation: {
                x: -.13,
                y: 0,
                z: 0
            },
            textureUrl: "diamondMap/1b.jpg",
            textureUrlfire: "diamondm/diamond_fire.jpg",
            modelUrl: "diamondm/d1.glb",
            effects: {
                map: !1,
                normalMap: !0,
                roughnessMap: !1,
                metalnessMap: !1,
                emissiveMap: !1,
                aoMap: !1,
                envMap: !0,
                displacementMap: !1
            }
        }
          , i = {
            ...n,
            ...e
        };
        if (i.effects = {
            ...n.effects,
            ...e.effects
        },
        e.uniformScale) {
            const l = e.uniformScale;
            i.scale = {
                x: l,
                y: l,
                z: l
            }
        }
        e.scale && typeof e.scale != "object" ? i.scale = {
            x: e.scale,
            y: e.scale,
            z: e.scale
        } : e.scale && (i.scale = {
            x: e.scale.x !== void 0 ? e.scale.x : n.scale.x,
            y: e.scale.y !== void 0 ? e.scale.y : n.scale.y,
            z: e.scale.z !== void 0 ? e.scale.z : n.scale.z
        }),
        e.rotation && typeof e.rotation != "object" ? i.rotation = {
            x: e.rotation,
            y: e.rotation,
            z: e.rotation
        } : e.rotation && (i.rotation = {
            x: e.rotation.x !== void 0 ? e.rotation.x : n.rotation.x,
            y: e.rotation.y !== void 0 ? e.rotation.y : n.rotation.y,
            z: e.rotation.z !== void 0 ? e.rotation.z : n.rotation.z
        }),
        e.position && typeof e.position != "object" ? i.position = {
            x: e.position,
            y: e.position,
            z: e.position
        } : e.position && (i.position = {
            x: e.position.x !== void 0 ? e.position.x : n.position.x,
            y: e.position.y !== void 0 ? e.position.y : n.position.y,
            z: e.position.z !== void 0 ? e.position.z : n.position.z
        });
        const r = i.ringIndex - 1;
        if (r < 0 || r >= this.modelManager.currentDisplayedModels.length)
            return console.error(`Ring ${i.ringIndex} not found. Available rings: ${this.modelManager.currentDisplayedModels.length}`),
            Promise.reject(new Error(`Ring ${i.ringIndex} not found`));
        const o = this.modelManager.currentDisplayedModels[r];
        if (!o)
            return console.error(`Ring ${i.ringIndex} model not found`),
            Promise.reject(new Error(`Ring ${i.ringIndex} model not found`));
        const a = new it;
        a.name = "diamondHolder",
        o.userData.StoneType = t,
        a.renderOrder = 1e3,
        o.add(a),
        console.log("diamondHolder", a);
        try {
            const c = (await new Promise( (h, d) => {
                this.modelManager.loader.load(i.modelUrl, u => h(u), u => console.log(`Diamond loading: ${u.loaded / u.total * 100}% loaded`), u => d(u))
            }
            )).scene;
            if (c.name = "diamond",
            c.renderOrder = 1e3,
            c.scale.set(i.scale.x, i.scale.y, i.scale.z),
            c.rotation.set(i.rotation.x * Math.PI, i.rotation.y * Math.PI, i.rotation.z * Math.PI),
            a.position.set(i.position.x, i.position.y, i.position.z),
            a.add(c),
            c.traverse(h => {
                h.isMesh && h.material && (h.material.map && h.material.map.dispose(),
                h.material.normalMap && h.material.normalMap.dispose(),
                h.material.roughnessMap && h.material.roughnessMap.dispose(),
                h.material.metalnessMap && h.material.metalnessMap.dispose(),
                h.material.emissiveMap && h.material.emissiveMap.dispose(),
                h.material.aoMap && h.material.aoMap.dispose(),
                h.material.envMap && h.material.envMap.dispose(),
                h.material.displacementMap && h.material.displacementMap.dispose(),
                h.material.dispose(),
                h.material = this.diamondMaterialManager.createDiamondMaterial(),
                h.renderOrder = 4)
            }
            ),
            i.effects) {
                const h = [];
                c.traverse(d => {
                    if (d.isMesh && d.material) {
                        const u = this.diamondMaterialManager.applyDiamondTextures(d.material, i.textureUrl, i.effects);
                        h.push(u)
                    }
                }
                );
                try {
                    await Promise.all(h),
                    console.log("All diamond textures applied successfully")
                } catch (d) {
                    console.warn("Some diamond textures failed to load:", d)
                }
            }
            return console.log(`Diamond successfully added to ring ${i.ringIndex} with scale: ${JSON.stringify(i.scale)}, position: ${JSON.stringify(i.position)}, and rotation: ${JSON.stringify(i.rotation)}`),
            c
        } catch (l) {
            return console.error("Error loading diamond model:", l),
            a && o.remove(a),
            Promise.reject(l)
        }
    }
    async addDiamondsToRingFront(e={}) {
        var m;
        const t = {
            ringIndex: 1,
            diamondCount: 3,
            coverage: .1,
            distribution: "Together",
            baseScale: 4,
            individualScale: {
                x: 3.5,
                y: 3.5,
                z: 4
            },
            rotation: {
                x: 0,
                y: 0,
                z: 0
            },
            baseRadius: 1.15,
            startAngle: -Math.PI / 4,
            zOffset: .25,
            modelUrl: "diamondm/d1.glb",
            textureUrl: "diamondMap/1b.jpg",
            textureUrlfire: "diamondm/diamond_fire.jpg",
            effects: {
                map: !1,
                normalMap: !0,
                roughnessMap: !1,
                metalnessMap: !1,
                emissiveMap: !1,
                aoMap: !1,
                envMap: !0,
                displacementMap: !1
            }
        }
          , n = {
            ...t,
            ...e
        };
        n.effects = {
            ...t.effects,
            ...e.effects
        };
        const i = n.ringIndex - 1;
        if (i < 0 || i >= this.modelManager.currentDisplayedModels.length)
            return console.error(`Ring ${n.ringIndex} not found. Available rings: ${this.modelManager.currentDisplayedModels.length}`),
            Promise.reject(new Error(`Ring ${n.ringIndex} not found`));
        const r = this.modelManager.currentDisplayedModels[i];
        if (!r)
            return console.error(`Ring ${n.ringIndex} model not found`),
            Promise.reject(new Error(`Ring ${n.ringIndex} model not found`));
        if (console.log("targetRing razi", r),
        r.userData && r.userData.StoneType) {
            const p = r.userData.StoneType;
            switch (this.stoneTypeNumber = p,
            console.log(`Stone type detected: ${p}`),
            p) {
            case "Smooth conversion":
                n.modelUrl = "diamondm/d1.glb";
                break;
            case "Pav":
                n.modelUrl = "diamondm/circle.glb";
                break;
            case "Rail setting":
                n.modelUrl = "diamondm/rect.glb";
                break;
            case "Smooth Stone":
                n.modelUrl = "diamondm/d3.glb";
                break;
            case "Rail setting Across":
                n.modelUrl = "diamondm/engStone.glb";
                break;
            case "Smooth setting Across":
                n.modelUrl = "diamondm/oval.glb";
                break;
            default:
                console.log(`Using default diamond model for unknown stone type: ${p}`)
            }
        } else
            console.log("No stone type found in userData, using default diamond model");
        if (e.individualScale && (n.individualScale = {
            x: e.individualScale.x !== void 0 ? e.individualScale.x : t.individualScale.x,
            y: e.individualScale.y !== void 0 ? e.individualScale.y : t.individualScale.y,
            z: e.individualScale.z !== void 0 ? e.individualScale.z : t.individualScale.z
        }),
        e.uniformScale) {
            const p = e.uniformScale;
            n.individualScale = {
                x: p,
                y: p,
                z: p
            }
        }
        const o = Math.max(.9, 1 - n.diamondCount / 40)
          , a = {
            x: n.individualScale.x * n.baseScale * o,
            y: n.individualScale.y * n.baseScale * o,
            z: n.individualScale.z * n.baseScale * o * .6
        }
          , l = new it;
        l.name = "diamondsHolder",
        l.renderOrder = 1e3,
        r.add(l);
        let c = 1
          , h = n.coverage;
        switch (n.distribution) {
        case "Together":
            h = .1,
            c = 1;
            break;
        case "Half stone distance":
            h = .25,
            c = 1.5;
            break;
        case "Whole stone distance":
            h = .33,
            c = 2;
            break;
        case "Double stone spacing":
            h = .5,
            c = 3;
            break;
        case "A third ring":
            h = .33;
            break;
        case "Half ring":
            h = .5;
            break;
        case "Whole ring":
            h = 1;
            break;
        default:
            console.log(`Unknown distribution type: ${n.distribution}, using default coverage`)
        }
        console.log(`Distribution: ${n.distribution}, Effective coverage: ${h}`);
        const d = 2 * Math.PI * h
          , u = {
            Together: 8,
            "Half stone distance": 12,
            "Whole stone distance": 15,
            "Double stone spacing": 20,
            "A third ring": 30,
            "Half ring": 50,
            "Whole ring": 69
        };
        let f;
        if (n.distribution in u ? f = u[n.distribution] : f = 4,
        n.diamondCount > f) {
            const p = `Too many diamonds (${n.diamondCount}) for "${n.distribution}" distribution.
      Maximum allowed: ${f}.
      Proceeding with ${f} diamonds instead.`;
            console.warn(p),
            typeof alert == "function" && alert(p),
            n.diamondCount = f
        }
        let g = 0;
        n.diamondCount > 1 && (["Together", "Half stone distance", "Whole stone distance", "Double stone spacing"].includes(n.distribution) ? g = d / (n.diamondCount * c) * c : g = d / n.diamondCount);
        const M = n.startAngle - d / 2;
        console.log(`Loading diamond model: ${n.modelUrl}`),
        console.log(`Diamond placement: count=${n.diamondCount}, coverage=${h}, totalAngle=${d}, angleStep=${g}`);
        try {
            const p = await new Promise( (v, L) => {
                this.modelManager.loader.load(n.modelUrl, P => v(P), P => console.log(`Diamond loading: ${P.loaded / P.total * 100}% loaded`), P => L(P))
            }
            )
              , E = [];
            for (let v = 0; v < n.diamondCount; v++) {
                const L = p.scene.clone();
                L.name = `diamond_${v}`,
                L.renderOrder = 3;
                const P = M + v * g
                  , A = new it;
                if (A.name = `diamondHolder_${v}`,
                A.renderOrder = 3,
                A.position.set(Math.sin(P) * n.baseRadius, Math.cos(P) * n.baseRadius, n.zOffset),
                L.scale.set(a.x, a.y, a.z),
                L.traverse(w => {
                    w.isMesh && w.material && (w.material.map && w.material.map.dispose(),
                    w.material.normalMap && w.material.normalMap.dispose(),
                    w.material.roughnessMap && w.material.roughnessMap.dispose(),
                    w.material.metalnessMap && w.material.metalnessMap.dispose(),
                    w.material.emissiveMap && w.material.emissiveMap.dispose(),
                    w.material.aoMap && w.material.aoMap.dispose(),
                    w.material.envMap && w.material.envMap.dispose(),
                    w.material.displacementMap && w.material.displacementMap.dispose(),
                    w.material.dispose(),
                    w.material = this.diamondMaterialManager.createDiamondMaterial(),
                    w.material.depthWrite = !0,
                    w.material.depthTest = !0,
                    w.material.polygonOffset = !1,
                    w.material.stencilWrite = !0,
                    w.material.stencilRef = 2,
                    w.material.stencilFunc = ii,
                    w.material.stencilZPass = fs,
                    w.renderOrder = 3,
                    w.material.needsUpdate = !0)
                }
                ),
                n.effects) {
                    const w = [];
                    L.traverse(S => {
                        if (S.isMesh && S.material) {
                            const y = this.diamondMaterialManager.applyDiamondTextures(S.material, n.textureUrl, n.effects);
                            w.push(y)
                        }
                    }
                    );
                    try {
                        await Promise.all(w)
                    } catch (S) {
                        console.warn("Failed to apply textures to diamond:", S)
                    }
                }
                l.renderOrder = 3,
                A.renderOrder = 3,
                E.renderOrder = 3,
                A.add(L),
                l.add(A),
                E.push(L)
            }
            l.rotation.y = Math.PI / 2,
            l.position.x = -.25,
            l.position.y = 0,
            console.log("diamondHolder numbeer", l.position);
            const _ = (m = r.userData) == null ? void 0 : m.modelIndex;
            return _ === 0 ? (l.scale.x += .013,
            l.scale.y += .013) : _ === 1 || _ == 2 ? (l.scale.x += .042,
            l.scale.y += .042) : _ == 4 ? (l.scale.x += .035,
            l.scale.y += .035) : _ == 5 ? (l.scale.x += .005,
            l.scale.y += .005) : _ == 6 ? (l.scale.x -= .027,
            l.scale.y -= .027) : _ == 7 || _ == 8 || (_ == 9 ? (l.scale.x += .035,
            l.scale.y += .035) : _ == 10 || (_ == 11 ? (l.scale.x += .023,
            l.scale.y += .023) : _ == 12 || _ == 13 || (_ == 14 ? (l.scale.x -= .027,
            l.scale.y -= .027) : l.position.z = .14))),
            l.children.forEach( (v, L) => {
                const P = M + L * g;
                if (v.children.length > 0) {
                    const A = v.children[0];
                    A.rotation.set(0, 0, 0),
                    this.stoneTypeNumber == "Rail setting Across" ? (A.rotateX(-Math.PI / 2),
                    A.rotateY(P),
                    A.rotateZ(-Math.PI / 2)) : (A.rotateX(-Math.PI / 2),
                    A.rotateY(P),
                    A.rotateZ(Math.PI / 2))
                }
            }
            ),
            console.log(`Added ${n.diamondCount} diamonds to the front of ring ${n.ringIndex}`),
            E
        } catch (p) {
            return console.error("Error loading diamond models:", p),
            l && r.remove(l),
            Promise.reject(p)
        }
    }
    applyStencilSettingsToAllDiamonds() {
        this.scene.traverse(e => {
            e.name && (e.name.includes("diamond") || e.name.includes("diamondHolder")) && (e.renderOrder = 1e3,
            e.traverse(t => {
                t.isMesh && t.material && (t.material.stencilWrite = !0,
                t.material.stencilRef = 2,
                t.material.stencilFunc = ii,
                t.material.stencilZPass = fs,
                t.material.depthTest = !0,
                t.material.depthWrite = !0,
                t.material.needsUpdate = !0)
            }
            ))
        }
        )
    }
    changeDiamondRotation(e, t=null) {
        const n = t || this.modelManager.selectedModel
          , i = n - 1;
        if (i < 0 || i >= this.modelManager.currentDisplayedModels.length) {
            console.error(`Ring ${n} not found for changing diamond rotation.`);
            return
        }
        const r = this.modelManager.currentDisplayedModels[i];
        if (!r) {
            console.error(`Ring model ${n} not found for changing diamond rotation.`);
            return
        }
        const o = r.getObjectByName("diamondHolder");
        if (!o) {
            console.log(`No diamond found on ring ${n} to rotate.`);
            return
        }
        let a = null;
        if (o.traverse(l => {
            l.name === "diamond" && (a = l)
        }
        ),
        !a) {
            console.error(`Diamond model not found inside holder on ring ${n}.`);
            return
        }
        e.x !== void 0 && (a.rotation.x = e.x * Math.PI),
        e.y !== void 0 && (a.rotation.y = e.y * Math.PI),
        e.z !== void 0 && (a.rotation.z = e.z * Math.PI),
        console.log(`Changed diamond rotation on ring ${n} to:`, e)
    }
    dispose() {
        this.diamondMaterialManager && this.diamondMaterialManager.dispose()
    }
    removeDiamondsFromRing(e=1) {
        const t = e - 1;
        if (t < 0 || t >= this.modelManager.currentDisplayedModels.length) {
            console.error(`Ring ${e} not found. Available rings: ${this.modelManager.currentDisplayedModels.length}`);
            return
        }
        const n = this.modelManager.currentDisplayedModels[t];
        if (!n) {
            console.error(`Ring ${e} model not found`);
            return
        }
        let i = n.getObjectByName("diamondsHolder");
        if (i || (i = n.getObjectByName("diamondHolder")),
        console.log(i, "diamondsHolder", n, "targetRing"),
        i) {
            const r = o => {
                for (; o.children.length > 0; )
                    r(o.children[0]),
                    o.remove(o.children[0]);
                o.isMesh && (o.geometry && o.geometry.dispose(),
                o.material && (Array.isArray(o.material) ? o.material.forEach(a => a.dispose()) : o.material.dispose()))
            }
            ;
            r(i),
            n.remove(i),
            console.log(`Diamonds removed from ring ${e}`)
        } else
            console.log(`No diamonds found on ring ${e}`)
    }
    changeStoneSize(e, t=null) {
        const n = t || this.modelManager.selectedModel
          , i = n - 1;
        if (i < 0 || i >= this.modelManager.currentDisplayedModels.length) {
            console.error(`Ring ${n} not found for resizing diamonds.`);
            return
        }
        const r = this.modelManager.currentDisplayedModels[i];
        if (!r) {
            console.error(`Ring model ${n} not found for resizing diamonds.`);
            return
        }
        let o = r.getObjectByName("diamondsHolder");
        if (!o && (o = r.getObjectByName("diamondHolder"),
        !o)) {
            console.log(`No diamonds found on ring ${n} to resize.`);
            return
        }
        const a = 19.7;
        let l;
        e.includes("1.3") ? (console.log("Setting diamond size to 1.3mm"),
        l = a * 1.15) : e.includes("1.5") ? (console.log("Setting diamond size to 1.5mm"),
        l = a * 1.2) : (console.log("Setting diamond size to 1.0mm"),
        l = a);
        let c = 0;
        if (o.name === "diamondsHolder")
            o.children.forEach( (h, d) => {
                if (h.children.length > 0) {
                    const u = h.children[0]
                      , f = u.scale.z;
                    u.scale.set(l, l, f),
                    c++
                }
            }
            );
        else {
            let h = null;
            if (o.traverse(d => {
                d.name === "diamond" && (h = d)
            }
            ),
            h) {
                const d = h.scale.z;
                h.scale.set(l, l, d),
                c = 1
            }
        }
        console.log(`Changed ${c} diamond(s) size on ring ${n} to ${e} (Scale: ${l})`)
    }
    changeStonePosition(e, t=null, n=null) {
        const i = t || this.modelManager.selectedModel
          , r = i - 1;
        if (r < 0 || r >= this.modelManager.currentDisplayedModels.length) {
            console.error(`Ring ${i} not found for repositioning diamonds.`);
            return
        }
        const o = this.modelManager.currentDisplayedModels[r];
        if (!o) {
            console.error(`Ring model ${i} not found for repositioning diamonds.`);
            return
        }
        let a = o.getObjectByName("diamondsHolder");
        if (!a && (a = o.getObjectByName("diamondHolder"),
        console.log("helo", a),
        !a)) {
            console.log(`No diamonds found on ring ${i} to reposition.`);
            return
        }
        let l = 0;
        if (o.getObjectByName("diamondHolder"))
            switch (e) {
            case "Left":
                l += -.05;
                break;
            case "Right":
                l += .05;
                break;
            case "Middle":
                l += 0;
                break;
            case "Free":
                console.log("Free position not available");
                return;
            default:
                console.warn(`Unknown position: ${e}. Using 'Middle' as default.`),
                l = 0
            }
        else
            switch (e) {
            case "Left":
                l += -.05,
                l += -.25;
                break;
            case "Right":
                l += .05,
                l += -.25;
                break;
            case "Middle":
                l += 0,
                l = -.25;
                break;
            case "Free":
                console.log("Free position not available");
                return;
            default:
                console.warn(`Unknown position: ${e}. Using 'Middle' as default.`),
                l = 0,
                l = -.25
            }
        a.position.x,
        a.position.x = l,
        console.log(`Changed diamond position on ring ${i} to ${e} (X: ${l})`)
    }
    handleStonePositionSlider(e, t=null) {
        const n = t ? t.includes("2") ? 2 : 1 : this.modelManager.selectedModel
          , i = n - 1;
        if (i < 0 || i >= this.modelManager.currentDisplayedModels.length) {
            console.error(`Ring ${n} not found for repositioning stones.`);
            return
        }
        const r = this.modelManager.currentDisplayedModels[i];
        if (!r) {
            console.error(`Ring model ${n} not found for repositioning stones.`);
            return
        }
        let o = r.getObjectByName("diamondsHolder")
          , a = !1;
        if (!o && (o = r.getObjectByName("diamondHolder"),
        a = !0,
        !o)) {
            console.log(`No stones found on ring ${n} to reposition.`);
            return
        }
        const l = a ? e : e - .25;
        o.position.x = l;
        let c = "Center";
        e < -.03 ? c = "Left" : e > .03 && (c = "Right"),
        console.log(`Changed stone position on ring ${n} to ${c} (X: ${l.toFixed(3)})`)
    }
}
class v_ {
    constructor(e, t, n) {
        this.scene = e,
        this.modelManager = t,
        this.renderer = n,
        this.ringPath = null,
        this.diamondMaterialManager = new Ca(n),
        this.modelData = [{
            glbPath: "models/memoir/01.glb",
            texturePath: "path/to/texture1.jpg"
        }, {
            glbPath: "models/memoir/02.glb",
            texturePath: "path/to/texture2.jpg"
        }, {
            glbPath: "models/memoir/03.glb"
        }, {
            glbPath: "models/memoir/04.glb"
        }, {
            glbPath: "models/memoir/05.glb"
        }, {
            glbPath: "models/memoir/06.glb"
        }, {
            glbPath: "models/memoir/07.glb"
        }, {
            glbPath: "models/memoir/08.glb"
        }, {
            glbPath: "models/memoir/09.glb"
        }, {
            glbPath: "models/memoir/10.glb"
        }, {
            glbPath: "models/memoir/11.glb"
        }, {
            glbPath: "models/memoir/12.glb"
        }, {
            glbPath: "models/memoir/13.glb"
        }, {
            glbPath: "models/memoir/14.glb"
        }, {
            glbPath: "models/memoir/15.glb"
        }, {
            glbPath: "models/memoir/16.glb"
        }, {
            glbPath: "models/memoir/17.glb"
        }, {
            glbPath: "models/memoir/18.glb"
        }, {
            glbPath: "models/memoir/19.glb"
        }, {
            glbPath: "models/memoir/20.glb"
        }, {
            glbPath: "models/memoir/21.glb"
        }, {
            glbPath: "models/memoir/22.glb"
        }, {
            glbPath: "models/memoir/23.glb"
        }, {
            glbPath: "models/memoir/24.glb"
        }, {
            glbPath: "models/memoir/25.glb"
        }, {
            glbPath: "models/memoir/26.glb"
        }, {
            glbPath: "models/memoir/27.glb"
        }, {
            glbPath: "models/memoir/28.glb"
        }, {
            glbPath: "models/memoir/29.glb"
        }, {
            glbPath: "models/memoir/30.glb"
        }, {
            glbPath: "models/memoir/31.glb"
        }, {
            glbPath: "models/memoir/32.glb"
        }, {
            glbPath: "models/memoir/33.glb"
        }, {
            glbPath: "models/memoir/34.glb"
        }, {
            glbPath: "models/memoir/35.glb"
        }, {
            glbPath: "models/memoir/36.glb"
        }, {
            glbPath: "models/memoir/37.glb"
        }, {
            glbPath: "models/memoir/38.glb"
        }, {
            glbPath: "models/memoir/39.glb"
        }, {
            glbPath: "models/memoir/40.glb"
        }, {
            glbPath: "models/memoir/41.glb"
        }, {
            glbPath: "models/memoir/42.glb"
        }, {
            glbPath: "models/memoir/43.glb"
        }, {
            glbPath: "models/memoir/44.glb"
        }, {
            glbPath: "models/memoir/45.glb"
        }, {
            glbPath: "models/memoir/46.glb"
        }, {
            glbPath: "models/memoir/47.glb"
        }, {
            glbPath: "models/memoir/48.glb"
        }, {
            glbPath: "models/memoir/49.glb"
        }, {
            glbPath: "models/memoir/50.glb"
        }]
    }
    async loadMemoirRingById(e) {
        try {
            e = e - 1;
            const t = document.querySelector(".loader-overlay");
            if (t && (t.style.display = "block"),
            console.log(`Loading memoir ring model with ID: ${e}`),
            e < 0 || e > this.modelData.length)
                throw new Error(`Invalid ID: ${e}. Please provide a valid model ID.`);
            const n = this.modelData[e];
            if (!n.glbPath)
                throw new Error(`Model path not found for ID: ${e}`);
            const i = new wr
              , o = (await new Promise( (a, l) => {
                i.load(n.glbPath, c => a(c), c => console.log(`${c.loaded / c.total * 100}% loaded`), c => l(new Error(`Error loading model: ${n.glbPath} - ${c}`)))
            }
            )).scene;
            return o.position.x = .7,
            o.position.y = -.18,
            o.scale.set(.85, .85, .85),
            this.scene.add(o),
            this.modelManager.currentDisplayedModels.push(o),
            console.log("model apply diamond texture to ring", o),
            this.applyDiamondTextureToRing(o),
            console.log(`Model loaded successfully: ${n.glbPath}`, o),
            t && (t.style.display = "none"),
            o
        } catch (t) {
            console.error(t.message);
            const n = document.querySelector(".loader-overlay");
            return n && (n.style.display = "none"),
            null
        }
    }
    applyColorExcludingMeshes(e, t, n=!1) {
        e.traverse(i => {
            i.isMesh && (n == !0 && i.name.includes("ring") && (i.material && i.material.color && i.material.color.set(t),
            console.warn("aaaaaa", i.name)),
            i.name.includes("Diam") && !n || i.material && i.material.color && !n && (console.warn("aaaaaa 2"),
            i.material.color.set(t)))
        }
        )
    }
    applyDiamondTextureToRing(e) {
        const t = {
            map: !1,
            normalMap: !0,
            roughnessMap: !1,
            metalnessMap: !1,
            emissiveMap: !1,
            aoMap: !1,
            envMap: !0,
            displacementMap: !1
        }
          , n = "diamondMap/1b.jpg";
        e.traverse(i => {
            if (i.isMesh && i.name.toLowerCase().includes("mon")) {
                console.log(`Applying diamond material to: ${i.name}`),
                i.material && (i.material.map && i.material.map.dispose(),
                i.material.normalMap && i.material.normalMap.dispose(),
                i.material.roughnessMap && i.material.roughnessMap.dispose(),
                i.material.metalnessMap && i.material.metalnessMap.dispose(),
                i.material.emissiveMap && i.material.emissiveMap.dispose(),
                i.material.aoMap && i.material.aoMap.dispose(),
                i.material.envMap && i.material.envMap.dispose(),
                i.material.displacementMap && i.material.displacementMap.dispose(),
                i.material.dispose()),
                i.material = this.diamondMaterialManager.createDiamondMaterial(),
                i.renderOrder = 4;
                const r = () => {
                    this.diamondMaterialManager.envMapPMREM && (console.log("applyEnvMap", this.diamondMaterialManager.envMapPMREM),
                    i.material.metalness = .6,
                    i.material.roughness = 0,
                    i.material.envMapIntensity = 1.5,
                    i.material.transmission = 1,
                    i.material.ior = 1.2,
                    i.material.reflectivity = 1.2,
                    i.material.clearcoat = 1,
                    i.material.clearcoatRoughness = 0,
                    i.material.thickness = 2,
                    i.material.transparent = !0,
                    i.material.opacity = .9,
                    i.material.depthWrite = !0,
                    i.material.depthTest = !0,
                    i.material.polygonOffset = !1,
                    i.material.specularIntensity = 1,
                    i.material.specularColor = new be(1,1,1),
                    i.material.side = Bt,
                    i.material.envMap = this.diamondMaterialManager.envMapPMREM,
                    i.material.needsUpdate = !0)
                }
                ;
                if (this.diamondMaterialManager.envMapPMREM)
                    console.log("applyEnvMap", this.diamondMaterialManager.envMapPMREM),
                    r();
                else {
                    const o = () => {
                        this.diamondMaterialManager.envMapPMREM ? (console.log("applyEnvMap", this.diamondMaterialManager.envMapPMREM),
                        r()) : setTimeout(o, 100)
                    }
                    ;
                    o()
                }
                this.diamondMaterialManager.applyDiamondTextures(i.material, n, t).then( () => {
                    console.log(`Diamond material applied successfully to: ${i.name}`)
                }
                ).catch(o => {
                    console.warn(`Failed to apply diamond textures to ${i.name}:`, o)
                }
                )
            }
        }
        ),
        console.log("Diamond materials applied successfully to memoir ring model", e)
    }
    dispose() {
        this.diamondMaterialManager && this.diamondMaterialManager.dispose()
    }
}
class x_ {
    constructor() {
        this.scene = new zg,
        this.scene.background = new be("#FFFFFF"),
        this.scene.env = null,
        this.cameraInstance = new c0(this.scene),
        this.camera = this.cameraInstance.getCamera(),
        this.rendererInstance = new h0,
        this.renderer = this.rendererInstance.getRenderer(),
        this.renderer.localClippingEnabled = !0,
        this.PreciousMetalins = new h_(this.scene,null,null,this.renderer),
        this.modelManager = new u_(this.scene,this.PreciousMetalins,this.renderer),
        this.PreciousMetalins.modelManager = this.modelManager,
        this.PreciousMetalHelper = new p_(this.scene,this.PreciousMetalins,this.modelManager),
        this.EngagementRings = new m_(this.scene,this.modelManager,this.renderer),
        this.MemoirRings = new v_(this.scene,this.modelManager,this.renderer),
        this.GrooveManager = new g_(this.scene,this.modelManager),
        this.StepsManager = new M_(this.scene,this.modelManager,this.GrooveManager),
        this.StoneManager = new __(this.scene,this.modelManager,this.renderer),
        this.modelManager.StoneManagerIns = this.StoneManager,
        this.modelManager.EngagementRingsins = this.EngagementRings,
        this.modelManager.MemoirRingsins = this.MemoirRings,
        this.modelManager.GrooveManagerIns = this.GrooveManager,
        this.modelManager.StepsManagerIns = this.StepsManager,
        this.PreciousMetalins.pmHelper = this.PreciousMetalHelper,
        this.lighting = new r0(this.scene),
        this.floor = new o0(this.scene,this.camera,this.renderer),
        this.environment = new l0(this.scene,this.renderer),
        this.OrbitControlHandler = new T0(this.camera,this.renderer.domElement),
        this.messageHandler = new f_(this.modelManager,this.PreciousMetalins),
        document.body.appendChild(this.renderer.domElement),
        document.addEventListener("environmentLoaded", () => {
            const e = [{
                glbPath: "models/p1.glb",
                texturePath: "path/to/texture2.jpg"
            }, {
                glbPath: "models/p2.glb",
                texturePath: "path/to/texture3.jpg"
            }, {
                glbPath: "models/p3.glb",
                texturePath: "path/to/texture1.jpg"
            }, {
                glbPath: "models/p4.glb"
            }, {
                glbPath: "models/p5.glb"
            }, {
                glbPath: "models/p6.glb"
            }, {
                glbPath: "models/p7.glb"
            }, {
                glbPath: "models/p8.glb"
            }, {
                glbPath: "models/p9.glb"
            }, {
                glbPath: "models/p10.glb"
            }, {
                glbPath: "models/p11.glb"
            }, {
                glbPath: "models/p12.glb"
            }, {
                glbPath: "models/p13.glb"
            }, {
                glbPath: "models/p14.glb"
            }, {
                glbPath: "models/p15.glb"
            }];
            this.modelManager.loadModels(e),
            console.log("Models loaded after environment")
        }
        ),
        window.addEventListener("resize", this.onWindowResize.bind(this)),
        this.animate(),
        console.log("App initialized")
    }
    showCurrentModels() {
        this.modelManager.showCurrentModels(this.currentModelIndex)
    }
    hideCurrentModels() {
        this.modelManager.hideCurrentModels()
    }
    addSecondModel(e, t) {
        this.modelManager.addSecondModel(e, t)
    }
    addThirdModel(e, t) {
        this.modelManager.addThirdModel(e, t)
    }
    addFourthModel(e, t) {
        this.modelManager.addFourthModel(e, t)
    }
    removeThirdModel() {
        this.modelManager.removeThirdModel()
    }
    removeFourthModel() {
        this.modelManager.removeFourthModel()
    }
    removeSecondModel() {
        this.modelManager.removeSecondModel()
    }
    switchModelLocal(e) {}
    onWindowResize() {
        this.camera.aspect = window.innerWidth / window.innerHeight,
        this.camera.updateProjectionMatrix(),
        this.renderer.setSize(window.innerWidth, window.innerHeight)
    }
    animate() {
        requestAnimationFrame(this.animate.bind(this)),
        this.OrbitControlHandler.updateControls(),
        this.renderer.render(this.scene, this.camera)
    }
}
window.app = new x_;
